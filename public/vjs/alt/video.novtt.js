/**
 * @license
 * Video.js 5.0.0-0 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":3}],2:[function(_dereq_,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],5:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('./button');

var _Button3 = _interopRequireWildcard(_Button2);

/* Big Play Button
================================================================================ */
/**
 * Initial play button. Shows before the video has played. The hiding of the
 * big play button is done via CSS and player states.
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var BigPlayButton = (function (_Button) {
  function BigPlayButton() {
    _classCallCheck(this, BigPlayButton);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(BigPlayButton, _Button);

  _createClass(BigPlayButton, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(BigPlayButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-big-play-button',
        innerHTML: '<span aria-hidden="true"></span>',
        'aria-label': 'play video'
      });
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      this.player_.play();
    }
  }]);

  return BigPlayButton;
})(_Button3['default']);

_Button3['default'].registerComponent('BigPlayButton', BigPlayButton);
exports['default'] = BigPlayButton;
module.exports = exports['default'];

},{"./button":6}],6:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('./events');

var Events = _interopRequireWildcard(_import2);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/* Button - Base class for all buttons
================================================================================ */
/**
 * Base class for all buttons
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Button = (function (_Component) {
  function Button(player, options) {
    _classCallCheck(this, Button);

    _get(Object.getPrototypeOf(Button.prototype), 'constructor', this).call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.onClick);
    this.on('click', this.onClick);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
  }

  _inherits(Button, _Component);

  _createClass(Button, [{
    key: 'createEl',
    value: function createEl(type, props) {
      // Add standard Aria and Tabindex info
      props = Lib.obj.merge({
        className: this.buildCSSClass(),
        role: 'button',
        'aria-live': 'polite', // let the screen reader user know that the text of the button may change
        tabIndex: 0
      }, props);

      var el = _get(Object.getPrototypeOf(Button.prototype), 'createEl', this).call(this, type, props);

      // if innerHTML hasn't been overridden (bigPlayButton), add content elements
      if (!props.innerHTML) {
        this.contentEl_ = Lib.createEl('div', {
          className: 'vjs-control-content'
        });

        this.controlText_ = Lib.createEl('span', {
          className: 'vjs-control-text',
          innerHTML: this.localize(this.buttonText) || 'Need Text'
        });

        this.contentEl_.appendChild(this.controlText_);
        el.appendChild(this.contentEl_);
      }

      return el;
    }
  }, {
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      // TODO: Change vjs-control to vjs-button?
      return 'vjs-control ' + _get(Object.getPrototypeOf(Button.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'onClick',

    // Click - Override with specific functionality for button
    value: function onClick() {}
  }, {
    key: 'onFocus',

    // Focus - Add keyboard functionality to element
    value: function onFocus() {
      Events.on(_document2['default'], 'keydown', Lib.bind(this, this.onKeyPress));
    }
  }, {
    key: 'onKeyPress',

    // KeyPress (document level) - Trigger click when keys are pressed
    value: function onKeyPress(event) {
      // Check for space bar (32) or enter (13) keys
      if (event.which == 32 || event.which == 13) {
        event.preventDefault();
        this.onClick();
      }
    }
  }, {
    key: 'onBlur',

    // Blur - Remove keyboard triggers
    value: function onBlur() {
      Events.off(_document2['default'], 'keydown', Lib.bind(this, this.onKeyPress));
    }
  }]);

  return Button;
})(_Component3['default']);

_Component3['default'].registerComponent('Button', Button);
exports['default'] = Button;
module.exports = exports['default'];

},{"./component":7,"./events":43,"./lib":46,"global/document":1}],7:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Player Component - Base class for all UI objects
 *
 */

var _import = _dereq_('./lib.js');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('./util.js');

var VjsUtil = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./events.js');

var Events = _interopRequireWildcard(_import3);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

/**
 * Base UI Component class
 *
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 *
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 *
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 *
 * Components are also event emitters.
 *
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *
 *     button.trigger('customevent');
 *
 * @param {Object} player  Main Player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Component = (function () {
  function Component(player, options, ready) {
    _classCallCheck(this, Component);

    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this;
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding global defaults
    this.options_ = Lib.obj.copy(this.options_);

    // Updated options with supplied options
    options = this.options(options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player.id && player.id() || 'no_player';
      this.id_ = '' + id + '_component_' + Lib.guid++;
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  _createClass(Component, [{
    key: 'init',

    // Temp for ES6 class transition, remove before 5.0
    value: function init() {
      // console.log('init called on Component');
      Component.apply(this, arguments);
    }
  }, {
    key: 'dispose',

    /**
     * Dispose of the component and all child components
     */
    value: function dispose() {
      this.trigger({ type: 'dispose', bubbles: false });

      // Dispose all children.
      if (this.children_) {
        for (var i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }

      // Delete child references
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;

      // Remove all event listeners.
      this.off();

      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      Lib.removeData(this.el_);
      this.el_ = null;
    }
  }, {
    key: 'player',

    /**
     * Return the component's player
     *
     * @return {Player}
     */
    value: function player() {
      return this.player_;
    }
  }, {
    key: 'options',

    /**
     * Deep merge of options objects
     *
     * Whenever a property is an object on both options objects
     * the two properties will be merged using Lib.obj.deepMerge.
     *
     * This is used for merging options for child components. We
     * want it to be easy to override individual options on a child
     * component without having to rewrite all the other default options.
     *
     *     Parent.prototype.options_ = {
     *       children: {
     *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
     *         'childTwo': {},
     *         'childThree': {}
     *       }
     *     }
     *     newOptions = {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'abc': '123' }
     *         'childTwo': null,
     *         'childFour': {}
     *       }
     *     }
     *
     *     this.options(newOptions);
     *
     * RESULT
     *
     *     {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
     *         'childTwo': null, // Disabled. Won't be initialized.
     *         'childThree': {},
     *         'childFour': {}
     *       }
     *     }
     *
     * @param  {Object} obj Object of new option values
     * @return {Object}     A NEW object of this.options_ and obj merged
     */
    value: function options(obj) {
      if (obj === undefined) {
        return this.options_;
      }return this.options_ = VjsUtil.mergeOptions(this.options_, obj);
    }
  }, {
    key: 'el',

    /**
     * Get the component's DOM element
     *
     *     var domEl = myComponent.el();
     *
     * @return {Element}
     */
    value: function el() {
      return this.el_;
    }
  }, {
    key: 'createEl',

    /**
     * Create the component's DOM element
     *
     * @param  {String=} tagName  Element's node type. e.g. 'div'
     * @param  {Object=} attributes An object of element attributes that should be set on the element
     * @return {Element}
     */
    value: function createEl(tagName, attributes) {
      return Lib.createEl(tagName, attributes);
    }
  }, {
    key: 'localize',
    value: function localize(string) {
      var lang = this.player_.language();
      var languages = this.player_.languages();

      if (languages && languages[lang] && languages[lang][string]) {
        return languages[lang][string];
      }

      return string;
    }
  }, {
    key: 'contentEl',

    /**
     * Return the component's DOM element where children are inserted.
     * Will either be the same as el() or a new element defined in createEl().
     *
     * @return {Element}
     */
    value: function contentEl() {
      return this.contentEl_ || this.el_;
    }
  }, {
    key: 'id',

    /**
     * Get the component's ID
     *
     *     var id = myComponent.id();
     *
     * @return {String}
     */
    value: function id() {
      return this.id_;
    }
  }, {
    key: 'name',

    /**
     * Get the component's name. The name is often used to reference the component.
     *
     *     var name = myComponent.name();
     *
     * @return {String}
     */
    value: function name() {
      return this.name_;
    }
  }, {
    key: 'children',

    /**
     * Get an array of all child components
     *
     *     var kids = myComponent.children();
     *
     * @return {Array} The children
     */
    value: function children() {
      return this.children_;
    }
  }, {
    key: 'getChildById',

    /**
     * Returns a child component with the provided ID
     *
     * @return {Component}
     */
    value: function getChildById(id) {
      return this.childIndex_[id];
    }
  }, {
    key: 'getChild',

    /**
     * Returns a child component with the provided name
     *
     * @return {Component}
     */
    value: function getChild(name) {
      return this.childNameIndex_[name];
    }
  }, {
    key: 'addChild',

    /**
     * Adds a child component inside this component
     *
     *     myComponent.el();
     *     // -> <div class='my-component'></div>
     *     myComponent.children();
     *     // [empty array]
     *
     *     var myButton = myComponent.addChild('MyButton');
     *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
     *     // -> myButton === myComonent.children()[0];
     *
     * Pass in options for child constructors and options for children of the child
     *
     *     var myButton = myComponent.addChild('MyButton', {
     *       text: 'Press Me',
     *       children: {
     *         buttonChildExample: {
     *           buttonChildOption: true
     *         }
     *       }
     *     });
     *
     * @param {String|Component} child The class name or instance of a child to add
     * @param {Object=} options Options, including options to be passed to children of the child.
     * @return {Component} The child component (created by this process if a string was used)
     * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
     */
    value: function addChild(child) {
      var options = arguments[1] === undefined ? {} : arguments[1];

      var component = undefined;
      var componentName = undefined;

      // If child is a string, create nt with options
      if (typeof child === 'string') {
        componentName = child;

        // Options can also be specified as a boolean, so convert to an empty object if false.
        if (!options) {
          options = {};
        }

        // Same as above, but true is deprecated so show a warning.
        if (options === true) {
          Lib.log.warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');
          options = {};
        }

        // If no componentClass in options, assume componentClass is the name lowercased
        // (e.g. playButton)
        var componentClassName = options.componentClass || Lib.capitalize(componentName);

        // Set name through options
        options.name = componentName;

        // Create a new object & element for this controls set
        // If there's no .player_, this is a player
        var componentClass = Component.getComponent(componentClassName);

        component = new componentClass(this.player_ || this, options);

        // child is a component instance
      } else {
        component = child;
      }

      this.children_.push(component);

      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }

      // If a name wasn't used to create the component, check if we can use the
      // name function of the component
      componentName = componentName || component.name && component.name();

      if (componentName) {
        this.childNameIndex_[componentName] = component;
      }

      // Add the UI object's element to the container div (box)
      // Having an element is not required
      if (typeof component.el === 'function' && component.el()) {
        this.contentEl().appendChild(component.el());
      }

      // Return so it can stored on parent object if desired.
      return component;
    }
  }, {
    key: 'removeChild',

    /**
     * Remove a child component from this component's list of children, and the
     * child component's element from this component's element
     *
     * @param  {Component} component Component to remove
     */
    value: function removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }

      if (!component || !this.children_) {
        return;
      }var childFound = false;
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }

      if (!childFound) {
        return;
      }this.childIndex_[component.id()] = null;
      this.childNameIndex_[component.name()] = null;

      var compEl = component.el();
      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }
  }, {
    key: 'initChildren',

    /**
     * Add and initialize default child components from options
     *
     *     // when an instance of MyComponent is created, all children in options
     *     // will be added to the instance by their name strings and options
     *     MyComponent.prototype.options_.children = {
     *       myChildComponent: {
     *         myChildOption: true
     *       }
     *     }
     *
     *     // Or when creating the component
     *     var myComp = new MyComponent(player, {
     *       children: {
     *         myChildComponent: {
     *           myChildOption: true
     *         }
     *       }
     *     });
     *
     * The children option can also be an Array of child names or
     * child options objects (that also include a 'name' key).
     *
     *     var myComp = new MyComponent(player, {
     *       children: [
     *         'button',
     *         {
     *           name: 'button',
     *           someOtherOption: true
     *         }
     *       ]
     *     });
     *
     */
    value: function initChildren() {
      var _this = this;

      var children = this.options_.children;

      if (children) {
        var i;

        (function () {
          var parent = _this;
          var parentOptions = parent.options();
          var handleAdd = function handleAdd(name, opts) {
            // Allow options for children to be set at the parent options
            // e.g. videojs(id, { controlBar: false });
            // instead of videojs(id, { children: { controlBar: false });
            if (parentOptions[name] !== undefined) {
              opts = parentOptions[name];
            }

            // Allow for disabling default components
            // e.g. options['children']['posterImage'] = false
            if (opts === false) {
              return;
            } // Create and add the child component.
            // Add a direct reference to the child by name on the parent instance.
            // If two of the same component are used, different names should be supplied
            // for each
            parent[name] = parent.addChild(name, opts);
          };

          // Allow for an array of children details to passed in the options
          if (Lib.obj.isArray(children)) {
            for (i = 0; i < children.length; i++) {
              var child = children[i];

              var _name = undefined,
                  opts = undefined;
              if (typeof child == 'string') {
                // ['myComponent']
                _name = child;
                opts = {};
              } else {
                // [{ name: 'myComponent', otherOption: true }]
                _name = child.name;
                opts = child;
              }

              handleAdd(_name, opts);
            }
          } else {
            Lib.obj.each(children, handleAdd);
          }
        })();
      }
    }
  }, {
    key: 'buildCSSClass',

    /**
     * Allows sub components to stack CSS class names
     *
     * @return {String} The constructed class name
     */
    value: function buildCSSClass() {
      // Child classes can include a function that does:
      // return 'CLASS NAME' + this._super();
      return '';
    }
  }, {
    key: 'on',

    /**
     * Add an event listener to this component's element
     *
     *     var myFunc = function(){
     *       var myComponent = this;
     *       // Do something when the event is fired
     *     };
     *
     *     myComponent.on('eventType', myFunc);
     *
     * The context of myFunc will be myComponent unless previously bound.
     *
     * Alternatively, you can add a listener to another element or component.
     *
     *     myComponent.on(otherElement, 'eventName', myFunc);
     *     myComponent.on(otherComponent, 'eventName', myFunc);
     *
     * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`
     * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
     * will be automatically cleaned up when either component is disposed.
     * It will also bind myComponent as the context of myFunc.
     *
     * **NOTE**: When using this on elements in the page other than window
     * and document (both permanent), if you remove the element from the DOM
     * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up
     * references to it and allow the browser to garbage collect it.
     *
     * @param  {String|Component} first   The event type or other component
     * @param  {Function|String}      second  The event handler or event type
     * @param  {Function}             third   The event handler
     * @return {Component}        self
     */
    value: function on(first, second, third) {
      var _this2 = this;

      if (typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.on(this.el_, first, Lib.bind(this, second));

        // Targeting another component or element
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Lib.bind(_this2, third);
          var thisComponent = _this2;

          // When this component is disposed, remove the listener from the other component
          var removeOnDispose = function removeOnDispose() {
            thisComponent.off(target, type, fn);
          };
          // Use the same function ID so we can remove it later it using the ID
          // of the original listener
          removeOnDispose.guid = fn.guid;
          _this2.on('dispose', removeOnDispose);

          // If the other component is disposed first we need to clean the reference
          // to the other component in this component's removeOnDispose listener
          // Otherwise we create a memory leak.
          var cleanRemover = function cleanRemover() {
            thisComponent.off('dispose', removeOnDispose);
          };
          // Add the same function ID so we can easily remove it later
          cleanRemover.guid = fn.guid;

          // Check if this is a DOM node
          if (first.nodeName) {
            // Add the listener to the other element
            Events.on(target, type, fn);
            Events.on(target, 'dispose', cleanRemover);

            // Should be a component
            // Not using `instanceof Component` because it makes mock players difficult
          } else if (typeof first.on === 'function') {
            // Add the listener to the other component
            target.on(type, fn);
            target.on('dispose', cleanRemover);
          }
        })();
      }

      return this;
    }
  }, {
    key: 'off',

    /**
     * Remove an event listener from this component's element
     *
     *     myComponent.off('eventType', myFunc);
     *
     * If myFunc is excluded, ALL listeners for the event type will be removed.
     * If eventType is excluded, ALL listeners will be removed from the component.
     *
     * Alternatively you can use `off` to remove listeners that were added to other
     * elements or components using `myComponent.on(otherComponent...`.
     * In this case both the event type and listener function are REQUIRED.
     *
     *     myComponent.off(otherElement, 'eventType', myFunc);
     *     myComponent.off(otherComponent, 'eventType', myFunc);
     *
     * @param  {String=|Component}  first  The event type or other component
     * @param  {Function=|String}       second The listener function or event type
     * @param  {Function=}              third  The listener for other component
     * @return {Component}
     */
    value: function off(first, second, third) {
      if (!first || typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.off(this.el_, first, second);
      } else {
        var target = first;
        var type = second;
        // Ensure there's at least a guid, even if the function hasn't been used
        var fn = Lib.bind(this, third);

        // Remove the dispose listener on this component,
        // which was given the same guid as the event listener
        this.off('dispose', fn);

        if (first.nodeName) {
          // Remove the listener
          Events.off(target, type, fn);
          // Remove the listener for cleaning the dispose listener
          Events.off(target, 'dispose', fn);
        } else {
          target.off(type, fn);
          target.off('dispose', fn);
        }
      }

      return this;
    }
  }, {
    key: 'one',

    /**
     * Add an event listener to be triggered only once and then removed
     *
     *     myComponent.one('eventName', myFunc);
     *
     * Alternatively you can add a listener to another element or component
     * that will be triggered only once.
     *
     *     myComponent.one(otherElement, 'eventName', myFunc);
     *     myComponent.one(otherComponent, 'eventName', myFunc);
     *
     * @param  {String|Component}  first   The event type or other component
     * @param  {Function|String}       second  The listener function or event type
     * @param  {Function=}             third   The listener function for other component
     * @return {Component}
     */
    value: function one(first, second, third) {
      var _this3 = this;

      if (typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.one(this.el_, first, Lib.bind(this, second));
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Lib.bind(_this3, third);
          var thisComponent = _this3;

          var newFunc = (function (_newFunc) {
            function newFunc() {
              return _newFunc.apply(this, arguments);
            }

            newFunc.toString = function () {
              return _newFunc.toString();
            };

            return newFunc;
          })(function () {
            thisComponent.off(target, type, newFunc);
            fn.apply(this, arguments);
          });
          // Keep the same function ID so we can remove it later
          newFunc.guid = fn.guid;

          _this3.on(target, type, newFunc);
        })();
      }

      return this;
    }
  }, {
    key: 'trigger',

    /**
     * Trigger an event on an element
     *
     *     myComponent.trigger('eventName');
     *     myComponent.trigger({'type':'eventName'});
     *
     * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
     * @return {Component}       self
     */
    value: function trigger(event) {
      Events.trigger(this.el_, event);
      return this;
    }
  }, {
    key: 'ready',

    /**
     * Bind a listener to the component's ready state
     *
     * Different from event listeners in that if the ready event has already happened
     * it will trigger the function immediately.
     *
     * @param  {Function} fn Ready listener
     * @return {Component}
     */
    value: function ready(fn) {
      if (fn) {
        if (this.isReady_) {
          fn.call(this);
        } else {
          this.readyQueue_ = this.readyQueue_ || [];
          this.readyQueue_.push(fn);
        }
      }
      return this;
    }
  }, {
    key: 'triggerReady',

    /**
     * Trigger the ready listeners
     *
     * @return {Component}
     */
    value: function triggerReady() {
      this.isReady_ = true;

      var readyQueue = this.readyQueue_;

      if (readyQueue && readyQueue.length > 0) {

        for (var i = 0, j = readyQueue.length; i < j; i++) {
          readyQueue[i].call(this);
        }

        // Reset Ready Queue
        this.readyQueue_ = [];

        // Allow for using event listeners also, in case you want to do something everytime a source is ready.
        this.trigger('ready');
      }
    }
  }, {
    key: 'hasClass',

    /**
     * Check if a component's element has a CSS class name
     *
     * @param {String} classToCheck Classname to check
     * @return {Component}
     */
    value: function hasClass(classToCheck) {
      return Lib.hasClass(this.el_, classToCheck);
    }
  }, {
    key: 'addClass',

    /**
     * Add a CSS class name to the component's element
     *
     * @param {String} classToAdd Classname to add
     * @return {Component}
     */
    value: function addClass(classToAdd) {
      Lib.addClass(this.el_, classToAdd);
      return this;
    }
  }, {
    key: 'removeClass',

    /**
     * Remove a CSS class name from the component's element
     *
     * @param {String} classToRemove Classname to remove
     * @return {Component}
     */
    value: function removeClass(classToRemove) {
      Lib.removeClass(this.el_, classToRemove);
      return this;
    }
  }, {
    key: 'show',

    /**
     * Show the component element if hidden
     *
     * @return {Component}
     */
    value: function show() {
      this.removeClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'hide',

    /**
     * Hide the component element if currently showing
     *
     * @return {Component}
     */
    value: function hide() {
      this.addClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'lockShowing',

    /**
     * Lock an item in its visible state
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function lockShowing() {
      this.addClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'unlockShowing',

    /**
     * Unlock an item to be hidden
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function unlockShowing() {
      this.removeClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'width',

    /**
     * Set or get the width of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num   Optional width number
     * @param  {Boolean} skipListeners Skip the 'resize' event trigger
     * @return {Component} This component, when setting the width
     * @return {Number|String} The width, when getting
     */
    value: function width(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    }
  }, {
    key: 'height',

    /**
     * Get or set the height of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num     New component height
     * @param  {Boolean=} skipListeners Skip the resize event trigger
     * @return {Component} This component, when setting the height
     * @return {Number|String} The height, when getting
     */
    value: function height(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    }
  }, {
    key: 'dimensions',

    /**
     * Set both width and height at the same time
     *
     * @param  {Number|String} width
     * @param  {Number|String} height
     * @return {Component} The component
     */
    value: function dimensions(width, height) {
      // Skip resize listeners on width for optimization
      return this.width(width, true).height(height);
    }
  }, {
    key: 'dimension',

    /**
     * Get or set width or height
     *
     * This is the shared code for the width() and height() methods.
     * All for an integer, integer + 'px' or integer + '%';
     *
     * Known issue: Hidden elements officially have a width of 0. We're defaulting
     * to the style.width value and falling back to computedStyle which has the
     * hidden element issue. Info, but probably not an efficient fix:
     * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
     *
     * @param  {String} widthOrHeight  'width' or 'height'
     * @param  {Number|String=} num     New dimension
     * @param  {Boolean=} skipListeners Skip resize event trigger
     * @return {Component} The component if a dimension was set
     * @return {Number|String} The dimension if nothing was set
     * @private
     */
    value: function dimension(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        // Set to zero if null or literally NaN (NaN !== NaN)
        if (num === null || num !== num) {
          num = 0;
        }

        // Check if using css width/height (% or px) and adjust
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }

        // skipListeners allows us to avoid triggering the resize event when setting both width and height
        if (!skipListeners) {
          this.trigger('resize');
        }

        // Return component
        return this;
      }

      // Not setting a value, so getting it
      // Make sure element exists
      if (!this.el_) {
        return 0;
      } // Get dimension value from style
      var val = this.el_.style[widthOrHeight];
      var pxIndex = val.indexOf('px');
      if (pxIndex !== -1) {
        // Return the pixel value with no 'px'
        return parseInt(val.slice(0, pxIndex), 10);

        // No px so using % or no style was set, so falling back to offsetWidth/height
        // If component has display:none, offset will return 0
        // TODO: handle display:none and no dimension style using px
      } else {

        return parseInt(this.el_['offset' + Lib.capitalize(widthOrHeight)], 10);

        // ComputedStyle version.
        // Only difference is if the element is hidden it will return
        // the percent value (e.g. '100%'')
        // instead of zero like offsetWidth returns.
        // var val = Lib.getComputedStyleValue(this.el_, widthOrHeight);
        // var pxIndex = val.indexOf('px');

        // if (pxIndex !== -1) {
        //   return val.slice(0, pxIndex);
        // } else {
        //   return val;
        // }
      }
    }
  }, {
    key: 'emitTapEvents',

    /**
     * Emit 'tap' events when touch events are supported
     *
     * This is used to support toggling the controls through a tap on the video.
     *
     * We're requiring them to be enabled because otherwise every component would
     * have this extra overhead unnecessarily, on mobile devices where extra
     * overhead is especially bad.
     * @private
     */
    value: function emitTapEvents() {
      // Track the start time so we can determine how long the touch lasted
      var touchStart = 0;
      var firstTouch = null;

      // Maximum movement allowed during a touch event to still be considered a tap
      // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
      var tapMovementThreshold = 10;

      // The maximum length a touch can be while still being considered a tap
      var touchTimeThreshold = 200;

      var couldBeTap = undefined;
      this.on('touchstart', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length === 1) {
          firstTouch = Lib.obj.copy(event.touches[0]);
          // Record start time so we can detect a tap vs. "touch and hold"
          touchStart = new Date().getTime();
          // Reset couldBeTap tracking
          couldBeTap = true;
        }
      });

      this.on('touchmove', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          // Some devices will throw touchmoves for all but the slightest of taps.
          // So, if we moved only a small distance, this could still be a tap
          var xdiff = event.touches[0].pageX - firstTouch.pageX;
          var ydiff = event.touches[0].pageY - firstTouch.pageY;
          var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });

      var noTap = function noTap() {
        couldBeTap = false;
      };
      // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);

      // When the touch ends, measure how long it took and trigger the appropriate
      // event
      this.on('touchend', function (event) {
        firstTouch = null;
        // Proceed only if the touchmove/leave/cancel event didn't happen
        if (couldBeTap === true) {
          // Measure how long the touch lasted
          var touchTime = new Date().getTime() - touchStart;
          // Make sure the touch was less than the threshold to be considered a tap
          if (touchTime < touchTimeThreshold) {
            event.preventDefault(); // Don't let browser turn this into a click
            this.trigger('tap');
            // It may be good to copy the touchend event object and change the
            // type to tap, if the other event properties aren't exact after
            // Lib.fixEvent runs (e.g. event.target)
          }
        }
      });
    }
  }, {
    key: 'enableTouchActivity',

    /**
     * Report user touch activity when touch events occur
     *
     * User activity is used to determine when controls should show/hide. It's
     * relatively simple when it comes to mouse events, because any mouse event
     * should show the controls. So we capture mouse events that bubble up to the
     * player and report activity when that happens.
     *
     * With touch events it isn't as easy. We can't rely on touch events at the
     * player level, because a tap (touchstart + touchend) on the video itself on
     * mobile devices is meant to turn controls off (and on). User activity is
     * checked asynchronously, so what could happen is a tap event on the video
     * turns the controls off, then the touchend event bubbles up to the player,
     * which if it reported user activity, would turn the controls right back on.
     * (We also don't want to completely block touch events from bubbling up)
     *
     * Also a touchmove, touch+hold, and anything other than a tap is not supposed
     * to turn the controls back on on a mobile device.
     *
     * Here we're setting the default component behavior to report user activity
     * whenever touch events happen, and this can be turned off by components that
     * want touch events to act differently.
     */
    value: function enableTouchActivity() {
      // Don't continue if the root player doesn't support reporting user activity
      if (!this.player().reportUserActivity) {
        return;
      }

      // listener for reporting that the user is active
      var report = Lib.bind(this.player(), this.player().reportUserActivity);

      var touchHolding = undefined;
      this.on('touchstart', function () {
        report();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(touchHolding);
        // report at the same interval as activityCheck
        touchHolding = this.setInterval(report, 250);
      });

      var touchEnd = function touchEnd(event) {
        report();
        // stop the interval that maintains activity if the touch is holding
        this.clearInterval(touchHolding);
      };

      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    }
  }, {
    key: 'setTimeout',

    /**
     * Creates timeout and sets up disposal automatically.
     * @param {Function} fn The function to run after the timeout.
     * @param {Number} timeout Number of ms to delay before executing specified function.
     * @return {Number} Returns the timeout ID
     */
    value: (function (_setTimeout) {
      function setTimeout(_x, _x2) {
        return _setTimeout.apply(this, arguments);
      }

      setTimeout.toString = function () {
        return _setTimeout.toString();
      };

      return setTimeout;
    })(function (fn, timeout) {
      fn = Lib.bind(this, fn);

      // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
      var timeoutId = setTimeout(fn, timeout);

      var disposeFn = function disposeFn() {
        this.clearTimeout(timeoutId);
      };

      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.on('dispose', disposeFn);

      return timeoutId;
    })
  }, {
    key: 'clearTimeout',

    /**
     * Clears a timeout and removes the associated dispose listener
     * @param {Number} timeoutId The id of the timeout to clear
     * @return {Number} Returns the timeout ID
     */
    value: (function (_clearTimeout) {
      function clearTimeout(_x3) {
        return _clearTimeout.apply(this, arguments);
      }

      clearTimeout.toString = function () {
        return _clearTimeout.toString();
      };

      return clearTimeout;
    })(function (timeoutId) {
      clearTimeout(timeoutId);

      var disposeFn = function disposeFn() {};
      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.off('dispose', disposeFn);

      return timeoutId;
    })
  }, {
    key: 'setInterval',

    /**
     * Creates an interval and sets up disposal automatically.
     * @param {Function} fn The function to run every N seconds.
     * @param {Number} interval Number of ms to delay before executing specified function.
     * @return {Number} Returns the interval ID
     */
    value: (function (_setInterval) {
      function setInterval(_x4, _x5) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    })(function (fn, interval) {
      fn = Lib.bind(this, fn);

      var intervalId = setInterval(fn, interval);

      var disposeFn = function disposeFn() {
        this.clearInterval(intervalId);
      };

      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.on('dispose', disposeFn);

      return intervalId;
    })
  }, {
    key: 'clearInterval',

    /**
     * Clears an interval and removes the associated dispose listener
     * @param {Number} intervalId The id of the interval to clear
     * @return {Number} Returns the interval ID
     */
    value: (function (_clearInterval) {
      function clearInterval(_x6) {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    })(function (intervalId) {
      clearInterval(intervalId);

      var disposeFn = function disposeFn() {};
      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.off('dispose', disposeFn);

      return intervalId;
    })
  }], [{
    key: 'registerComponent',
    value: function registerComponent(name, comp) {
      if (!Component.components_) {
        Component.components_ = {};
      }

      Component.components_[name] = comp;
      return comp;
    }
  }, {
    key: 'getComponent',
    value: function getComponent(name) {
      if (Component.components_ && Component.components_[name]) {
        return Component.components_[name];
      }

      if (_window2['default'] && _window2['default'].videojs && _window2['default'].videojs[name]) {
        Lib.log.warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');
        return _window2['default'].videojs[name];
      }
    }
  }, {
    key: 'extend',
    value: function extend(props) {
      props = props || {};
      // Set up the constructor using the supplied init method
      // or using the init of the parent object
      // Make sure to check the unobfuscated version for external libs
      var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};
      // In Resig's simple class inheritance (previously used) the constructor
      //  is a function that calls `this.init.apply(arguments)`
      // However that would prevent us from using `ParentObject.call(this);`
      //  in a Child constructor because the `this` in `this.init`
      //  would still refer to the Child and cause an infinite loop.
      // We would instead have to do
      //    `ParentObject.prototype.init.apply(this, arguments);`
      //  Bleh. We're not creating a _super() function, so it's good to keep
      //  the parent constructor reference simple.
      var subObj = function subObj() {
        init.apply(this, arguments);
      };

      // Inherit from this object's prototype
      subObj.prototype = Lib.obj.create(this.prototype);
      // Reset the constructor property for subObj otherwise
      // instances of subObj would have the constructor of the parent Object
      subObj.prototype.constructor = subObj;

      // Make the class extendable
      subObj.extend = Component.extend;
      // Make a function for creating instances
      // subObj.create = CoreObject.create;

      // Extend subObj's prototype with functions and other properties from props
      for (var name in props) {
        if (props.hasOwnProperty(name)) {
          subObj.prototype[name] = props[name];
        }
      }

      return subObj;
    }
  }]);

  return Component;
})();

Component.registerComponent('Component', Component);
exports['default'] = Component;
module.exports = exports['default'];

},{"./events.js":43,"./lib.js":46,"./util.js":70,"global/window":2}],8:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

// Required children

var _PlayToggle = _dereq_('./play-toggle.js');

var _PlayToggle2 = _interopRequireWildcard(_PlayToggle);

var _CurrentTimeDisplay = _dereq_('./time-controls/current-time-display.js');

var _CurrentTimeDisplay2 = _interopRequireWildcard(_CurrentTimeDisplay);

var _DurationDisplay = _dereq_('./time-controls/duration-display.js');

var _DurationDisplay2 = _interopRequireWildcard(_DurationDisplay);

var _TimeDivider = _dereq_('./time-controls/time-divider.js');

var _TimeDivider2 = _interopRequireWildcard(_TimeDivider);

var _RemainingTimeDisplay = _dereq_('./time-controls/remaining-time-display.js');

var _RemainingTimeDisplay2 = _interopRequireWildcard(_RemainingTimeDisplay);

var _LiveDisplay = _dereq_('./live-display.js');

var _LiveDisplay2 = _interopRequireWildcard(_LiveDisplay);

var _ProgressControl = _dereq_('./progress-control/progress-control.js');

var _ProgressControl2 = _interopRequireWildcard(_ProgressControl);

var _FullscreenToggle = _dereq_('./fullscreen-toggle.js');

var _FullscreenToggle2 = _interopRequireWildcard(_FullscreenToggle);

var _VolumeControl = _dereq_('./volume-control/volume-control.js');

var _VolumeControl2 = _interopRequireWildcard(_VolumeControl);

var _VolumeMenuButton = _dereq_('./volume-menu-button.js');

var _VolumeMenuButton2 = _interopRequireWildcard(_VolumeMenuButton);

var _MuteToggle = _dereq_('./mute-toggle.js');

var _MuteToggle2 = _interopRequireWildcard(_MuteToggle);

var _ChaptersButton = _dereq_('./text-track-controls/chapters-button.js');

var _ChaptersButton2 = _interopRequireWildcard(_ChaptersButton);

var _SubtitlesButton = _dereq_('./text-track-controls/subtitles-button.js');

var _SubtitlesButton2 = _interopRequireWildcard(_SubtitlesButton);

var _CaptionsButton = _dereq_('./text-track-controls/captions-button.js');

var _CaptionsButton2 = _interopRequireWildcard(_CaptionsButton);

var _PlaybackRateMenuButton = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');

var _PlaybackRateMenuButton2 = _interopRequireWildcard(_PlaybackRateMenuButton);

var _CustomControlSpacer = _dereq_('./spacer-controls/custom-control-spacer.js');

var _CustomControlSpacer2 = _interopRequireWildcard(_CustomControlSpacer);

/**
 * Container of main controls
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends Component
 */

var ControlBar = (function (_Component) {
  function ControlBar() {
    _classCallCheck(this, ControlBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ControlBar, _Component);

  _createClass(ControlBar, [{
    key: 'createEl',
    value: function createEl() {
      return Lib.createEl('div', {
        className: 'vjs-control-bar'
      });
    }
  }]);

  return ControlBar;
})(_Component3['default']);

ControlBar.prototype.options_ = {
  loadEvent: 'play',
  children: ['playToggle', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'muteToggle', 'volumeControl', 'chaptersButton', 'subtitlesButton', 'captionsButton', 'volumeMenuButton', 'fullscreenToggle']
};

_Component3['default'].registerComponent('ControlBar', ControlBar);
exports['default'] = ControlBar;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46,"./fullscreen-toggle.js":9,"./live-display.js":10,"./mute-toggle.js":11,"./play-toggle.js":12,"./playback-rate-menu/playback-rate-menu-button.js":13,"./progress-control/progress-control.js":17,"./spacer-controls/custom-control-spacer.js":20,"./text-track-controls/captions-button.js":23,"./text-track-controls/chapters-button.js":24,"./text-track-controls/subtitles-button.js":27,"./time-controls/current-time-display.js":30,"./time-controls/duration-display.js":31,"./time-controls/remaining-time-display.js":32,"./time-controls/time-divider.js":33,"./volume-control/volume-control.js":35,"./volume-menu-button.js":38}],9:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button');

var _Button3 = _interopRequireWildcard(_Button2);

/**
 * Toggle fullscreen video
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @extends vjs.Button
 */

var FullscreenToggle = (function (_Button) {
  function FullscreenToggle() {
    _classCallCheck(this, FullscreenToggle);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(FullscreenToggle, _Button);

  _createClass(FullscreenToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-fullscreen-control ' + _get(Object.getPrototypeOf(FullscreenToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
        this.controlText_.innerHTML = this.localize('Non-Fullscreen');
      } else {
        this.player_.exitFullscreen();
        this.controlText_.innerHTML = this.localize('Fullscreen');
      }
    }
  }]);

  return FullscreenToggle;
})(_Button3['default']);

FullscreenToggle.prototype.buttonText = 'Fullscreen';

_Button3['default'].registerComponent('FullscreenToggle', FullscreenToggle);
exports['default'] = FullscreenToggle;
module.exports = exports['default'];

},{"../button":6}],10:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Displays the live indicator
 * TODO - Future make it click to snap to live
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LiveDisplay = (function (_Component) {
  function LiveDisplay() {
    _classCallCheck(this, LiveDisplay);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LiveDisplay, _Component);

  _createClass(LiveDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(LiveDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-live-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-live-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
        'aria-live': 'off'
      });

      el.appendChild(this.contentEl_);

      return el;
    }
  }]);

  return LiveDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('LiveDisplay', LiveDisplay);
exports['default'] = LiveDisplay;
module.exports = exports['default'];

},{"../component":7,"../lib":46}],11:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button');

var _Button3 = _interopRequireWildcard(_Button2);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

/**
 * A button component for muting the audio
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MuteToggle = (function (_Button) {
  function MuteToggle(player, options) {
    _classCallCheck(this, MuteToggle);

    _get(Object.getPrototypeOf(MuteToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(MuteToggle, _Button);

  _createClass(MuteToggle, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(MuteToggle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-mute-control vjs-control',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  }, {
    key: 'update',
    value: function update() {
      var vol = this.player_.volume(),
          level = 3;

      if (vol === 0 || this.player_.muted()) {
        level = 0;
      } else if (vol < 0.33) {
        level = 1;
      } else if (vol < 0.67) {
        level = 2;
      }

      // Don't rewrite the button text if the actual text doesn't change.
      // This causes unnecessary and confusing information for screen reader users.
      // This check is needed because this function gets called every time the volume level is changed.
      var toMute = this.player_.muted() ? 'Unmute' : 'Mute';
      var localizedMute = this.localize(toMute);
      if (this.el_.children[0].children[0].innerHTML !== localizedMute) {
        this.el_.children[0].children[0].innerHTML = localizedMute;
      }

      /* TODO improve muted icon classes */
      for (var i = 0; i < 4; i++) {
        Lib.removeClass(this.el_, 'vjs-vol-' + i);
      }
      Lib.addClass(this.el_, 'vjs-vol-' + level);
    }
  }]);

  return MuteToggle;
})(_Button3['default']);

_Component2['default'].registerComponent('MuteToggle', MuteToggle);
exports['default'] = MuteToggle;
module.exports = exports['default'];

},{"../button":6,"../component":7,"../lib":46}],12:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button');

var _Button3 = _interopRequireWildcard(_Button2);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Button to toggle between play and pause
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var PlayToggle = (function (_Button) {
  function PlayToggle(player, options) {
    _classCallCheck(this, PlayToggle);

    _get(Object.getPrototypeOf(PlayToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'play', this.onPlay);
    this.on(player, 'pause', this.onPause);
  }

  _inherits(PlayToggle, _Button);

  _createClass(PlayToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-play-control ' + _get(Object.getPrototypeOf(PlayToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'onClick',

    // OnClick - Toggle between play and pause
    value: function onClick() {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }, {
    key: 'onPlay',

    // OnPlay - Add the vjs-playing class to the element so it can change appearance
    value: function onPlay() {
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
    }
  }, {
    key: 'onPause',

    // OnPause - Add the vjs-paused class to the element so it can change appearance
    value: function onPause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
    }
  }]);

  return PlayToggle;
})(_Button3['default']);

PlayToggle.prototype.buttonText = 'Play';

_Button3['default'].registerComponent('PlayToggle', PlayToggle);
exports['default'] = PlayToggle;
module.exports = exports['default'];

},{"../button":6,"../lib":46}],13:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuButton2 = _dereq_('../../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _Menu = _dereq_('../../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _PlaybackRateMenuItem = _dereq_('./playback-rate-menu-item.js');

var _PlaybackRateMenuItem2 = _interopRequireWildcard(_PlaybackRateMenuItem);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * The component for controlling the playback rate
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlaybackRateMenuButton = (function (_MenuButton) {
  function PlaybackRateMenuButton(player, options) {
    _classCallCheck(this, PlaybackRateMenuButton);

    _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'constructor', this).call(this, player, options);

    this.updateVisibility();
    this.updateLabel();

    this.on(player, 'loadstart', this.updateVisibility);
    this.on(player, 'ratechange', this.updateLabel);
  }

  _inherits(PlaybackRateMenuButton, _MenuButton);

  _createClass(PlaybackRateMenuButton, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'createEl', this).call(this);

      this.labelEl_ = Lib.createEl('div', {
        className: 'vjs-playback-rate-value',
        innerHTML: 1
      });

      el.appendChild(this.labelEl_);

      return el;
    }
  }, {
    key: 'createMenu',

    // Menu creation
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player());
      var rates = this.player().options().playbackRates;

      if (rates) {
        for (var i = rates.length - 1; i >= 0; i--) {
          menu.addChild(new _PlaybackRateMenuItem2['default'](this.player(), { rate: rates[i] + 'x' }));
        }
      }

      return menu;
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current playback rate
      this.el().setAttribute('aria-valuenow', this.player().playbackRate());
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      // select next rate option
      var currentRate = this.player().playbackRate();
      var rates = this.player().options().playbackRates;
      // this will select first one if the last one currently selected
      var newRate = rates[0];
      for (var i = 0; i < rates.length; i++) {
        if (rates[i] > currentRate) {
          newRate = rates[i];
          break;
        }
      }
      this.player().playbackRate(newRate);
    }
  }, {
    key: 'playbackRateSupported',
    value: function playbackRateSupported() {
      return this.player().tech && this.player().tech.featuresPlaybackRate && this.player().options().playbackRates && this.player().options().playbackRates.length > 0;
    }
  }, {
    key: 'updateVisibility',

    /**
     * Hide playback rate controls when they're no playback rate options to select
     */
    value: function updateVisibility() {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    }
  }, {
    key: 'updateLabel',

    /**
     * Update button label when rate changed
     */
    value: function updateLabel() {
      if (this.playbackRateSupported()) {
        this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
      }
    }
  }]);

  return PlaybackRateMenuButton;
})(_MenuButton3['default']);

PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

_MenuButton3['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
exports['default'] = PlaybackRateMenuButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-button.js":49,"../../menu/menu.js":51,"./playback-rate-menu-item.js":14}],14:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

/**
 * The specific menu item type for selecting a playback rate
 *
 * @constructor
 */

var PlaybackRateMenuItem = (function (_MenuItem) {
  function PlaybackRateMenuItem(player, options) {
    _classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.label = label;
    this.rate = rate;

    this.on(player, 'ratechange', this.update);
  }

  _inherits(PlaybackRateMenuItem, _MenuItem);

  _createClass(PlaybackRateMenuItem, [{
    key: 'onClick',
    value: function onClick() {
      _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'onClick', this).call(this);
      this.player().playbackRate(this.rate);
    }
  }, {
    key: 'update',
    value: function update() {
      this.selected(this.player().playbackRate() == this.rate);
    }
  }]);

  return PlaybackRateMenuItem;
})(_MenuItem3['default']);

PlaybackRateMenuItem.prototype.contentElType = 'button';

_MenuItem3['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
exports['default'] = PlaybackRateMenuItem;
module.exports = exports['default'];

},{"../../menu/menu-item.js":50}],15:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * Shows load progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LoadProgressBar = (function (_Component) {
  function LoadProgressBar(player, options) {
    _classCallCheck(this, LoadProgressBar);

    _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'progress', this.update);
  }

  _inherits(LoadProgressBar, _Component);

  _createClass(LoadProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-load-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var buffered = this.player_.buffered();
      var duration = this.player_.duration();
      var bufferedEnd = this.player_.bufferedEnd();
      var children = this.el_.children;

      // get the percent width of a time compared to the total end
      var percentify = function percentify(time, end) {
        var percent = time / end || 0; // no NaN
        return percent * 100 + '%';
      };

      // update the width of the progress bar
      this.el_.style.width = percentify(bufferedEnd, duration);

      // add child elements to represent the individual buffered time ranges
      for (var i = 0; i < buffered.length; i++) {
        var start = buffered.start(i);
        var end = buffered.end(i);
        var part = children[i];

        if (!part) {
          part = this.el_.appendChild(Lib.createEl());
        }

        // set the percent based on the width of the progress bar (bufferedEnd)
        part.style.left = percentify(start, bufferedEnd);
        part.style.width = percentify(end - start, bufferedEnd);
      }

      // remove unused buffered range elements
      for (var i = children.length; i > buffered.length; i--) {
        this.el_.removeChild(children[i - 1]);
      }
    }
  }]);

  return LoadProgressBar;
})(_Component3['default']);

_Component3['default'].registerComponent('LoadProgressBar', LoadProgressBar);
exports['default'] = LoadProgressBar;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],16:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Shows play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlayProgressBar = (function (_Component) {
  function PlayProgressBar() {
    _classCallCheck(this, PlayProgressBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(PlayProgressBar, _Component);

  _createClass(PlayProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(PlayProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-play-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
      });
    }
  }]);

  return PlayProgressBar;
})(_Component3['default']);

_Component3['default'].registerComponent('PlayProgressBar', PlayProgressBar);
exports['default'] = PlayProgressBar;
module.exports = exports['default'];

},{"../../component.js":7}],17:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _SeekBar = _dereq_('./seek-bar.js');

var _SeekBar2 = _interopRequireWildcard(_SeekBar);

/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ProgressControl = (function (_Component) {
  function ProgressControl() {
    _classCallCheck(this, ProgressControl);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ProgressControl, _Component);

  _createClass(ProgressControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(ProgressControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-control vjs-control'
      });
    }
  }]);

  return ProgressControl;
})(_Component3['default']);

ProgressControl.prototype.options_ = {
  children: {
    seekBar: {}
  }
};

_Component3['default'].registerComponent('ProgressControl', ProgressControl);
exports['default'] = ProgressControl;
module.exports = exports['default'];

},{"../../component.js":7,"./seek-bar.js":18}],18:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Slider2 = _dereq_('../../slider/slider.js');

var _Slider3 = _interopRequireWildcard(_Slider2);

var _LoadProgressBar = _dereq_('./load-progress-bar.js');

var _LoadProgressBar2 = _interopRequireWildcard(_LoadProgressBar);

var _PlayProgressBar = _dereq_('./play-progress-bar.js');

var _PlayProgressBar2 = _interopRequireWildcard(_PlayProgressBar);

var _SeekHandle = _dereq_('./seek-handle.js');

var _SeekHandle2 = _interopRequireWildcard(_SeekHandle);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekBar = (function (_Slider) {
  function SeekBar(player, options) {
    _classCallCheck(this, SeekBar);

    _get(Object.getPrototypeOf(SeekBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateARIAAttributes);
    player.ready(Lib.bind(this, this.updateARIAAttributes));
  }

  _inherits(SeekBar, _Slider);

  _createClass(SeekBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-holder',
        'aria-label': 'video progress bar'
      });
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.setAttribute('aria-valuenow', Lib.round(this.getPercent() * 100, 2)); // machine readable value of progress bar (percentage complete)
      this.el_.setAttribute('aria-valuetext', Lib.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      return this.player_.currentTime() / this.player_.duration();
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'onMouseDown', this).call(this, event);

      this.player_.scrubbing(true);

      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(event) {
      var newTime = this.calculateDistance(event) * this.player_.duration();

      // Don't let video end while scrubbing.
      if (newTime == this.player_.duration()) {
        newTime = newTime - 0.1;
      }

      // Set new time (tell player to seek to new time)
      this.player_.currentTime(newTime);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'onMouseUp', this).call(this, event);

      this.player_.scrubbing(false);
      if (this.videoWasPlaying) {
        this.player_.play();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
    }
  }]);

  return SeekBar;
})(_Slider3['default']);

SeekBar.prototype.options_ = {
  children: {
    loadProgressBar: {},
    playProgressBar: {},
    seekHandle: {}
  },
  barName: 'playProgressBar',
  handleName: 'seekHandle'
};

SeekBar.prototype.playerEvent = 'timeupdate';

_Slider3['default'].registerComponent('SeekBar', SeekBar);
exports['default'] = SeekBar;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider.js":58,"./load-progress-bar.js":15,"./play-progress-bar.js":16,"./seek-handle.js":19}],19:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _SliderHandle2 = _dereq_('../../slider/slider-handle.js');

var _SliderHandle3 = _interopRequireWildcard(_SliderHandle2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * The Seek Handle shows the current position of the playhead during playback,
 * and can be dragged to adjust the playhead.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekHandle = (function (_SliderHandle) {
  function SeekHandle(player, options) {
    _classCallCheck(this, SeekHandle);

    _get(Object.getPrototypeOf(SeekHandle.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(SeekHandle, _SliderHandle);

  _createClass(SeekHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-seek-handle',
        'aria-live': 'off'
      });
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.innerHTML = '<span class="vjs-control-text">' + Lib.formatTime(time, this.player_.duration()) + '</span>';
    }
  }]);

  return SeekHandle;
})(_SliderHandle3['default']);

/**
 * The default value for the handle content, which may be read by screen readers
 *
 * @type {String}
 * @private
 */
SeekHandle.prototype.defaultValue = '00:00';

_SliderHandle3['default'].registerComponent('SeekHandle', SeekHandle);
exports['default'] = SeekHandle;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider-handle.js":57}],20:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Spacer2 = _dereq_('./spacer.js');

var _Spacer3 = _interopRequireWildcard(_Spacer2);

/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @param {Player|Object} player
 * @param {Obect=} options
 */

var CustomControlSpacer = (function (_Spacer) {
  function CustomControlSpacer() {
    _classCallCheck(this, CustomControlSpacer);

    if (_Spacer != null) {
      _Spacer.apply(this, arguments);
    }
  }

  _inherits(CustomControlSpacer, _Spacer);

  _createClass(CustomControlSpacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-custom-control-spacer ' + _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'buildCSSClass', this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'createEl', this).call(this, {
        className: this.buildCSSClass()
      });
    }
  }]);

  return CustomControlSpacer;
})(_Spacer3['default']);

_Spacer3['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);

exports['default'] = CustomControlSpacer;
module.exports = exports['default'];

},{"./spacer.js":21}],21:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 */

var Spacer = (function (_Component) {
  function Spacer() {
    _classCallCheck(this, Spacer);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Spacer, _Component);

  _createClass(Spacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-spacer ' + _get(Object.getPrototypeOf(Spacer.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl(props) {
      return _get(Object.getPrototypeOf(Spacer.prototype), 'createEl', this).call(this, 'div', {
        className: this.buildCSSClass()
      });
    }
  }]);

  return Spacer;
})(_Component3['default']);

_Component3['default'].registerComponent('Spacer', Spacer);

exports['default'] = Spacer;
module.exports = exports['default'];

},{"../../component.js":7}],22:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackMenuItem2 = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem3 = _interopRequireWildcard(_TextTrackMenuItem2);

var CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {
  function CaptionSettingsMenuItem(player, options) {
    _classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      kind: options.kind,
      player: player,
      label: options.kind + ' settings',
      'default': false,
      mode: 'disabled'
    };

    _get(Object.getPrototypeOf(CaptionSettingsMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.addClass('vjs-texttrack-settings');
  }

  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  _createClass(CaptionSettingsMenuItem, [{
    key: 'onClick',
    value: function onClick() {
      this.player().getChild('textTrackSettings').show();
    }
  }]);

  return CaptionSettingsMenuItem;
})(_TextTrackMenuItem3['default']);

_TextTrackMenuItem3['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
exports['default'] = CaptionSettingsMenuItem;
module.exports = exports['default'];

},{"./text-track-menu-item.js":29}],23:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

var _CaptionSettingsMenuItem = _dereq_('./caption-settings-menu-item.js');

var _CaptionSettingsMenuItem2 = _interopRequireWildcard(_CaptionSettingsMenuItem);

/**
 * The button component for toggling and selecting captions
 *
 * @constructor
 */

var CaptionsButton = (function (_TextTrackButton) {
  function CaptionsButton(player, options, ready) {
    _classCallCheck(this, CaptionsButton);

    _get(Object.getPrototypeOf(CaptionsButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Captions Menu');
  }

  _inherits(CaptionsButton, _TextTrackButton);

  _createClass(CaptionsButton, [{
    key: 'update',
    value: function update() {
      var threshold = 2;
      _get(Object.getPrototypeOf(CaptionsButton.prototype), 'update', this).call(this);

      // if native, then threshold is 1 because no settings button
      if (this.player().tech && this.player().tech.featuresNativeTextTracks) {
        threshold = 1;
      }

      if (this.items && this.items.length > threshold) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'createItems',
    value: function createItems() {
      var items = [];

      if (!(this.player().tech && this.player().tech.featuresNativeTextTracks)) {
        items.push(new _CaptionSettingsMenuItem2['default'](this.player_, { kind: this.kind_ }));
      }

      return _get(Object.getPrototypeOf(CaptionsButton.prototype), 'createItems', this).call(this, items);
    }
  }]);

  return CaptionsButton;
})(_TextTrackButton3['default']);

CaptionsButton.prototype.kind_ = 'captions';
CaptionsButton.prototype.buttonText = 'Captions';
CaptionsButton.prototype.className = 'vjs-captions-button';

_TextTrackButton3['default'].registerComponent('CaptionsButton', CaptionsButton);
exports['default'] = CaptionsButton;
module.exports = exports['default'];

},{"./caption-settings-menu-item.js":22,"./text-track-button.js":28}],24:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

var _TextTrackMenuItem = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem2 = _interopRequireWildcard(_TextTrackMenuItem);

var _ChaptersTrackMenuItem = _dereq_('./chapters-track-menu-item.js');

var _ChaptersTrackMenuItem2 = _interopRequireWildcard(_ChaptersTrackMenuItem);

var _Menu = _dereq_('../../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

// Chapters act much differently than other text tracks
// Cues are navigation vs. other tracks of alternative languages
/**
 * The button component for toggling and selecting chapters
 *
 * @constructor
 */

var ChaptersButton = (function (_TextTrackButton) {
  function ChaptersButton(player, options, ready) {
    _classCallCheck(this, ChaptersButton);

    _get(Object.getPrototypeOf(ChaptersButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Chapters Menu');
  }

  _inherits(ChaptersButton, _TextTrackButton);

  _createClass(ChaptersButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = [];

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track.kind === this.kind_) {
          items.push(new _TextTrackMenuItem2['default'](this.player_, {
            track: track
          }));
        }
      }

      return items;
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var tracks = this.player_.textTracks() || [];
      var chaptersTrack = undefined;
      var items = this.items = [];

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track.kind == this.kind_) {
          if (!track.cues) {
            track.mode = 'hidden';
            /* jshint loopfunc:true */
            // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
            _window2['default'].setTimeout(Lib.bind(this, function () {
              this.createMenu();
            }), 100);
            /* jshint loopfunc:false */
          } else {
            chaptersTrack = track;
            break;
          }
        }
      }

      var menu = this.menu;
      if (menu === undefined) {
        menu = new _Menu2['default'](this.player_);
        menu.contentEl().appendChild(Lib.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: Lib.capitalize(this.kind_),
          tabindex: -1
        }));
      }

      if (chaptersTrack) {
        var cues = chaptersTrack.cues,
            cue = undefined;

        for (var i = 0, l = cues.length; i < l; i++) {
          cue = cues[i];

          var mi = new _ChaptersTrackMenuItem2['default'](this.player_, {
            track: chaptersTrack,
            cue: cue
          });

          items.push(mi);

          menu.addChild(mi);
        }
        this.addChild(menu);
      }

      if (this.items.length > 0) {
        this.show();
      }

      return menu;
    }
  }]);

  return ChaptersButton;
})(_TextTrackButton3['default']);

ChaptersButton.prototype.kind_ = 'chapters';
ChaptersButton.prototype.buttonText = 'Chapters';
ChaptersButton.prototype.className = 'vjs-chapters-button';

_TextTrackButton3['default'].registerComponent('ChaptersButton', ChaptersButton);
exports['default'] = ChaptersButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu.js":51,"./chapters-track-menu-item.js":25,"./text-track-button.js":28,"./text-track-menu-item.js":29,"global/window":2}],25:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * @constructor
 */

var ChaptersTrackMenuItem = (function (_MenuItem) {
  function ChaptersTrackMenuItem(player, options) {
    _classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;
    this.cue = cue;
    track.addEventListener('cuechange', Lib.bind(this, this.update));
  }

  _inherits(ChaptersTrackMenuItem, _MenuItem);

  _createClass(ChaptersTrackMenuItem, [{
    key: 'onClick',
    value: function onClick() {
      _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'onClick', this).call(this);
      this.player_.currentTime(this.cue.startTime);
      this.update(this.cue.startTime);
    }
  }, {
    key: 'update',
    value: function update() {
      var cue = this.cue;
      var currentTime = this.player_.currentTime();

      // vjs.log(currentTime, cue.startTime);
      this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
    }
  }]);

  return ChaptersTrackMenuItem;
})(_MenuItem3['default']);

_MenuItem3['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
exports['default'] = ChaptersTrackMenuItem;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-item.js":50}],26:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackMenuItem2 = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem3 = _interopRequireWildcard(_TextTrackMenuItem2);

/**
 * A special menu item for turning of a specific type of text track
 *
 * @constructor
 */

var OffTextTrackMenuItem = (function (_TextTrackMenuItem) {
  function OffTextTrackMenuItem(player, options) {
    _classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      kind: options.kind,
      player: player,
      label: options.kind + ' off',
      'default': false,
      mode: 'disabled'
    };

    _get(Object.getPrototypeOf(OffTextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(true);
  }

  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  _createClass(OffTextTrackMenuItem, [{
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      var tracks = this.player().textTracks();
      var selected = true;

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track.kind === this.track.kind && track.mode === 'showing') {
          selected = false;
          break;
        }
      }

      this.selected(selected);
    }
  }]);

  return OffTextTrackMenuItem;
})(_TextTrackMenuItem3['default']);

_TextTrackMenuItem3['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
exports['default'] = OffTextTrackMenuItem;
module.exports = exports['default'];

},{"./text-track-menu-item.js":29}],27:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackButton2 = _dereq_('./text-track-button.js');

var _TextTrackButton3 = _interopRequireWildcard(_TextTrackButton2);

/**
 * The button component for toggling and selecting subtitles
 *
 * @constructor
 */

var SubtitlesButton = (function (_TextTrackButton) {
  function SubtitlesButton(player, options, ready) {
    _classCallCheck(this, SubtitlesButton);

    _get(Object.getPrototypeOf(SubtitlesButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Subtitles Menu');
  }

  _inherits(SubtitlesButton, _TextTrackButton);

  return SubtitlesButton;
})(_TextTrackButton3['default']);

SubtitlesButton.prototype.kind_ = 'subtitles';
SubtitlesButton.prototype.buttonText = 'Subtitles';
SubtitlesButton.prototype.className = 'vjs-subtitles-button';

_TextTrackButton3['default'].registerComponent('SubtitlesButton', SubtitlesButton);
exports['default'] = SubtitlesButton;
module.exports = exports['default'];

},{"./text-track-button.js":28}],28:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuButton2 = _dereq_('../../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

var _TextTrackMenuItem = _dereq_('./text-track-menu-item.js');

var _TextTrackMenuItem2 = _interopRequireWildcard(_TextTrackMenuItem);

var _OffTextTrackMenuItem = _dereq_('./off-text-track-menu-item.js');

var _OffTextTrackMenuItem2 = _interopRequireWildcard(_OffTextTrackMenuItem);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @constructor
 */

var TextTrackButton = (function (_MenuButton) {
  function TextTrackButton(player, options) {
    _classCallCheck(this, TextTrackButton);

    _get(Object.getPrototypeOf(TextTrackButton.prototype), 'constructor', this).call(this, player, options);

    var tracks = this.player_.textTracks();

    if (this.items.length <= 1) {
      this.hide();
    }

    if (!tracks) {
      return;
    }

    var updateHandler = Lib.bind(this, this.update);
    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);

    this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
  }

  _inherits(TextTrackButton, _MenuButton);

  _createClass(TextTrackButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = arguments[0] === undefined ? [] : arguments[0];

      // Add an OFF menu item to turn all tracks off
      items.push(new _OffTextTrackMenuItem2['default'](this.player_, { kind: this.kind_ }));

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        // only add tracks that are of the appropriate kind and have a label
        if (track.kind === this.kind_) {
          items.push(new _TextTrackMenuItem2['default'](this.player_, {
            track: track
          }));
        }
      }

      return items;
    }
  }]);

  return TextTrackButton;
})(_MenuButton3['default']);

_MenuButton3['default'].registerComponent('TextTrackButton', TextTrackButton);
exports['default'] = TextTrackButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-button.js":49,"./off-text-track-menu-item.js":26,"./text-track-menu-item.js":29}],29:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _MenuItem2 = _dereq_('../../menu/menu-item.js');

var _MenuItem3 = _interopRequireWildcard(_MenuItem2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @constructor
 */

var TextTrackMenuItem = (function (_MenuItem) {
  function TextTrackMenuItem(player, options) {
    var _this = this;

    _classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track['default'] || track.mode === 'showing';
    _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;

    if (tracks) {
      (function () {
        var changeHandler = Lib.bind(_this, _this.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks && tracks.onchange === undefined) {
      (function () {
        var event = undefined;

        _this.on(['tap', 'click'], function () {
          if (typeof _window2['default'].Event !== 'object') {
            // Android 2.3 throws an Illegal Constructor error for window.Event
            try {
              event = new _window2['default'].Event('change');
            } catch (err) {}
          }

          if (!event) {
            event = _document2['default'].createEvent('Event');
            event.initEvent('change', true, true);
          }

          tracks.dispatchEvent(event);
        });
      })();
    }
  }

  _inherits(TextTrackMenuItem, _MenuItem);

  _createClass(TextTrackMenuItem, [{
    key: 'onClick',
    value: function onClick(event) {
      var kind = this.track.kind;
      var tracks = this.player_.textTracks();

      _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'onClick', this).call(this, event);

      if (!tracks) {
        return;
      }for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        if (track.kind !== kind) {
          continue;
        }

        if (track === this.track) {
          track.mode = 'showing';
        } else {
          track.mode = 'disabled';
        }
      }
    }
  }, {
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      this.selected(this.track.mode === 'showing');
    }
  }]);

  return TextTrackMenuItem;
})(_MenuItem3['default']);

_MenuItem3['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);
exports['default'] = TextTrackMenuItem;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-item.js":50,"global/document":1,"global/window":2}],30:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * Displays the current time
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var CurrentTimeDisplay = (function (_Component) {
  function CurrentTimeDisplay(player, options) {
    _classCallCheck(this, CurrentTimeDisplay);

    _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(CurrentTimeDisplay, _Component);

  _createClass(CurrentTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-current-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-current-time-display',
        innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      var localizedText = this.localize('Current Time');
      var formattedTime = Lib.formatTime(time, this.player_.duration());
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime;
    }
  }]);

  return CurrentTimeDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
exports['default'] = CurrentTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],31:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * Displays the duration
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var DurationDisplay = (function (_Component) {
  function DurationDisplay(player, options) {
    _classCallCheck(this, DurationDisplay);

    _get(Object.getPrototypeOf(DurationDisplay.prototype), 'constructor', this).call(this, player, options);

    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
    // however the durationchange event fires before this.player_.duration() is set,
    // so the value cannot be written out using this method.
    // Once the order of durationchange and this.player_.duration() being set is figured out,
    // this can be updated.
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(DurationDisplay, _Component);

  _createClass(DurationDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(DurationDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-duration vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-duration-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> 0:00', // label the duration time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var duration = this.player_.duration();
      if (duration) {
        var localizedText = this.localize('Duration Time');
        var formattedTime = Lib.formatTime(duration);
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users
      }
    }
  }]);

  return DurationDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('DurationDisplay', DurationDisplay);
exports['default'] = DurationDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],32:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Displays the time left in the video
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var RemainingTimeDisplay = (function (_Component) {
  function RemainingTimeDisplay(player, options) {
    _classCallCheck(this, RemainingTimeDisplay);

    _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(RemainingTimeDisplay, _Component);

  _createClass(RemainingTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-remaining-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-remaining-time-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> -0:00', // label the remaining time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      if (this.player_.duration()) {
        var localizedText = this.localize('Remaining Time');
        var formattedTime = Lib.formatTime(this.player_.remainingTime());
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> -' + formattedTime;
      }

      // Allows for smooth scrubbing, when player can't keep up.
      // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
    }
  }]);

  return RemainingTimeDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
exports['default'] = RemainingTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib":46}],33:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * The separator between the current time and duration
 *
 * Can be hidden if it's not needed in the design.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var TimeDivider = (function (_Component) {
  function TimeDivider() {
    _classCallCheck(this, TimeDivider);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(TimeDivider, _Component);

  _createClass(TimeDivider, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TimeDivider.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-time-control vjs-time-divider',
        innerHTML: '<div><span>/</span></div>'
      });
    }
  }]);

  return TimeDivider;
})(_Component3['default']);

_Component3['default'].registerComponent('TimeDivider', TimeDivider);
exports['default'] = TimeDivider;
module.exports = exports['default'];

},{"../../component.js":7}],34:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Slider2 = _dereq_('../../slider/slider.js');

var _Slider3 = _interopRequireWildcard(_Slider2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

// Required children

var _VolumeHandle = _dereq_('./volume-handle.js');

var _VolumeHandle2 = _interopRequireWildcard(_VolumeHandle);

var _VolumeLevel = _dereq_('./volume-level.js');

var _VolumeLevel2 = _interopRequireWildcard(_VolumeLevel);

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeBar = (function (_Slider) {
  function VolumeBar(player, options) {
    _classCallCheck(this, VolumeBar);

    _get(Object.getPrototypeOf(VolumeBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(Lib.bind(this, this.updateARIAAttributes));
  }

  _inherits(VolumeBar, _Slider);

  _createClass(VolumeBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-bar',
        'aria-label': 'volume level'
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(event) {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }

      this.player_.volume(this.calculateDistance(event));
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      if (this.player_.muted()) {
        return 0;
      } else {
        return this.player_.volume();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.volume(this.player_.volume() + 0.1);
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.volume(this.player_.volume() - 0.1);
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current value of volume bar as a percentage
      this.el_.setAttribute('aria-valuenow', Lib.round(this.player_.volume() * 100, 2));
      this.el_.setAttribute('aria-valuetext', Lib.round(this.player_.volume() * 100, 2) + '%');
    }
  }]);

  return VolumeBar;
})(_Slider3['default']);

VolumeBar.prototype.options_ = {
  children: {
    volumeLevel: {},
    volumeHandle: {}
  },
  barName: 'volumeLevel',
  handleName: 'volumeHandle'
};

VolumeBar.prototype.playerEvent = 'volumechange';

_Slider3['default'].registerComponent('VolumeBar', VolumeBar);
exports['default'] = VolumeBar;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider.js":58,"./volume-handle.js":36,"./volume-level.js":37}],35:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_import);

// Required children

var _VolumeBar = _dereq_('./volume-bar.js');

var _VolumeBar2 = _interopRequireWildcard(_VolumeBar);

/**
 * The component for controlling the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeControl = (function (_Component) {
  function VolumeControl(player, options) {
    _classCallCheck(this, VolumeControl);

    _get(Object.getPrototypeOf(VolumeControl.prototype), 'constructor', this).call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(VolumeControl, _Component);

  _createClass(VolumeControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-control vjs-control'
      });
    }
  }]);

  return VolumeControl;
})(_Component3['default']);

VolumeControl.prototype.options_ = {
  children: {
    volumeBar: {}
  }
};

_Component3['default'].registerComponent('VolumeControl', VolumeControl);
exports['default'] = VolumeControl;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46,"./volume-bar.js":34}],36:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _SliderHandle2 = _dereq_('../../slider/slider-handle.js');

var _SliderHandle3 = _interopRequireWildcard(_SliderHandle2);

/**
 * The volume handle can be dragged to adjust the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeHandle = (function (_SliderHandle) {
  function VolumeHandle() {
    _classCallCheck(this, VolumeHandle);

    if (_SliderHandle != null) {
      _SliderHandle.apply(this, arguments);
    }
  }

  _inherits(VolumeHandle, _SliderHandle);

  _createClass(VolumeHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-handle'
      });
    }
  }]);

  return VolumeHandle;
})(_SliderHandle3['default']);

VolumeHandle.prototype.defaultValue = '00:00';

_SliderHandle3['default'].registerComponent('VolumeHandle', VolumeHandle);
exports['default'] = VolumeHandle;
module.exports = exports['default'];

},{"../../slider/slider-handle.js":57}],37:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

/**
 * Shows volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeLevel = (function (_Component) {
  function VolumeLevel() {
    _classCallCheck(this, VolumeLevel);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(VolumeLevel, _Component);

  _createClass(VolumeLevel, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeLevel.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-level',
        innerHTML: '<span class="vjs-control-text"></span>'
      });
    }
  }]);

  return VolumeLevel;
})(_Component3['default']);

_Component3['default'].registerComponent('VolumeLevel', VolumeLevel);
exports['default'] = VolumeLevel;
module.exports = exports['default'];

},{"../../component.js":7}],38:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button = _dereq_('../button.js');

var _Button2 = _interopRequireWildcard(_Button);

var _Menu = _dereq_('../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _MenuButton2 = _dereq_('../menu/menu-button.js');

var _MenuButton3 = _interopRequireWildcard(_MenuButton2);

var _MuteToggle = _dereq_('./mute-toggle.js');

var _MuteToggle2 = _interopRequireWildcard(_MuteToggle);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

var _VolumeBar = _dereq_('./volume-control/volume-bar.js');

var _VolumeBar2 = _interopRequireWildcard(_VolumeBar);

/**
 * Menu button with a popup for showing the volume slider.
 * @constructor
 */

var VolumeMenuButton = (function (_MenuButton) {
  function VolumeMenuButton(player, options) {
    _classCallCheck(this, VolumeMenuButton);

    _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'constructor', this).call(this, player, options);

    // Same listeners as MuteToggle
    this.on(player, 'volumechange', this.volumeUpdate);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech.featuresVolumeControl === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech.featuresVolumeControl === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
    this.addClass('vjs-menu-button');
  }

  _inherits(VolumeMenuButton, _MenuButton);

  _createClass(VolumeMenuButton, [{
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player_, {
        contentElType: 'div'
      });

      // The volumeBar is vertical by default in the base theme when used with a VolumeMenuButton
      var options = this.options_.volumeBar || {};
      options.vertical = options.vertical || true;

      var vc = new _VolumeBar2['default'](this.player_, options);

      vc.on('focus', function () {
        menu.lockShowing();
      });
      vc.on('blur', function () {
        menu.unlockShowing();
      });
      menu.addChild(vc);
      return menu;
    }
  }, {
    key: 'onClick',
    value: function onClick() {
      _MuteToggle2['default'].prototype.onClick.call(this);
      _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'onClick', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-menu-button vjs-menu-button vjs-control',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }]);

  return VolumeMenuButton;
})(_MenuButton3['default']);

VolumeMenuButton.prototype.volumeUpdate = _MuteToggle2['default'].prototype.update;

_Button2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);
exports['default'] = VolumeMenuButton;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46,"../menu/menu-button.js":49,"../menu/menu.js":51,"./mute-toggle.js":11,"./volume-control/volume-bar.js":34}],39:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Core Object/Class for objects that use inheritance + constructors
 *
 * To create a class that can be subclassed itself, extend the CoreObject class.
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * The constructor can be defined through the init property of an object argument.
 *
 *     var Animal = CoreObject.extend({
 *       init: function(name, sound){
 *         this.name = name;
 *       }
 *     });
 *
 * Other methods and properties can be added the same way, or directly to the
 * prototype.
 *
 *    var Animal = CoreObject.extend({
 *       init: function(name){
 *         this.name = name;
 *       },
 *       getName: function(){
 *         return this.name;
 *       },
 *       sound: '...'
 *    });
 *
 *    Animal.prototype.makeSound = function(){
 *      alert(this.sound);
 *    };
 *
 * To create an instance of a class, use the create method.
 *
 *    var fluffy = Animal.create('Fluffy');
 *    fluffy.getName(); // -> Fluffy
 *
 * Methods and properties can be overridden in subclasses.
 *
 *     var Horse = Animal.extend({
 *       sound: 'Neighhhhh!'
 *     });
 *
 *     var horsey = Horse.create('Horsey');
 *     horsey.getName(); // -> Horsey
 *     horsey.makeSound(); // -> Alert: Neighhhhh!
 *
 * @class
 * @constructor
 */
var CoreObject = function CoreObject() {};
// Manually exporting vjs['CoreObject'] here for Closure Compiler
// because of the use of the extend/create class methods
// If we didn't do this, those functions would get flattened to something like
// `a = ...` and `this.prototype` would refer to the global object instead of
// CoreObject

/**
 * Create a new object that inherits from this Object
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * @param {Object} props Functions and properties to be applied to the
 *                       new object's prototype
 * @return {CoreObject} An object that inherits from CoreObject
 * @this {*}
 */
CoreObject.extend = function () {
  var props = arguments[0] === undefined ? {} : arguments[0];

  // Set up the constructor using the supplied init method
  // or using the init of the parent object
  // Make sure to check the unobfuscated version for external libs
  var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};
  // In Resig's simple class inheritance (previously used) the constructor
  //  is a function that calls `this.init.apply(arguments)`
  // However that would prevent us from using `ParentObject.call(this);`
  //  in a Child constructor because the `this` in `this.init`
  //  would still refer to the Child and cause an infinite loop.
  // We would instead have to do
  //    `ParentObject.prototype.init.apply(this, arguments);`
  //  Bleh. We're not creating a _super() function, so it's good to keep
  //  the parent constructor reference simple.
  var subObj = function subObj() {
    init.apply(this, arguments);
  };

  // Inherit from this object's prototype
  subObj.prototype = Lib.obj.create(this.prototype);
  // Reset the constructor property for subObj otherwise
  // instances of subObj would have the constructor of the parent Object
  subObj.prototype.constructor = subObj;

  // Make the class extendable
  subObj.extend = CoreObject.extend;
  // Make a function for creating instances
  subObj.create = CoreObject.create;

  // Extend subObj's prototype with functions and other properties from props
  for (var name in props) {
    if (props.hasOwnProperty(name)) {
      subObj.prototype[name] = props[name];
    }
  }

  return subObj;
};

/**
 * Create a new instance of this Object class
 *
 *     var myAnimal = Animal.create();
 *
 * @return {CoreObject} An instance of a CoreObject subclass
 * @this {*}
 */
CoreObject.create = function () {
  // Create a new object that inherits from this object's prototype
  var inst = Lib.obj.create(this.prototype);

  // Apply this constructor function to the new object
  this.apply(inst, arguments);

  // Return the new object
  return inst;
};

exports['default'] = CoreObject;
module.exports = exports['default'];

},{"./lib":46}],40:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Main function src.
 */

var _Player = _dereq_('./player');

var _Player2 = _interopRequireWildcard(_Player);

var _Plugins = _dereq_('./plugins');

var _Plugins2 = _interopRequireWildcard(_Plugins);

var _Options = _dereq_('./options');

var _Options2 = _interopRequireWildcard(_Options);

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('./util');

var VjsUtil = _interopRequireWildcard(_import2);

var _CoreObject = _dereq_('./core-object');

var _CoreObject2 = _interopRequireWildcard(_CoreObject);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 *
 * **ALIASES** videojs, _V_ (deprecated)
 *
 * The `vjs` function can be used to initialize or retrieve a player.
 *
 *     var myPlayer = vjs('my_video_id');
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {Player}             A player instance
 * @namespace
 */
var videojs = function videojs(id, options, ready) {
  var tag; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (_Player2['default'].players[id]) {

      // If options or ready funtion are passed, warn
      if (options) {
        Lib.log.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        _Player2['default'].players[id].ready(ready);
      }

      return _Player2['default'].players[id];

      // Otherwise get element for ID
    } else {
      tag = Lib.el(id);
    }

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  if (!tag || !tag.nodeName) {
    // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag.player || new _Player2['default'](tag, options, ready);
};

// Extended name, also available externally, window.videojs
// var videojs = window['videojs'] = vjs;

// CDN Version. Used to target right flash swf.
videojs.CDN_VERSION = '5.0';
videojs.ACCESS_PROTOCOL = 'https:' == _document2['default'].location.protocol ? 'https://' : 'http://';

/**
* Full player version
* @type {string}
*/
videojs.VERSION = '5.0.0-0';

// Set CDN Version of swf
// The added (+) blocks the replace from changing this _VERSION_NO_PATCH_ string
if (videojs.CDN_VERSION !== '__VERSION_' + 'NO_PATCH__') {
  _Options2['default'].flash.swf = '' + videojs.ACCESS_PROTOCOL + 'vjs.zencdn.net/' + videojs.CDN_VERSION + '/video-js.swf';
}

/**
 * Utility function for adding languages to the default options. Useful for
 * amending multiple language support at runtime.
 *
 * Example: videojs.addLanguage('es', {'Hello':'Hola'});
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting global languages dictionary object
 */
videojs.addLanguage = function (code, data) {
  if (_Options2['default'].languages[code] !== undefined) {
    _Options2['default'].languages[code] = VjsUtil.mergeOptions(_Options2['default'].languages[code], data);
  } else {
    _Options2['default'].languages[code] = data;
  }
  return _Options2['default'].languages;
};

/**
 * Custom Universal Module Definition (UMD)
 *
 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
 * still support requirejs and browserify. This also needs to be closure
 * compiler compatible, so string keys are used.
 */
if (typeof define === 'function' && define.amd) {
  define('videojs', [], function () {
    return videojs;
  });

  // checking that module is an object too because of umdjs/umd#35
} else if (typeof exports === 'object' && typeof module === 'object') {
  module.exports = videojs;
}

exports['default'] = videojs;
module.exports = exports['default'];

},{"./core-object":39,"./lib":46,"./options":52,"./player":53,"./plugins":54,"./util":70,"global/document":1}],41:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Display that an error has occurred making the video unplayable
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ErrorDisplay = (function (_Component) {
  function ErrorDisplay(player, options) {
    _classCallCheck(this, ErrorDisplay);

    _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'constructor', this).call(this, player, options);

    this.update();
    this.on(player, 'error', this.update);
  }

  _inherits(ErrorDisplay, _Component);

  _createClass(ErrorDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-error-display'
      });

      this.contentEl_ = Lib.createEl('div');
      el.appendChild(this.contentEl_);

      return el;
    }
  }, {
    key: 'update',
    value: function update() {
      if (this.player().error()) {
        this.contentEl_.innerHTML = this.localize(this.player().error().message);
      }
    }
  }]);

  return ErrorDisplay;
})(_Component3['default']);

_Component3['default'].registerComponent('ErrorDisplay', ErrorDisplay);
exports['default'] = ErrorDisplay;
module.exports = exports['default'];

},{"./component":7,"./lib":46}],42:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./events');

var Events = _interopRequireWildcard(_import);

var _import2 = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import2);

var EventEmitter = function EventEmitter() {};

EventEmitter.prototype.allowedEvents_ = {};

EventEmitter.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;
  this.addEventListener = Function.prototype;
  Events.on(this, type, fn);
  this.addEventListener = ael;
};
EventEmitter.prototype.addEventListener = EventEmitter.prototype.on;

EventEmitter.prototype.off = function (type, fn) {
  Events.off(this, type, fn);
};
EventEmitter.prototype.removeEventListener = EventEmitter.prototype.off;

EventEmitter.prototype.one = function (type, fn) {
  Events.one(this, type, fn);
};

EventEmitter.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = {
      type: type
    };
  }
  event = Events.fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  Events.trigger(this, event);
};
// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
EventEmitter.prototype.dispatchEvent = EventEmitter.prototype.trigger;

exports['default'] = EventEmitter;
module.exports = exports['default'];

},{"./events":43,"./lib":46}],43:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Fix a native event to have standard property values
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 */
var fixEvent = function fixEvent(event) {

  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || _window2['default'].event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || _document2['default'];
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = _document2['default'].documentElement,
          body = _document2['default'].body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }

  // Returns fixed-up instance
  return event;
};

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @private
 */
var on = (function (_on) {
  function on(_x, _x2, _x3) {
    return _on.apply(this, arguments);
  }

  on.toString = function () {
    return _on.toString();
  };

  return on;
})(function (elem, type, fn) {
  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = Lib.getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = Lib.guid++;

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event) {

      if (data.disabled) return;
      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            handlersCopy[m].call(elem, event);
          }
        }
      }
    };
  }

  if (data.handlers[type].length == 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
});

/**
 * Removes event listeners from an element
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @private
 */
var off = (function (_off) {
  function off(_x4, _x5, _x6) {
    return _off.apply(this, arguments);
  }

  off.toString = function () {
    return _off.toString();
  };

  return off;
})(function (elem, type, fn) {
  // Don't want to add a cache object through getData if not needed
  if (!Lib.hasData(elem)) return;

  var data = Lib.getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) return;

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  cleanUpEvents(elem, type);
});

/**
 * Clean up the listener cache and dispatchers
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 */
var cleanUpEvents = function cleanUpEvents(elem, type) {
  var data = Lib.getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Lib.isEmpty(data.handlers)) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;

    // data.handlers = null;
    // data.dispatcher = null;
    // data.disabled = null;
  }

  // Finally remove the expando if there is no data left
  if (Lib.isEmpty(data)) {
    Lib.removeData(elem);
  }
};

/**
 * Trigger an event for an element
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @private
 */
var trigger = (function (_trigger) {
  function trigger(_x7, _x8) {
    return _trigger.apply(this, arguments);
  }

  trigger.toString = function () {
    return _trigger.toString();
  };

  return trigger;
})(function (elem, event) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasData first.
  var elemData = Lib.hasData(elem) ? Lib.getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
    trigger(parent, event);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = Lib.getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
});

/**
 * Trigger a listener only once for an event
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type
 * @param  {Function} fn
 * @private
 */
var one = (function (_one) {
  function one(_x9, _x10, _x11) {
    return _one.apply(this, arguments);
  }

  one.toString = function () {
    return _one.toString();
  };

  return one;
})(function (elem, type, fn) {
  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = (function (_func) {
    function func() {
      return _func.apply(this, arguments);
    }

    func.toString = function () {
      return _func.toString();
    };

    return func;
  })(function () {
    off(elem, type, func);
    fn.apply(this, arguments);
  });
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || Lib.guid++;
  on(elem, type, func);
});

/**
 * Loops through an array of event types and calls the requested method for each type.
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 */
function _handleMultipleEvents(fn, elem, type, callback) {
  Lib.arr.forEach(type, function (type) {
    fn(elem, type, callback); //Call the event method for each one of the types
  });
}

exports.on = on;
exports.off = off;
exports.cleanUpEvents = cleanUpEvents;
exports.fixEvent = fixEvent;
exports.one = one;
exports.trigger = trigger;

},{"./lib":46,"global/document":1,"global/window":2}],44:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * ```
 * var Button = videojs.getComponent('Button');
 *
 * var MyButton = videojs.extends(Button, {
 *   constructor: function(player, options) {
 *     Button.call(this, player, options);
 *   },
 *
 *   onClick: function() {
 *     // doSomething
 *   }
 * });
 * ```
 */
var extendsFn = function extendsFn(superClass) {
  var subClassMethods = arguments[1] === undefined ? {} : arguments[1];

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };
  var methods = {};

  if (subClassMethods.constructor !== Object.prototype.constructor) {
    subClass = subClassMethods.constructor;
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

exports['default'] = extendsFn;
module.exports = exports['default'];

},{"./lib":46}],45:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Store the browser-specific methods for the fullscreen API
 * @type {Object|undefined}
 * @private
 */
var FullscreenApi = {};

// browser API methods
// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
var apiMap = [
// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = undefined;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in _document2['default']) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var i = 0; i < browserApi.length; i++) {
    FullscreenApi[specApi[i]] = browserApi[i];
  }
}

exports['default'] = FullscreenApi;
module.exports = exports['default'];

},{"global/document":1}],46:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var navigator = _window2['default'].navigator;

var hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * Creates an element and applies properties.
 * @param  {String=} tagName    Name of tag to be created.
 * @param  {Object=} properties Element properties to be applied.
 * @return {Element}
 * @private
 */
var createEl = function createEl() {
  var tagName = arguments[0] === undefined ? 'div' : arguments[0];
  var properties = arguments[1] === undefined ? {} : arguments[1];

  var el = _document2['default'].createElement(tagName);

  obj.each(properties, function (propName, val) {
    // Not remembering why we were checking for dash
    // but using setAttribute means you have to use getAttribute

    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
    // The additional check for "role" is because the default method for adding attributes does not
    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
      el.setAttribute(propName, val);
    } else {
      el[propName] = val;
    }
  });

  return el;
};

/**
 * Uppercase the first letter of a string
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 */
var capitalize = function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};

/**
 * Object functions container
 * @type {Object}
 * @private
 */
var obj = {};

/**
 * Object.create shim for prototypal inheritance
 *
 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 *
 * @function
 * @param  {Object}   obj Object to use as prototype
 * @private
 */
obj.create = Object.create || function (obj) {
  //Create a new function called 'F' which is just an empty object.
  function F() {}

  //the prototype of the 'F' function should point to the
  //parameter of the anonymous function.
  F.prototype = obj;

  //create a new constructor function based off of the 'F' function.
  return new F();
};

/**
 * Loop through each property in an object and call a function
 * whose arguments are (key,value)
 * @param  {Object}   obj Object of properties
 * @param  {Function} fn  Function to be called on each property.
 * @this {*}
 * @private
 */
obj.each = function (obj, fn, context) {
  for (var key in obj) {
    if (hasOwnProp.call(obj, key)) {
      fn.call(context || this, key, obj[key]);
    }
  }
};

/**
 * Merge two objects together and return the original.
 * @param  {Object} obj1
 * @param  {Object} obj2
 * @return {Object}
 * @private
 */
obj.merge = function (obj1, obj2) {
  if (!obj2) {
    return obj1;
  }
  for (var key in obj2) {
    if (hasOwnProp.call(obj2, key)) {
      obj1[key] = obj2[key];
    }
  }
  return obj1;
};

/**
 * Merge two objects, and merge any properties that are objects
 * instead of just overwriting one. Uses to merge options hashes
 * where deeper default settings are important.
 * @param  {Object} obj1 Object to override
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
 * @private
 */
obj.deepMerge = function (obj1, obj2) {
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = obj.copy(obj1);

  for (key in obj2) {
    if (hasOwnProp.call(obj2, key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (obj.isPlain(val1) && obj.isPlain(val2)) {
        obj1[key] = obj.deepMerge(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};

/**
 * Make a copy of the supplied object
 * @param  {Object} obj Object to copy
 * @return {Object}     Copy of object
 * @private
 */
obj.copy = function (objToCopy) {
  return obj.merge({}, objToCopy);
};

/**
 * Check if an object is plain, and not a dom node or any object sub-instance
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
obj.isPlain = function (obj) {
  return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;
};

/**
 * Check if an object is Array
*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
obj.isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
   It also stores a unique id on the function so it can be easily removed from events
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = (exports.guid = guid += 1, guid - 1);
  }

  // Create the new function that changes the context
  var ret = function ret() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return ret;
};

/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 * @type {Object}
 * @private
 */
var cache = {};

/**
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
var guid = 1;

/**
 * Unique attribute name to store an element's guid in
 * @type {String}
 * @constant
 * @private
 */
var expando = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
var getData = function getData(el) {
  var id = el[expando];
  if (!id) {
    id = el[expando] = (exports.guid = guid += 1, guid - 1);
  }
  if (!cache[id]) {
    cache[id] = {};
  }
  return cache[id];
};

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
var hasData = function hasData(el) {
  var id = el[expando];
  return !(!id || isEmpty(cache[id]));
};

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 * @param  {Element} el Remove data for an element
 * @private
 */
var removeData = function removeData(el) {
  var id = el[expando];
  if (!id) {
    return;
  }
  // Remove all stored data
  // Changed to = null
  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
  // cache[id] = null;
  delete cache[id];

  // Remove the expando property from the DOM node
  try {
    delete el[expando];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(expando);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[expando] = null;
    }
  }
};

/**
 * Check if an object is empty
 * @param  {Object}  obj The object to check for emptiness
 * @return {Boolean}
 * @private
 */
var isEmpty = function isEmpty(obj) {
  for (var prop in obj) {
    // Inlude null properties as empty.
    if (obj[prop] !== null) {
      return false;
    }
  }
  return true;
};

/**
 * Check if an element has a CSS class
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 * @private
 */
var hasClass = function hasClass(element, classToCheck) {
  return (' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1;
};

/**
 * Add a CSS class name to an element
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 * @private
 */
var addClass = function addClass(element, classToAdd) {
  if (!hasClass(element, classToAdd)) {
    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
  }
};

/**
 * Remove a CSS class name from an element
 * @param {Element} element    Element to remove from class name
 * @param {String} classToAdd Classname to remove
 * @private
 */
var removeClass = function removeClass(element, classToRemove) {
  if (!hasClass(element, classToRemove)) {
    return;
  }

  var classNames = element.className.split(' ');

  // no arr.indexOf in ie8, and we don't want to add a big shim
  for (var i = classNames.length - 1; i >= 0; i--) {
    if (classNames[i] === classToRemove) {
      classNames.splice(i, 1);
    }
  }

  element.className = classNames.join(' ');
};

/**
 * Element for testing browser HTML5 video capabilities
 * @type {Element}
 * @constant
 * @private
 */
var TEST_VID = createEl('video');
var track = _document2['default'].createElement('track');
track.kind = 'captions';
track.srclang = 'en';
track.label = 'English';
TEST_VID.appendChild(track);

/**
 * Useragent for browser testing.
 * @type {String}
 * @constant
 * @private
 */
var USER_AGENT = navigator.userAgent;

/**
 * Device is an iPhone
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPHONE = /iPhone/i.test(USER_AGENT);
var IS_IPAD = /iPad/i.test(USER_AGENT);
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = (function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
})();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = (function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
      major,
      minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_CHROME = /Chrome/i.test(USER_AGENT);
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);

var TOUCH_ENABLED = !!('ontouchstart' in _window2['default'] || _window2['default'].DocumentTouch && _document2['default'] instanceof _window2['default'].DocumentTouch);
var BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in TEST_VID.style);

/**
 * Apply attributes to an HTML element.
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 */
var setElementAttributes = function setElementAttributes(el, attributes) {
  obj.each(attributes, function (attrName, attrValue) {
    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
};

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 */
var getElementAttributes = function getElementAttributes(tag) {
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
};

/**
 * Get the computed style value for an element
 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
 * @param  {Element} el        Element to get style value for
 * @param  {String} strCssRule Style name
 * @return {String}            Style value
 * @private
 */
var getComputedDimension = function getComputedDimension(el, strCssRule) {
  var strValue = '';
  if (_document2['default'].defaultView && _document2['default'].defaultView.getComputedStyle) {
    strValue = _document2['default'].defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);
  } else if (el.currentStyle) {
    // IE8 Width/Height support
    var upperCasedRule = strCssRule.substr(0, 1).toUpperCase() + strCssRule.substr(1);
    strValue = el['client' + upperCasedRule] + 'px';
  }
  return strValue;
};

/**
 * Insert an element as the first child node of another
 * @param  {Element} child   Element to insert
 * @param  {[type]} parent Element to insert child into
 * @private
 */
var insertFirst = function insertFirst(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
};

/**
 * Object to hold browser support information
 * @type {Object}
 * @private
 */
var browser = {};

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @private
 */
var el = function el(id) {
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return _document2['default'].getElementById(id);
};

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 */
var formatTime = function formatTime(seconds) {
  var guide = arguments[1] === undefined ? seconds : arguments[1];
  return (function () {
    var s = Math.floor(seconds % 60);
    var m = Math.floor(seconds / 60 % 60);
    var h = Math.floor(seconds / 3600);
    var gm = Math.floor(guide / 60 % 60);
    var gh = Math.floor(guide / 3600);

    // handle invalid times
    if (isNaN(seconds) || seconds === Infinity) {
      // '-' is false for all relational operators (e.g. <, >=) so this setting
      // will add the minimum number of fields specified by the guide
      h = m = s = '-';
    }

    // Check if we need to show hours
    h = h > 0 || gh > 0 ? h + ':' : '';

    // If hours are showing, we may need to add a leading zero.
    // Always show at least one digit of minutes.
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

    // Check if leading zero is need for seconds
    s = s < 10 ? '0' + s : s;

    return h + m + s;
  })();
};

// Attempt to block the ability to select text while dragging controls
var blockTextSelection = function blockTextSelection() {
  _document2['default'].body.focus();
  _document2['default'].onselectstart = function () {
    return false;
  };
};
// Turn off text selection blocking
var unblockTextSelection = function unblockTextSelection() {
  _document2['default'].onselectstart = function () {
    return true;
  };
};

/**
 * Trim whitespace from the ends of a string.
 * @param  {String} string String to trim
 * @return {String}        Trimmed string
 * @private
 */
var trim = function trim(str) {
  return (str + '').replace(/^\s+|\s+$/g, '');
};

/**
 * Should round off a number to a decimal place
 * @param  {Number} num Number to round
 * @param  {Number} dec Number of decimal places to round to
 * @return {Number}     Rounded number
 * @private
 */
var round = function round(num) {
  var dec = arguments[1] === undefined ? 0 : arguments[1];

  return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
};

/**
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 * @param  {Number} start Start time in seconds
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @private
 */
var createTimeRange = function createTimeRange(start, end) {
  return {
    length: 1,
    start: (function (_start) {
      function start() {
        return _start.apply(this, arguments);
      }

      start.toString = function () {
        return _start.toString();
      };

      return start;
    })(function () {
      return start;
    }),
    end: (function (_end) {
      function end() {
        return _end.apply(this, arguments);
      }

      end.toString = function () {
        return _end.toString();
      };

      return end;
    })(function () {
      return end;
    })
  };
};

/**
 * Add to local storage (maybe removable)
 * @private
 */
var setLocalStorage = function setLocalStorage(key, value) {
  try {
    // IE was throwing errors referencing the var anywhere without this
    var _localStorage = _window2['default'].localStorage || false;
    if (!_localStorage) {
      return;
    }
    _localStorage[key] = value;
  } catch (e) {
    if (e.code == 22 || e.code == 1014) {
      // Webkit == 22 / Firefox == 1014
      log('LocalStorage Full (VideoJS)', e);
    } else {
      if (e.code == 18) {
        log('LocalStorage not allowed (VideoJS)', e);
      } else {
        log('LocalStorage Error (VideoJS)', e);
      }
    }
  }
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    url = createEl('div', {
      innerHTML: '<a href="' + url + '">x</a>'
    }).firstChild.href;
  }

  return url;
};

/**
 * Resolve and parse the elements of a URL
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = createEl('a', { href: url });

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = undefined;
  if (addToBody) {
    div = createEl('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    _document2['default'].body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }
  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    _document2['default'].body.removeChild(div);
  }

  return details;
};

/**
 * Log messages to the console and history based on the type of message
 *
 * @param  {String} type The type of message, or `null` for `log`
 * @param  {[type]} args The args to be passed to the log
 * @private
 */
function _logType(type, args) {
  // convert args to an array to get array functions
  var argsArray = Array.prototype.slice.call(args);
  // if there's no console then don't try to output messages
  // they will still be stored in Lib.log.history
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  var noop = function noop() {};

  var console = _window2['default'].console || {
    log: noop,
    warn: noop,
    error: noop
  };

  if (type) {
    // add the type to the front of the message
    argsArray.unshift(type.toUpperCase() + ':');
  } else {
    // default to log with no prefix
    type = 'log';
  }

  // add to history
  log.history.push(argsArray);

  // add console prefix after adding to history
  argsArray.unshift('VIDEOJS:');

  // call appropriate log function
  if (console[type].apply) {
    console[type].apply(console, argsArray);
  } else {
    // ie8 doesn't allow error.apply, but it will just join() the array anyway
    console[type](argsArray.join(' '));
  }
}

/**
 * Log plain debug messages
 */
var log = function log() {
  _logType(null, arguments);
};

/**
 * Keep a history of log messages
 * @type {Array}
 */
log.history = [];

/**
 * Log error messages
 */
log.error = function () {
  _logType('error', arguments);
};

/**
 * Log warning messages
 */
log.warn = function () {
  _logType('warn', arguments);
};

// Offset Left
// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
var findPosition = function findPosition(el) {
  var box = undefined;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = _document2['default'].documentElement;
  var body = _document2['default'].body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: round(left),
    top: round(top)
  };
};

/**
 * Array functions container
 * @type {Object}
 * @private
 */
var arr = {};

/*
 * Loops through an array and runs a function for each item inside it.
 * @param  {Array}    array       The array
 * @param  {Function} callback    The function to be run for each item
 * @param  {*}        thisArg     The `this` binding of callback
 * @returns {Array}               The array
 * @private
 */
arr.forEach = function (array, callback, thisArg) {
  thisArg = thisArg || this;

  if (obj.isArray(array) && callback instanceof Function) {
    for (var i = 0, len = array.length; i < len; ++i) {
      callback.call(thisArg, array[i], i, array);
    }
  }

  return array;
};

/**
 * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path
 *
 * @param {String}    path    The fileName path like '/path/to/file.mp4'
 * @returns {String}          The extension in lower case or an empty string if no extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

exports.createEl = createEl;
exports.capitalize = capitalize;
exports.obj = obj;
exports.isNaN = isNaN;
exports.bind = bind;
exports.cache = cache;
exports.guid = guid;
exports.expando = expando;
exports.getData = getData;
exports.hasData = hasData;
exports.removeData = removeData;
exports.isEmpty = isEmpty;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.TEST_VID = TEST_VID;
exports.USER_AGENT = USER_AGENT;
exports.IS_IPHONE = IS_IPHONE;
exports.IS_IPAD = IS_IPAD;
exports.IS_IPOD = IS_IPOD;
exports.IS_IOS = IS_IOS;
exports.IOS_VERSION = IOS_VERSION;
exports.IS_ANDROID = IS_ANDROID;
exports.ANDROID_VERSION = ANDROID_VERSION;
exports.IS_OLD_ANDROID = IS_OLD_ANDROID;
exports.IS_FIREFOX = IS_FIREFOX;
exports.IS_IE8 = IS_IE8;
exports.IS_CHROME = IS_CHROME;
exports.TOUCH_ENABLED = TOUCH_ENABLED;
exports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;
exports.setElementAttributes = setElementAttributes;
exports.getElementAttributes = getElementAttributes;
exports.getComputedDimension = getComputedDimension;
exports.insertFirst = insertFirst;
exports.browser = browser;
exports.el = el;
exports.formatTime = formatTime;
exports.blockTextSelection = blockTextSelection;
exports.unblockTextSelection = unblockTextSelection;
exports.trim = trim;
exports.round = round;
exports.createTimeRange = createTimeRange;
exports.setLocalStorage = setLocalStorage;
exports.getAbsoluteURL = getAbsoluteURL;
exports.parseUrl = parseUrl;
exports.log = log;
exports.findPosition = findPosition;
exports.arr = arr;
exports.getFileExtension = getFileExtension;

},{"global/document":1,"global/window":2}],47:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component');

var _Component3 = _interopRequireWildcard(_Component2);

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var LoadingSpinner = (function (_Component) {
  function LoadingSpinner() {
    _classCallCheck(this, LoadingSpinner);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LoadingSpinner, _Component);

  _createClass(LoadingSpinner, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadingSpinner.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-loading-spinner'
      });
    }
  }]);

  return LoadingSpinner;
})(_Component3['default']);

_Component3['default'].registerComponent('LoadingSpinner', LoadingSpinner);
exports['default'] = LoadingSpinner;
module.exports = exports['default'];

},{"./component":7}],48:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

/**
 * Custom MediaError to mimic the HTML5 MediaError
 * @param {Number} code The media error code
 */
var MediaError = (function (_MediaError) {
  function MediaError(_x) {
    return _MediaError.apply(this, arguments);
  }

  MediaError.toString = function () {
    return _MediaError.toString();
  };

  return MediaError;
})(function (code) {
  if (typeof code === 'number') {
    this.code = code;
  } else if (typeof code === 'string') {
    // default code is zero, so this is a custom error
    this.message = code;
  } else if (typeof code === 'object') {
    // object
    Lib.obj.merge(this, code);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
});

/**
 * The error code that refers two one of the defined
 * MediaError types
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 * @type {[type]}
 */
MediaError.prototype.status = null;

MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0
'MEDIA_ERR_ABORTED', // = 1
'MEDIA_ERR_NETWORK', // = 2
'MEDIA_ERR_DECODE', // = 3
'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
'MEDIA_ERR_ENCRYPTED' // = 5
];

MediaError.defaultMessages = {
  1: 'You aborted the video playback',
  2: 'A network error caused the video download to fail part-way.',
  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The video is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

exports['default'] = MediaError;
module.exports = exports['default'];

},{"./lib":46}],49:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _Menu = _dereq_('./menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * A button class with a popup menu
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MenuButton = (function (_Button) {
  function MenuButton(player, options) {
    _classCallCheck(this, MenuButton);

    _get(Object.getPrototypeOf(MenuButton.prototype), 'constructor', this).call(this, player, options);

    this.update();

    this.on('keydown', this.onKeyPress);
    this.el_.setAttribute('aria-haspopup', true);
    this.el_.setAttribute('role', 'button');
  }

  _inherits(MenuButton, _Button);

  _createClass(MenuButton, [{
    key: 'update',
    value: function update() {
      var menu = this.createMenu();

      if (this.menu) {
        this.removeChild(this.menu);
      }

      this.menu = menu;
      this.addChild(menu);

      /**
       * Track the state of the menu button
       * @type {Boolean}
       * @private
       */
      this.buttonPressed_ = false;

      if (this.items && this.items.length === 0) {
        this.hide();
      } else if (this.items && this.items.length > 1) {
        this.show();
      }
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _Menu2['default'](this.player_);

      // Add a title list item to the top
      if (this.options().title) {
        menu.contentEl().appendChild(Lib.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: Lib.capitalize(this.options().title),
          tabindex: -1
        }));
      }

      this.items = this.createItems();

      if (this.items) {
        // Add menu items to the menu
        for (var i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }

      return menu;
    }
  }, {
    key: 'createItems',

    /**
     * Create the list of menu items. Specific to each subclass.
     */
    value: function createItems() {}
  }, {
    key: 'buildCSSClass',

    /** @inheritDoc */
    value: function buildCSSClass() {
      return '' + this.className + ' vjs-menu-button ' + _get(Object.getPrototypeOf(MenuButton.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'onFocus',

    // Focus - Add keyboard functionality to element
    // This function is not needed anymore. Instead, the keyboard functionality is handled by
    // treating the button as triggering a submenu. When the button is pressed, the submenu
    // appears. Pressing the button again makes the submenu disappear.
    value: function onFocus() {}
  }, {
    key: 'onBlur',

    // Can't turn off list display that we turned on with focus, because list would go away.
    value: function onBlur() {}
  }, {
    key: 'onClick',
    value: function onClick() {
      // When you click the button it adds focus, which will show the menu indefinitely.
      // So we'll remove focus when the mouse leaves the button.
      // Focus is needed for tab navigation.
      this.one('mouseout', Lib.bind(this, function () {
        this.menu.unlockShowing();
        this.el_.blur();
      }));
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(event) {

      // Check for space bar (32) or enter (13) keys
      if (event.which == 32 || event.which == 13) {
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
        event.preventDefault();
        // Check for escape (27) key
      } else if (event.which == 27) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        event.preventDefault();
      }
    }
  }, {
    key: 'pressButton',
    value: function pressButton() {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.el_.setAttribute('aria-pressed', true);
      if (this.items && this.items.length > 0) {
        this.items[0].el().focus(); // set the focus to the title of the submenu
      }
    }
  }, {
    key: 'unpressButton',
    value: function unpressButton() {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.el_.setAttribute('aria-pressed', false);
    }
  }]);

  return MenuButton;
})(_Button3['default']);

_Button3['default'].registerComponent('MenuButton', MenuButton);
exports['default'] = MenuButton;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46,"./menu.js":51}],50:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('../button.js');

var _Button3 = _interopRequireWildcard(_Button2);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * The component for a menu item. `<li>`
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var MenuItem = (function (_Button) {
  function MenuItem(player, options) {
    _classCallCheck(this, MenuItem);

    _get(Object.getPrototypeOf(MenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(options.selected);
  }

  _inherits(MenuItem, _Button);

  _createClass(MenuItem, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      return _get(Object.getPrototypeOf(MenuItem.prototype), 'createEl', this).call(this, 'li', Lib.obj.merge({
        className: 'vjs-menu-item',
        innerHTML: this.localize(this.options_.label)
      }, props));
    }
  }, {
    key: 'onClick',

    /**
     * Handle a click on the menu item, and set it to selected
     */
    value: function onClick() {
      this.selected(true);
    }
  }, {
    key: 'selected',

    /**
     * Set this menu item as selected or not
     * @param  {Boolean} selected
     */
    value: (function (_selected) {
      function selected(_x) {
        return _selected.apply(this, arguments);
      }

      selected.toString = function () {
        return _selected.toString();
      };

      return selected;
    })(function (selected) {
      if (selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-selected', true);
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-selected', false);
      }
    })
  }]);

  return MenuItem;
})(_Button3['default']);

_Button3['default'].registerComponent('MenuItem', MenuItem);
exports['default'] = MenuItem;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46}],51:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('../events.js');

var Events = _interopRequireWildcard(_import2);

/* Menu
================================================================================ */
/**
 * The Menu component is used to build pop up menus, including subtitle and
 * captions selection menus.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Menu = (function (_Component) {
  function Menu() {
    _classCallCheck(this, Menu);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Menu, _Component);

  _createClass(Menu, [{
    key: 'addItem',

    /**
     * Add a menu item to the menu
     * @param {Object|String} component Component or component type to add
     */
    value: function addItem(component) {
      this.addChild(component);
      component.on('click', Lib.bind(this, function () {
        this.unlockShowing();
      }));
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var contentElType = this.options().contentElType || 'ul';
      this.contentEl_ = Lib.createEl(contentElType, {
        className: 'vjs-menu-content'
      });
      var el = _get(Object.getPrototypeOf(Menu.prototype), 'createEl', this).call(this, 'div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);

      // Prevent clicks from bubbling up. Needed for Menu Buttons,
      // where a click on the parent is significant
      Events.on(el, 'click', function (event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });

      return el;
    }
  }]);

  return Menu;
})(_Component3['default']);

_Component3['default'].registerComponent('Menu', Menu);
exports['default'] = Menu;
module.exports = exports['default'];

},{"../component.js":7,"../events.js":43,"../lib.js":46}],52:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var navigator = _window2['default'].navigator;

/**
 * Global Player instance options, surfaced from Player.prototype.options_
 * options = Player.prototype.options_
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 */
exports['default'] = {
  // Default order of fallback technology
  techOrder: ['html5', 'flash'],
  // techOrder: ['flash','html5'],

  html5: {},
  flash: {},

  // Default of web browser is 300x150. Should rely on source width/height.
  width: 300,
  height: 150,
  // defaultVolume: 0.85,
  defaultVolume: 0, // The freakin seaguls are driving me crazy!

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: {
    mediaLoader: {},
    posterImage: {},
    textTrackDisplay: {},
    loadingSpinner: {},
    bigPlayButton: {},
    controlBar: {},
    errorDisplay: {},
    textTrackSettings: {}
  },

  language: _document2['default'].getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this video.'
};
module.exports = exports['default'];

},{"global/document":1,"global/window":2}],53:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('./component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('./lib.js');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('./events.js');

var Events = _interopRequireWildcard(_import2);

var _FullscreenApi = _dereq_('./fullscreen-api.js');

var _FullscreenApi2 = _interopRequireWildcard(_FullscreenApi);

var _MediaError = _dereq_('./media-error.js');

var _MediaError2 = _interopRequireWildcard(_MediaError);

var _Options = _dereq_('./options.js');

var _Options2 = _interopRequireWildcard(_Options);

var _safeParseTuple = _dereq_('safe-json-parse/tuple');

var _safeParseTuple2 = _interopRequireWildcard(_safeParseTuple);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

// Include required child components

var _MediaLoader = _dereq_('./tech/loader.js');

var _MediaLoader2 = _interopRequireWildcard(_MediaLoader);

var _Poster = _dereq_('./poster-image.js');

var _Poster2 = _interopRequireWildcard(_Poster);

var _TextTrackDisplay = _dereq_('./tracks/text-track-display.js');

var _TextTrackDisplay2 = _interopRequireWildcard(_TextTrackDisplay);

var _LoadingSpinner = _dereq_('./loading-spinner.js');

var _LoadingSpinner2 = _interopRequireWildcard(_LoadingSpinner);

var _BigPlayButton = _dereq_('./big-play-button.js');

var _BigPlayButton2 = _interopRequireWildcard(_BigPlayButton);

var _controlBar = _dereq_('./control-bar/control-bar.js');

var _controlBar2 = _interopRequireWildcard(_controlBar);

var _ErrorDisplay = _dereq_('./error-display.js');

var _ErrorDisplay2 = _interopRequireWildcard(_ErrorDisplay);

var _TextTrackSettings = _dereq_('./tracks/text-track-settings.js');

var _TextTrackSettings2 = _interopRequireWildcard(_TextTrackSettings);

// Require html5 for disposing the original video tag

var _Html5 = _dereq_('./tech/html5.js');

var _Html52 = _interopRequireWildcard(_Html5);

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.
 *
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 *
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 *
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 *
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @class
 * @extends Component
 */

var Player = (function (_Component) {

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */

  function Player(tag, options, ready) {
    _classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + Lib.guid++;

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = Lib.obj.merge(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // Run base component initializing with new options
    _get(Object.getPrototypeOf(Player.prototype), 'constructor', this).call(this, null, options, ready);

    this.tag = tag; // Store the original tag used to set options

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && Lib.getElementAttributes(tag);

    // Update Current Language
    this.language_ = options.language || _Options2['default'].language;

    // Update Supported Languages
    this.languages_ = options.languages || _Options2['default'].languages;

    // Cache for video property values.
    this.cache_ = {};

    // Set poster
    this.poster_ = options.poster || '';

    // Set controls
    this.controls_ = !!options.controls;
    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /**
    * Store the internal state of scrubbing
    * @private
    * @return {Boolean} True if the user is scrubbing
    */
    this.scrubbing_ = false;

    this.el_ = this.createEl();
    this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    if (this.flexNotSupported_()) {
      this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (Lib.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // Make player easily findable by ID
    Player.players[this.id_] = this;

    if (options.plugins) {
      Lib.obj.each(options.plugins, function (key, val) {
        this[key](val);
      }, this);
    }

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    this.userActive_ = true;
    this.reportUserActivity();
    this.listenForUserActivity();
  }

  _inherits(Player, _Component);

  _createClass(Player, [{
    key: 'dispose',

    /**
     * Destroys the video player and does any necessary cleanup
     *
     *     myPlayer.dispose();
     *
     * This is especially helpful if you are dynamically adding and removing videos
     * to/from the DOM.
     */
    value: function dispose() {
      this.trigger('dispose');
      // prevent dispose from being called twice
      this.off('dispose');

      // Kill reference to this player
      Player.players[this.id_] = null;
      if (this.tag && this.tag.player) {
        this.tag.player = null;
      }
      if (this.el_ && this.el_.player) {
        this.el_.player = null;
      }

      if (this.tech) {
        this.tech.dispose();
      }

      _get(Object.getPrototypeOf(Player.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var el = this.el_ = _get(Object.getPrototypeOf(Player.prototype), 'createEl', this).call(this, 'div');
      var tag = this.tag;

      // Remove width/height attrs from tag so CSS can make it 100% width/height
      tag.removeAttribute('width');
      tag.removeAttribute('height');

      // Copy over all the attributes from the tag, including ID and class
      // ID will now reference player box, not the video tag
      var attrs = Lib.getElementAttributes(tag);
      Lib.obj.each(attrs, function (attr) {
        // workaround so we don't totally break IE7
        // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
        if (attr == 'class') {
          el.className = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      });

      // Update tag id/class for use as HTML5 playback tech
      // Might think we should do this after embedding in container so .vjs-tech class
      // doesn't flash 100% width/height, but class only applies with .video-js parent
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';

      // Make player findable on elements
      tag.player = el.player = this;
      // Default state of video is paused
      this.addClass('vjs-paused');

      // Make box use width/height of tag, or rely on default implementation
      // Enforce with CSS since width/height attrs don't work on divs
      this.width(this.options_.width, true); // (true) Skip resize listener on load
      this.height(this.options_.height, true);

      // Lib.insertFirst seems to cause the networkState to flicker from 3 to 2, so
      // keep track of the original for later so we can know if the source originally failed
      tag.initNetworkState_ = tag.networkState;

      // Wrap video tag in div (el/box) container
      if (tag.parentNode) {
        tag.parentNode.insertBefore(el, tag);
      }
      Lib.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

      // The event listeners need to be added before the children are added
      // in the component init because the tech (loaded with mediaLoader) may
      // fire events, like loadstart, that these events need to capture.
      // Long term it might be better to expose a way to do this in component.init
      // like component.initEventListeners() that runs between el creation and
      // adding children
      this.el_ = el;
      this.on('loadstart', this.onLoadStart);
      this.on('waiting', this.onWaiting);
      this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
      this.on('seeking', this.onSeeking);
      this.on('seeked', this.onSeeked);
      this.on('ended', this.onEnded);
      this.on('play', this.onPlay);
      this.on('firstplay', this.onFirstPlay);
      this.on('pause', this.onPause);
      this.on('progress', this.onProgress);
      this.on('durationchange', this.onDurationChange);
      this.on('fullscreenchange', this.onFullscreenChange);

      return el;
    }
  }, {
    key: 'loadTech',

    /**
     * Load the Media Playback Technology (tech)
     * Load/Create an instance of playback technology including element and API methods
     * And append playback element in player div.
     */
    value: function loadTech(techName, source) {

      // Pause and remove current playback technology
      if (this.tech) {
        this.unloadTech();
      }

      // get rid of the HTML5 video tag as soon as we are using another tech
      if (techName !== 'Html5' && this.tag) {
        _Component3['default'].getComponent('Html5').disposeMediaElement(this.tag);
        this.tag = null;
      }

      this.techName = techName;

      // Turn off API access because we're loading a new tech that might load asynchronously
      this.isReady_ = false;

      var techReady = function techReady() {
        this.player_.triggerReady();
      };

      // Grab tech-specific options from player options and add source and parent element to use.
      var techOptions = Lib.obj.merge({ source: source, parentEl: this.el_ }, this.options_[techName.toLowerCase()]);

      if (source) {
        this.currentType_ = source.type;
        if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
          techOptions.startTime = this.cache_.currentTime;
        }

        this.cache_.src = source.src;
      }

      // Initialize tech instance
      var techComponent = _Component3['default'].getComponent(techName);
      this.tech = new techComponent(this, techOptions);

      this.tech.ready(techReady);
    }
  }, {
    key: 'unloadTech',
    value: function unloadTech() {
      this.isReady_ = false;

      this.tech.dispose();

      this.tech = false;
    }
  }, {
    key: 'onLoadStart',

    /**
     * Fired when the user agent begins looking for media data
     * @event loadstart
     */
    value: function onLoadStart() {
      // TODO: Update to use `emptied` event instead. See #1277.

      this.removeClass('vjs-ended');

      // reset the error state
      this.error(null);

      // If it's already playing we want to trigger a firstplay event now.
      // The firstplay event relies on both the play and loadstart events
      // which can happen in any order for a new source
      if (!this.paused()) {
        this.trigger('firstplay');
      } else {
        // reset the hasStarted state
        this.hasStarted(false);
      }
    }
  }, {
    key: 'hasStarted',
    value: (function (_hasStarted) {
      function hasStarted(_x) {
        return _hasStarted.apply(this, arguments);
      }

      hasStarted.toString = function () {
        return _hasStarted.toString();
      };

      return hasStarted;
    })(function (hasStarted) {
      if (hasStarted !== undefined) {
        // only update if this is a new value
        if (this.hasStarted_ !== hasStarted) {
          this.hasStarted_ = hasStarted;
          if (hasStarted) {
            this.addClass('vjs-has-started');
            // trigger the firstplay event if this newly has played
            this.trigger('firstplay');
          } else {
            this.removeClass('vjs-has-started');
          }
        }
        return this;
      }
      return !!this.hasStarted_;
    })
  }, {
    key: 'onPlay',

    /**
     * Fired whenever the media begins or resumes playback
     * @event play
     */
    value: function onPlay() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');

      // hide the poster when the user hits play
      // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
      this.hasStarted(true);
    }
  }, {
    key: 'onWaiting',

    /**
     * Fired whenever the media begins waiting
     * @event waiting
     */
    value: function onWaiting() {
      this.addClass('vjs-waiting');
    }
  }, {
    key: 'onWaitEnd',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @private
     */
    value: function onWaitEnd() {
      this.removeClass('vjs-waiting');
    }
  }, {
    key: 'onSeeking',

    /**
     * Fired whenever the player is jumping to a new time
     * @event seeking
     */
    value: function onSeeking() {
      this.addClass('vjs-seeking');
    }
  }, {
    key: 'onSeeked',

    /**
     * Fired when the player has finished jumping to a new time
     * @event seeked
     */
    value: function onSeeked() {
      this.removeClass('vjs-seeking');
    }
  }, {
    key: 'onFirstPlay',

    /**
     * Fired the first time a video is played
     *
     * Not part of the HLS spec, and we're not sure if this is the best
     * implementation yet, so use sparingly. If you don't have a reason to
     * prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event firstplay
     */
    value: function onFirstPlay() {
      //If the first starttime attribute is specified
      //then we will start at the given offset in seconds
      if (this.options_.starttime) {
        this.currentTime(this.options_.starttime);
      }

      this.addClass('vjs-has-started');
    }
  }, {
    key: 'onPause',

    /**
     * Fired whenever the media has been paused
     * @event pause
     */
    value: function onPause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
    }
  }, {
    key: 'onProgress',

    /**
     * Fired while the user agent is downloading media data
     * @event progress
     */
    value: function onProgress() {
      // Add custom event for when source is finished downloading.
      if (this.bufferedPercent() == 1) {
        this.trigger('loadedalldata');
      }
    }
  }, {
    key: 'onEnded',

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     * @event ended
     */
    value: function onEnded() {
      this.addClass('vjs-ended');
      if (this.options_.loop) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }
    }
  }, {
    key: 'onDurationChange',

    /**
     * Fired when the duration of the media resource is first known or changed
     * @event durationchange
     */
    value: function onDurationChange() {
      // Allows for caching value instead of asking player each time.
      // We need to get the techGet response and check for a value so we don't
      // accidentally cause the stack to blow up.
      var duration = this.techGet('duration');
      if (duration) {
        if (duration < 0) {
          duration = Infinity;
        }
        this.duration(duration);
        // Determine if the stream is live and propagate styles down to UI.
        if (duration === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
      }
    }
  }, {
    key: 'onFullscreenChange',

    /**
     * Fired when the player switches in or out of fullscreen mode
     * @event fullscreenchange
     */
    value: function onFullscreenChange() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    }
  }, {
    key: 'getCache',

    /**
     * Object for cached values.
     */
    value: function getCache() {
      return this.cache_;
    }
  }, {
    key: 'techCall',

    // Pass values to the playback tech
    value: function techCall(method, arg) {
      // If it's not ready yet, call method when it is
      if (this.tech && !this.tech.isReady_) {
        this.tech.ready(function () {
          this[method](arg);
        });

        // Otherwise call method now
      } else {
        try {
          this.tech[method](arg);
        } catch (e) {
          Lib.log(e);
          throw e;
        }
      }
    }
  }, {
    key: 'techGet',

    // Get calls can't wait for the tech, and sometimes don't need to.
    value: function techGet(method) {
      if (this.tech && this.tech.isReady_) {

        // Flash likes to die and reload when you hide or reposition it.
        // In these cases the object methods go away and we get errors.
        // When that happens we'll catch the errors and inform tech that it's not ready any more.
        try {
          return this.tech[method]();
        } catch (e) {
          // When building additional tech libs, an expected method may not be defined yet
          if (this.tech[method] === undefined) {
            Lib.log('Video.js: ' + method + ' method not defined for ' + this.techName + ' playback technology.', e);
          } else {
            // When a method isn't available on the object it throws a TypeError
            if (e.name == 'TypeError') {
              Lib.log('Video.js: ' + method + ' unavailable on ' + this.techName + ' playback technology element.', e);
              this.tech.isReady_ = false;
            } else {
              Lib.log(e);
            }
          }
          throw e;
        }
      }

      return;
    }
  }, {
    key: 'play',

    /**
     * start media playback
     *
     *     myPlayer.play();
     *
     * @return {Player} self
     */
    value: function play() {
      this.techCall('play');
      return this;
    }
  }, {
    key: 'pause',

    /**
     * Pause the video playback
     *
     *     myPlayer.pause();
     *
     * @return {Player} self
     */
    value: function pause() {
      this.techCall('pause');
      return this;
    }
  }, {
    key: 'paused',

    /**
     * Check if the player is paused
     *
     *     var isPaused = myPlayer.paused();
     *     var isPlaying = !myPlayer.paused();
     *
     * @return {Boolean} false if the media is currently playing, or true otherwise
     */
    value: function paused() {
      // The initial state of paused should be true (in Safari it's actually false)
      return this.techGet('paused') === false ? false : true;
    }
  }, {
    key: 'scrubbing',

    /**
    * Returns whether or not the user is "scrubbing". Scrubbing is when the user
    * has clicked the progress bar handle and is dragging it along the progress bar.
    * @param  {Boolean} isScrubbing   True/false the user is scrubbing
    * @return {Boolean}               The scrubbing status when getting
    * @return {Object}                The player when setting
    */
    value: function scrubbing(isScrubbing) {
      if (isScrubbing !== undefined) {
        this.scrubbing_ = !!isScrubbing;

        if (isScrubbing) {
          this.addClass('vjs-scrubbing');
        } else {
          this.removeClass('vjs-scrubbing');
        }

        return this;
      }

      return this.scrubbing_;
    }
  }, {
    key: 'currentTime',

    /**
     * Get or set the current time (in seconds)
     *
     *     // get
     *     var whereYouAt = myPlayer.currentTime();
     *
     *     // set
     *     myPlayer.currentTime(120); // 2 minutes into the video
     *
     * @param  {Number|String=} seconds The time to seek to
     * @return {Number}        The time in seconds, when not setting
     * @return {Player}    self, when the current time is set
     */
    value: function currentTime(seconds) {
      if (seconds !== undefined) {

        this.techCall('setCurrentTime', seconds);

        return this;
      }

      // cache last currentTime and return. default to 0 seconds
      //
      // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
      // currentTime when scrubbing, but may not provide much performance benefit afterall.
      // Should be tested. Also something has to read the actual current time or the cache will
      // never get updated.
      return this.cache_.currentTime = this.techGet('currentTime') || 0;
    }
  }, {
    key: 'duration',

    /**
     * Get the length in time of the video in seconds
     *
     *     var lengthOfVideo = myPlayer.duration();
     *
     * **NOTE**: The video must have started loading before the duration can be
     * known, and in the case of Flash, may not be known until the video starts
     * playing.
     *
     * @return {Number} The duration of the video in seconds
     */
    value: function duration(seconds) {
      if (seconds !== undefined) {

        // cache the last set value for optimized scrubbing (esp. Flash)
        this.cache_.duration = parseFloat(seconds);

        return this;
      }

      if (this.cache_.duration === undefined) {
        this.onDurationChange();
      }

      return this.cache_.duration || 0;
    }
  }, {
    key: 'remainingTime',

    /**
     * Calculates how much time is left.
     *
     *     var timeLeft = myPlayer.remainingTime();
     *
     * Not a native video element function, but useful
     * @return {Number} The time remaining in seconds
     */
    value: function remainingTime() {
      return this.duration() - this.currentTime();
    }
  }, {
    key: 'buffered',

    // http://dev.w3.org/html5/spec/video.html#dom-media-buffered
    // Buffered returns a timerange object.
    // Kind of like an array of portions of the video that have been downloaded.

    /**
     * Get a TimeRange object with the times of the video that have been downloaded
     *
     * If you just want the percent of the video that's been downloaded,
     * use bufferedPercent.
     *
     *     // Number of different ranges of time have been buffered. Usually 1.
     *     numberOfRanges = bufferedTimeRange.length,
     *
     *     // Time in seconds when the first range starts. Usually 0.
     *     firstRangeStart = bufferedTimeRange.start(0),
     *
     *     // Time in seconds when the first range ends
     *     firstRangeEnd = bufferedTimeRange.end(0),
     *
     *     // Length in seconds of the first time range
     *     firstRangeLength = firstRangeEnd - firstRangeStart;
     *
     * @return {Object} A mock TimeRange object (following HTML spec)
     */
    value: (function (_buffered) {
      function buffered() {
        return _buffered.apply(this, arguments);
      }

      buffered.toString = function () {
        return _buffered.toString();
      };

      return buffered;
    })(function () {
      var buffered = this.techGet('buffered');

      if (!buffered || !buffered.length) {
        buffered = Lib.createTimeRange(0, 0);
      }

      return buffered;
    })
  }, {
    key: 'bufferedPercent',

    /**
     * Get the percent (as a decimal) of the video that's been downloaded
     *
     *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
     *
     * 0 means none, 1 means all.
     * (This method isn't in the HTML5 spec, but it's very convenient)
     *
     * @return {Number} A decimal between 0 and 1 representing the percent
     */
    value: function bufferedPercent() {
      var duration = this.duration(),
          buffered = this.buffered(),
          bufferedDuration = 0,
          start,
          end;

      if (!duration) {
        return 0;
      }

      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);

        // buffered end can be bigger than duration by a very small fraction
        if (end > duration) {
          end = duration;
        }

        bufferedDuration += end - start;
      }

      return bufferedDuration / duration;
    }
  }, {
    key: 'bufferedEnd',

    /**
     * Get the ending time of the last buffered time range
     *
     * This is used in the progress bar to encapsulate all time ranges.
     * @return {Number} The end of the last buffered time range
     */
    value: function bufferedEnd() {
      var buffered = this.buffered(),
          duration = this.duration(),
          end = buffered.end(buffered.length - 1);

      if (end > duration) {
        end = duration;
      }

      return end;
    }
  }, {
    key: 'volume',

    /**
     * Get or set the current volume of the media
     *
     *     // get
     *     var howLoudIsIt = myPlayer.volume();
     *
     *     // set
     *     myPlayer.volume(0.5); // Set volume to half
     *
     * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
     *
     * @param  {Number} percentAsDecimal The new volume as a decimal percent
     * @return {Number}                  The current volume, when getting
     * @return {Player}              self, when setting
     */
    value: function volume(percentAsDecimal) {
      var vol = undefined;

      if (percentAsDecimal !== undefined) {
        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
        this.cache_.volume = vol;
        this.techCall('setVolume', vol);
        Lib.setLocalStorage('volume', vol);
        return this;
      }

      // Default to 1 when returning current volume.
      vol = parseFloat(this.techGet('volume'));
      return isNaN(vol) ? 1 : vol;
    }
  }, {
    key: 'muted',

    /**
     * Get the current muted state, or turn mute on or off
     *
     *     // get
     *     var isVolumeMuted = myPlayer.muted();
     *
     *     // set
     *     myPlayer.muted(true); // mute the volume
     *
     * @param  {Boolean=} muted True to mute, false to unmute
     * @return {Boolean} True if mute is on, false if not, when getting
     * @return {Player} self, when setting mute
     */
    value: (function (_muted) {
      function muted(_x2) {
        return _muted.apply(this, arguments);
      }

      muted.toString = function () {
        return _muted.toString();
      };

      return muted;
    })(function (muted) {
      if (muted !== undefined) {
        this.techCall('setMuted', muted);
        return this;
      }
      return this.techGet('muted') || false; // Default to false
    })
  }, {
    key: 'supportsFullScreen',

    // Check if current tech can support native fullscreen
    // (e.g. with built in controls like iOS, so not our flash swf)
    value: function supportsFullScreen() {
      return this.techGet('supportsFullScreen') || false;
    }
  }, {
    key: 'isFullscreen',

    /**
     * Check if the player is in fullscreen mode
     *
     *     // get
     *     var fullscreenOrNot = myPlayer.isFullscreen();
     *
     *     // set
     *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
     *
     * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
     * property and instead document.fullscreenElement is used. But isFullscreen is
     * still a valuable property for internal player workings.
     *
     * @param  {Boolean=} isFS Update the player's fullscreen state
     * @return {Boolean} true if fullscreen, false if not
     * @return {Player} self, when setting
     */
    value: function isFullscreen(isFS) {
      if (isFS !== undefined) {
        this.isFullscreen_ = !!isFS;
        return this;
      }
      return !!this.isFullscreen_;
    }
  }, {
    key: 'isFullScreen',

    /**
     * Old naming for isFullscreen()
     * @deprecated for lowercase 's' version
     */
    value: function isFullScreen(isFS) {
      Lib.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
      return this.isFullscreen(isFS);
    }
  }, {
    key: 'requestFullscreen',

    /**
     * Increase the size of the video to full screen
     *
     *     myPlayer.requestFullscreen();
     *
     * In some browsers, full screen is not supported natively, so it enters
     * "full window mode", where the video fills the browser window.
     * In browsers and devices that support native full screen, sometimes the
     * browser's default controls will be shown, and not the Video.js custom skin.
     * This includes most mobile devices (iOS, Android) and older versions of
     * Safari.
     *
     * @return {Player} self
     */
    value: function requestFullscreen() {
      var fsApi = _FullscreenApi2['default'];

      this.isFullscreen(true);

      if (fsApi) {
        // the browser supports going fullscreen at the element level so we can
        // take the controls fullscreen as well as the video

        // Trigger fullscreenchange event after change
        // We have to specifically add this each time, and remove
        // when canceling fullscreen. Otherwise if there's multiple
        // players on a page, they would all be reacting to the same fullscreen
        // events
        Events.on(_document2['default'], fsApi.fullscreenchange, Lib.bind(this, function documentFullscreenChange(e) {
          this.isFullscreen(_document2['default'][fsApi.fullscreenElement]);

          // If cancelling fullscreen, remove event listener.
          if (this.isFullscreen() === false) {
            Events.off(_document2['default'], fsApi.fullscreenchange, documentFullscreenChange);
          }

          this.trigger('fullscreenchange');
        }));

        this.el_[fsApi.requestFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        // we can't take the video.js controls fullscreen but we can go fullscreen
        // with native controls
        this.techCall('enterFullScreen');
      } else {
        // fullscreen isn't supported so we'll just stretch the video element to
        // fill the viewport
        this.enterFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'requestFullScreen',

    /**
     * Old naming for requestFullscreen
     * @deprecated for lower case 's' version
     */
    value: function requestFullScreen() {
      Lib.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
      return this.requestFullscreen();
    }
  }, {
    key: 'exitFullscreen',

    /**
     * Return the video to its normal size after having been in full screen mode
     *
     *     myPlayer.exitFullscreen();
     *
     * @return {Player} self
     */
    value: function exitFullscreen() {
      var fsApi = _FullscreenApi2['default'];
      this.isFullscreen(false);

      // Check for browser element fullscreen support
      if (fsApi) {
        _document2['default'][fsApi.exitFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        this.techCall('exitFullScreen');
      } else {
        this.exitFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'cancelFullScreen',

    /**
     * Old naming for exitFullscreen
     * @deprecated for exitFullscreen
     */
    value: function cancelFullScreen() {
      Lib.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
      return this.exitFullscreen();
    }
  }, {
    key: 'enterFullWindow',

    // When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
    value: function enterFullWindow() {
      this.isFullWindow = true;

      // Storing original doc overflow value to return to when fullscreen is off
      this.docOrigOverflow = _document2['default'].documentElement.style.overflow;

      // Add listener for esc key to exit fullscreen
      Events.on(_document2['default'], 'keydown', Lib.bind(this, this.fullWindowOnEscKey));

      // Hide any scroll bars
      _document2['default'].documentElement.style.overflow = 'hidden';

      // Apply fullscreen styles
      Lib.addClass(_document2['default'].body, 'vjs-full-window');

      this.trigger('enterFullWindow');
    }
  }, {
    key: 'fullWindowOnEscKey',
    value: function fullWindowOnEscKey(event) {
      if (event.keyCode === 27) {
        if (this.isFullscreen() === true) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  }, {
    key: 'exitFullWindow',
    value: function exitFullWindow() {
      this.isFullWindow = false;
      Events.off(_document2['default'], 'keydown', this.fullWindowOnEscKey);

      // Unhide scroll bars.
      _document2['default'].documentElement.style.overflow = this.docOrigOverflow;

      // Remove fullscreen styles
      Lib.removeClass(_document2['default'].body, 'vjs-full-window');

      // Resize the box, controller, and poster to original sizes
      // this.positionAll();
      this.trigger('exitFullWindow');
    }
  }, {
    key: 'selectSource',
    value: function selectSource(sources) {
      // Loop through each playback technology in the options order
      for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
        var techName = Lib.capitalize(j[i]);
        var tech = _Component3['default'].getComponent(techName);

        // Check if the current tech is defined before continuing
        if (!tech) {
          Lib.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          continue;
        }

        // Check if the browser supports this technology
        if (tech.isSupported()) {
          // Loop through each source object
          for (var a = 0, b = sources; a < b.length; a++) {
            var source = b[a];

            // Check if source can be played with this technology
            if (tech.canPlaySource(source)) {
              return { source: source, tech: techName };
            }
          }
        }
      }

      return false;
    }
  }, {
    key: 'src',

    /**
     * The source function updates the video source
     *
     * There are three types of variables you can pass as the argument.
     *
     * **URL String**: A URL to the the video file. Use this method if you are sure
     * the current playback technology (HTML5/Flash) can support the source you
     * provide. Currently only MP4 files can be used in both HTML5 and Flash.
     *
     *     myPlayer.src("http://www.example.com/path/to/video.mp4");
     *
     * **Source Object (or element):** A javascript object containing information
     * about the source file. Use this method if you want the player to determine if
     * it can support the file using the type information.
     *
     *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
     *
     * **Array of Source Objects:** To provide multiple versions of the source so
     * that it can be played using HTML5 across browsers you can use an array of
     * source objects. Video.js will detect which version is supported and load that
     * file.
     *
     *     myPlayer.src([
     *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
     *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
     *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
     *     ]);
     *
     * @param  {String|Object|Array=} source The source URL, object, or array of sources
     * @return {String} The current video source when getting
     * @return {String} The player when setting
     */
    value: function src() {
      var source = arguments[0] === undefined ? this.techGet('src') : arguments[0];

      var currentTech = _Component3['default'].getComponent(this.techName);

      // case: Array of source objects to choose from and pick the best to play
      if (Lib.obj.isArray(source)) {
        this.sourceList_(source);

        // case: URL String (http://myvideo...)
      } else if (typeof source === 'string') {
        // create a source object from the string
        this.src({ src: source });

        // case: Source object { src: '', type: '' ... }
      } else if (source instanceof Object) {
        // check if the source has a type and the loaded tech cannot play the source
        // if there's no type we'll just try the current tech
        if (source.type && !currentTech.canPlaySource(source)) {
          // create a source list with the current source and send through
          // the tech loop to check for a compatible technology
          this.sourceList_([source]);
        } else {
          this.cache_.src = source.src;
          this.currentType_ = source.type || '';

          // wait until the tech is ready to set the source
          this.ready(function () {

            // The setSource tech method was added with source handlers
            // so older techs won't support it
            // We need to check the direct prototype for the case where subclasses
            // of the tech do not support source handlers
            if (currentTech.prototype.hasOwnProperty('setSource')) {
              this.techCall('setSource', source);
            } else {
              this.techCall('src', source.src);
            }

            if (this.options_.preload == 'auto') {
              this.load();
            }

            if (this.options_.autoplay) {
              this.play();
            }
          });
        }
      }

      return this;
    }
  }, {
    key: 'sourceList_',

    /**
     * Handle an array of source objects
     * @param  {[type]} sources Array of source objects
     * @private
     */
    value: function sourceList_(sources) {
      var sourceTech = this.selectSource(sources);

      if (sourceTech) {
        if (sourceTech.tech === this.techName) {
          // if this technology is already loaded, set the source
          this.src(sourceTech.source);
        } else {
          // load this technology with the chosen source
          this.loadTech(sourceTech.tech, sourceTech.source);
        }
      } else {
        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        this.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options().notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        this.triggerReady();
      }
    }
  }, {
    key: 'load',

    /**
     * Begin loading the src data.
     * @return {Player} Returns the player
     */
    value: function load() {
      this.techCall('load');
      return this;
    }
  }, {
    key: 'currentSrc',

    /**
     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
     * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
     * @return {String} The current source
     */
    value: function currentSrc() {
      return this.techGet('currentSrc') || this.cache_.src || '';
    }
  }, {
    key: 'currentType',

    /**
     * Get the current source type e.g. video/mp4
     * This can allow you rebuild the current source object so that you could load the same
     * source and tech later
     * @return {String} The source MIME type
     */
    value: function currentType() {
      return this.currentType_ || '';
    }
  }, {
    key: 'preload',

    /**
     * Get or set the preload attribute.
     * @return {String} The preload attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function preload(value) {
      if (value !== undefined) {
        this.techCall('setPreload', value);
        this.options_.preload = value;
        return this;
      }
      return this.techGet('preload');
    }
  }, {
    key: 'autoplay',

    /**
     * Get or set the autoplay attribute.
     * @return {String} The autoplay attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function autoplay(value) {
      if (value !== undefined) {
        this.techCall('setAutoplay', value);
        this.options_.autoplay = value;
        return this;
      }
      return this.techGet('autoplay', value);
    }
  }, {
    key: 'loop',

    /**
     * Get or set the loop attribute on the video element.
     * @return {String} The loop attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function loop(value) {
      if (value !== undefined) {
        this.techCall('setLoop', value);
        this.options_.loop = value;
        return this;
      }
      return this.techGet('loop');
    }
  }, {
    key: 'poster',

    /**
     * get or set the poster image source url
     *
     * ##### EXAMPLE:
     *
     *     // getting
     *     var currentPoster = myPlayer.poster();
     *
     *     // setting
     *     myPlayer.poster('http://example.com/myImage.jpg');
     *
     * @param  {String=} [src] Poster image source URL
     * @return {String} poster URL when getting
     * @return {Player} self when setting
     */
    value: function poster(src) {
      if (src === undefined) {
        return this.poster_;
      }

      // The correct way to remove a poster is to set as an empty string
      // other falsey values will throw errors
      if (!src) {
        src = '';
      }

      // update the internal poster variable
      this.poster_ = src;

      // update the tech's poster
      this.techCall('setPoster', src);

      // alert components that the poster has been set
      this.trigger('posterchange');

      return this;
    }
  }, {
    key: 'controls',

    /**
     * Get or set whether or not the controls are showing.
     * @param  {Boolean} controls Set controls to showing or not
     * @return {Boolean}    Controls are showing
     */
    value: function controls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.controls_ !== bool) {
          this.controls_ = bool;
          if (bool) {
            this.removeClass('vjs-controls-disabled');
            this.addClass('vjs-controls-enabled');
            this.trigger('controlsenabled');
          } else {
            this.removeClass('vjs-controls-enabled');
            this.addClass('vjs-controls-disabled');
            this.trigger('controlsdisabled');
          }
        }
        return this;
      }
      return !!this.controls_;
    }
  }, {
    key: 'usingNativeControls',

    /**
     * Toggle native controls on/off. Native controls are the controls built into
     * devices (e.g. default iPhone controls), Flash, or other techs
     * (e.g. Vimeo Controls)
     *
     * **This should only be set by the current tech, because only the tech knows
     * if it can support native controls**
     *
     * @param  {Boolean} bool    True signals that native controls are on
     * @return {Player}      Returns the player
     * @private
     */
    value: function usingNativeControls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.usingNativeControls_ !== bool) {
          this.usingNativeControls_ = bool;
          if (bool) {
            this.addClass('vjs-using-native-controls');

            /**
             * player is using the native device controls
             *
             * @event usingnativecontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingnativecontrols');
          } else {
            this.removeClass('vjs-using-native-controls');

            /**
             * player is using the custom HTML controls
             *
             * @event usingcustomcontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingcustomcontrols');
          }
        }
        return this;
      }
      return !!this.usingNativeControls_;
    }
  }, {
    key: 'error',

    /**
     * Set or get the current MediaError
     * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
     * @return {MediaError|null}     when getting
     * @return {Player}              when setting
     */
    value: function error(err) {
      if (err === undefined) {
        return this.error_ || null;
      }

      // restoring to default
      if (err === null) {
        this.error_ = err;
        this.removeClass('vjs-error');
        return this;
      }

      // error instance
      if (err instanceof _MediaError2['default']) {
        this.error_ = err;
      } else {
        this.error_ = new _MediaError2['default'](err);
      }

      // fire an error event on the player
      this.trigger('error');

      // add the vjs-error classname to the player
      this.addClass('vjs-error');

      // log the name of the error type and any message
      // ie8 just logs "[object object]" if you just log the error object
      Lib.log.error('(CODE:' + this.error_.code + ' ' + _MediaError2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

      return this;
    }
  }, {
    key: 'ended',

    /**
     * Returns whether or not the player is in the "ended" state.
     * @return {Boolean} True if the player is in the ended state, false if not.
     */
    value: function ended() {
      return this.techGet('ended');
    }
  }, {
    key: 'seeking',

    /**
     * Returns whether or not the player is in the "seeking" state.
     * @return {Boolean} True if the player is in the seeking state, false if not.
     */
    value: function seeking() {
      return this.techGet('seeking');
    }
  }, {
    key: 'reportUserActivity',
    value: function reportUserActivity(event) {
      this.userActivity_ = true;
    }
  }, {
    key: 'userActive',
    value: function userActive(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (bool !== this.userActive_) {
          this.userActive_ = bool;
          if (bool) {
            // If the user was inactive and is now active we want to reset the
            // inactivity timer
            this.userActivity_ = true;
            this.removeClass('vjs-user-inactive');
            this.addClass('vjs-user-active');
            this.trigger('useractive');
          } else {
            // We're switching the state to inactive manually, so erase any other
            // activity
            this.userActivity_ = false;

            // Chrome/Safari/IE have bugs where when you change the cursor it can
            // trigger a mousemove event. This causes an issue when you're hiding
            // the cursor when the user is inactive, and a mousemove signals user
            // activity. Making it impossible to go into inactive mode. Specifically
            // this happens in fullscreen when we really need to hide the cursor.
            //
            // When this gets resolved in ALL browsers it can be removed
            // https://code.google.com/p/chromium/issues/detail?id=103041
            if (this.tech) {
              this.tech.one('mousemove', function (e) {
                e.stopPropagation();
                e.preventDefault();
              });
            }

            this.removeClass('vjs-user-active');
            this.addClass('vjs-user-inactive');
            this.trigger('userinactive');
          }
        }
        return this;
      }
      return this.userActive_;
    }
  }, {
    key: 'listenForUserActivity',
    value: function listenForUserActivity() {
      var mouseInProgress = undefined,
          lastMoveX = undefined,
          lastMoveY = undefined;

      var onActivity = Lib.bind(this, this.reportUserActivity);

      var onMouseMove = function onMouseMove(e) {
        // #1068 - Prevent mousemove spamming
        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
        if (e.screenX != lastMoveX || e.screenY != lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          onActivity();
        }
      };

      var onMouseDown = function onMouseDown() {
        onActivity();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(mouseInProgress);
        // Setting userActivity=true now and setting the interval to the same time
        // as the activityCheck interval (250) should ensure we never miss the
        // next activityCheck
        mouseInProgress = this.setInterval(onActivity, 250);
      };

      var onMouseUp = function onMouseUp(event) {
        onActivity();
        // Stop the interval that maintains activity if the mouse/touch is down
        this.clearInterval(mouseInProgress);
      };

      // Any mouse movement will be considered user activity
      this.on('mousedown', onMouseDown);
      this.on('mousemove', onMouseMove);
      this.on('mouseup', onMouseUp);

      // Listen for keyboard navigation
      // Shouldn't need to use inProgress interval because of key repeat
      this.on('keydown', onActivity);
      this.on('keyup', onActivity);

      // Run an interval every 250 milliseconds instead of stuffing everything into
      // the mousemove/touchmove function itself, to prevent performance degradation.
      // `this.reportUserActivity` simply sets this.userActivity_ to true, which
      // then gets picked up by this loop
      // http://ejohn.org/blog/learning-from-twitter/
      var activityCheck = this.setInterval(function () {
        var inactivityTimeout = undefined;

        // Check to see if mouse/touch activity has happened
        if (this.userActivity_) {
          // Reset the activity tracker
          this.userActivity_ = false;

          // If the user state was inactive, set the state to active
          this.userActive(true);

          // Clear any existing inactivity timeout to start the timer over
          this.clearTimeout(inactivityTimeout);

          var timeout = this.options().inactivityTimeout;
          if (timeout > 0) {
            // In <timeout> milliseconds, if no more activity has occurred the
            // user will be considered inactive
            inactivityTimeout = this.setTimeout(function () {
              // Protect against the case where the inactivityTimeout can trigger just
              // before the next user activity is picked up by the activityCheck loop
              // causing a flicker
              if (!this.userActivity_) {
                this.userActive(false);
              }
            }, timeout);
          }
        }
      }, 250);
    }
  }, {
    key: 'playbackRate',

    /**
     * Gets or sets the current playback rate.  A playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed
     * playback, for instance.
     * @param  {Number} rate    New playback rate to set.
     * @return {Number}         Returns the new playback rate when setting
     * @return {Number}         Returns the current playback rate when getting
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
     */
    value: function playbackRate(rate) {
      if (rate !== undefined) {
        this.techCall('setPlaybackRate', rate);
        return this;
      }

      if (this.tech && this.tech.featuresPlaybackRate) {
        return this.techGet('playbackRate');
      } else {
        return 1;
      }
    }
  }, {
    key: 'isAudio',

    /**
     * Gets or sets the audio flag
     *
     * @param  {Boolean} bool    True signals that this is an audio player.
     * @return {Boolean}         Returns true if player is audio, false if not when getting
     * @return {Player}      Returns the player if setting
     * @private
     */
    value: function isAudio(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return this;
      }

      return !!this.isAudio_;
    }
  }, {
    key: 'networkState',

    /**
     * Returns the current state of network activity for the element, from
     * the codes in the list below.
     * - NETWORK_EMPTY (numeric value 0)
     *   The element has not yet been initialised. All attributes are in
     *   their initial states.
     * - NETWORK_IDLE (numeric value 1)
     *   The element's resource selection algorithm is active and has
     *   selected a resource, but it is not actually using the network at
     *   this time.
     * - NETWORK_LOADING (numeric value 2)
     *   The user agent is actively trying to download data.
     * - NETWORK_NO_SOURCE (numeric value 3)
     *   The element's resource selection algorithm is active, but it has
     *   not yet found a resource to use.
     * @return {Number} the current network activity state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
     */
    value: function networkState() {
      return this.techGet('networkState');
    }
  }, {
    key: 'readyState',

    /**
     * Returns a value that expresses the current state of the element
     * with respect to rendering the current playback position, from the
     * codes in the list below.
     * - HAVE_NOTHING (numeric value 0)
     *   No information regarding the media resource is available.
     * - HAVE_METADATA (numeric value 1)
     *   Enough of the resource has been obtained that the duration of the
     *   resource is available.
     * - HAVE_CURRENT_DATA (numeric value 2)
     *   Data for the immediate current playback position is available.
     * - HAVE_FUTURE_DATA (numeric value 3)
     *   Data for the immediate current playback position is available, as
     *   well as enough data for the user agent to advance the current
     *   playback position in the direction of playback.
     * - HAVE_ENOUGH_DATA (numeric value 4)
     *   The user agent estimates that enough data is available for
     *   playback to proceed uninterrupted.
     * @return {Number} the current playback rendering state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
     */
    value: function readyState() {
      return this.techGet('readyState');
    }
  }, {
    key: 'textTracks',

    /**
     * Text tracks are tracks of timed text events.
     * Captions - text displayed over the video for the hearing impaired
     * Subtitles - text displayed over the video for those who don't understand language in the video
     * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
     * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
     */

    /**
     * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
     * @return {Array}           Array of track objects
     */
    value: function textTracks() {
      // cannot use techGet directly because it checks to see whether the tech is ready.
      // Flash is unlikely to be ready in time but textTracks should still work.
      return this.tech && this.tech.textTracks();
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      return this.tech && this.tech.remoteTextTracks();
    }
  }, {
    key: 'addTextTrack',

    /**
     * Add a text track
     * In addition to the W3C settings we allow adding additional info through options.
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
     * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
     * @param {String=} label       Optional label
     * @param {String=} language    Optional language
     */
    value: function addTextTrack(kind, label, language) {
      return this.tech && this.tech.addTextTrack(kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      return this.tech && this.tech.addRemoteTextTrack(options);
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.tech && this.tech.removeRemoteTextTrack(track);
    }
  }, {
    key: 'language',

    // Methods to add support for
    // initialTime: function(){ return this.techCall('initialTime'); },
    // startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
    // played: function(){ return this.techCall('played'); },
    // seekable: function(){ return this.techCall('seekable'); },
    // videoTracks: function(){ return this.techCall('videoTracks'); },
    // audioTracks: function(){ return this.techCall('audioTracks'); },
    // videoWidth: function(){ return this.techCall('videoWidth'); },
    // videoHeight: function(){ return this.techCall('videoHeight'); },
    // defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
    // mediaGroup: function(){ return this.techCall('mediaGroup'); },
    // controller: function(){ return this.techCall('controller'); },
    // defaultMuted: function(){ return this.techCall('defaultMuted'); }

    // TODO
    // currentSrcList: the array of sources including other formats and bitrates
    // playList: array of source lists in order of playback

    /**
     * The player's language code
     * @param  {String} languageCode  The locale string
     * @return {String}             The locale string when getting
     * @return {Player}         self, when setting
     */
    value: function language(languageCode) {
      if (languageCode === undefined) {
        return this.language_;
      }

      this.language_ = languageCode;
      return this;
    }
  }, {
    key: 'languages',

    /**
     * Get the player's language dictionary
     */
    value: function languages() {
      return this.languages_;
    }
  }], [{
    key: 'getTagSettings',
    value: function getTagSettings(tag) {
      var baseOptions = {
        sources: [],
        tracks: []
      };

      var tagOptions = Lib.getElementAttributes(tag);
      var dataSetup = tagOptions['data-setup'];

      // Check if data-setup attr exists.
      if (dataSetup !== null) {
        // Parse options JSON
        // If empty string, make it a parsable json object.
        Lib.obj.merge(tagOptions, _safeParseTuple2['default'](dataSetup || '{}')[1]);
      }

      Lib.obj.merge(baseOptions, tagOptions);

      // Get tag children settings
      if (tag.hasChildNodes()) {
        var children = tag.childNodes;

        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];
          // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
          var childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            baseOptions.sources.push(Lib.getElementAttributes(child));
          } else if (childName === 'track') {
            baseOptions.tracks.push(Lib.getElementAttributes(child));
          }
        }
      }

      return baseOptions;
    }
  }]);

  return Player;
})(_Component3['default']);

/**
 * Global player list
 * @type {Object}
 */
Player.players = {};

/**
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 * @private
 */
Player.prototype.options_ = _Options2['default'];

/**
 * Fired when the player has initial duration and dimension information
 * @event loadedmetadata
 */
Player.prototype.onLoadedMetaData;

/**
 * Fired when the player has downloaded data at the current playback position
 * @event loadeddata
 */
Player.prototype.onLoadedData;

/**
 * Fired when the player has finished downloading the source data
 * @event loadedalldata
 */
Player.prototype.onLoadedAllData;

/**
 * Fired when the user is active, e.g. moves the mouse over the player
 * @event useractive
 */
Player.prototype.onUserActive;

/**
 * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction
 * @event userinactive
 */
Player.prototype.onUserInactive;

/**
 * Fired when the current playback position has changed
 *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 * @event timeupdate
 */
Player.prototype.onTimeUpdate;

/**
 * Fired when the volume changes
 * @event volumechange
 */
Player.prototype.onVolumeChange;

/**
 * Fired when an error occurs
 * @event error
 */
Player.prototype.onError;

Player.prototype.flexNotSupported_ = function () {
  var elem = _document2['default'].createElement('i');

  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style);
};

_Component3['default'].registerComponent('Player', Player);
exports['default'] = Player;
module.exports = exports['default'];

},{"./big-play-button.js":5,"./component.js":7,"./control-bar/control-bar.js":8,"./error-display.js":41,"./events.js":43,"./fullscreen-api.js":45,"./lib.js":46,"./loading-spinner.js":47,"./media-error.js":48,"./options.js":52,"./poster-image.js":55,"./tech/html5.js":61,"./tech/loader.js":62,"./tracks/text-track-display.js":65,"./tracks/text-track-settings.js":68,"global/document":1,"global/window":2,"safe-json-parse/tuple":4}],54:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Player = _dereq_('./player');

var _Player2 = _interopRequireWildcard(_Player);

/**
 * the method for registering a video.js plugin
 *
 * @param  {String} name The name of the plugin
 * @param  {Function} init The function that is run when the player inits
 */
var plugin = function plugin(name, init) {
  _Player2['default'].prototype[name] = init;
};

exports['default'] = plugin;
module.exports = exports['default'];

},{"./player":53}],55:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Button2 = _dereq_('./button');

var _Button3 = _interopRequireWildcard(_Button2);

var _import = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import);

/* Poster Image
================================================================================ */
/**
 * The component that handles showing the poster image.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PosterImage = (function (_Button) {
  function PosterImage(player, options) {
    _classCallCheck(this, PosterImage);

    _get(Object.getPrototypeOf(PosterImage.prototype), 'constructor', this).call(this, player, options);

    this.update();
    player.on('posterchange', Lib.bind(this, this.update));
  }

  _inherits(PosterImage, _Button);

  _createClass(PosterImage, [{
    key: 'dispose',

    /**
     * Clean up the poster image
     */
    value: function dispose() {
      this.player().off('posterchange', this.update);
      _get(Object.getPrototypeOf(PosterImage.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',

    /**
     * Create the poster image element
     * @return {Element}
     */
    value: function createEl() {
      var el = Lib.createEl('div', {
        className: 'vjs-poster',

        // Don't want poster to be tabbable.
        tabIndex: -1
      });

      // To ensure the poster image resizes while maintaining its original aspect
      // ratio, use a div with `background-size` when available. For browsers that
      // do not support `background-size` (e.g. IE8), fall back on using a regular
      // img element.
      if (!Lib.BACKGROUND_SIZE_SUPPORTED) {
        this.fallbackImg_ = Lib.createEl('img');
        el.appendChild(this.fallbackImg_);
      }

      return el;
    }
  }, {
    key: 'update',

    /**
     * Event handler for updates to the player's poster source
     */
    value: function update() {
      var url = this.player().poster();

      this.setSrc(url);

      // If there's no poster source we should display:none on this component
      // so it's not still clickable or right-clickable
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'setSrc',

    /**
     * Set the poster source depending on the display method
     */
    value: function setSrc(url) {
      if (this.fallbackImg_) {
        this.fallbackImg_.src = url;
      } else {
        var backgroundImage = '';
        // Any falsey values should stay as an empty string, otherwise
        // this will throw an extra error
        if (url) {
          backgroundImage = 'url("' + url + '")';
        }

        this.el_.style.backgroundImage = backgroundImage;
      }
    }
  }, {
    key: 'onClick',

    /**
     * Event handler for clicks on the poster image
     */
    value: function onClick() {
      // We don't want a click to trigger playback when controls are disabled
      // but CSS should be hiding the poster to prevent that from happening
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }]);

  return PosterImage;
})(_Button3['default']);

_Button3['default'].registerComponent('PosterImage', PosterImage);
exports['default'] = PosterImage;
module.exports = exports['default'];

},{"./button":6,"./lib":46}],56:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./events');

var Events = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _windowLoaded = false;
var videojs = undefined;

/**
 * @fileoverview Functions for automatically setting up a player
 * based on the data-setup attribute of the video tag
 */

// Automatically set up any tags that have a data-setup attribute
var autoSetup = function autoSetup() {
  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
  // to build up a new, combined list of elements.
  var vids = _document2['default'].getElementsByTagName('video');
  var audios = _document2['default'].getElementsByTagName('audio');
  var mediaEls = [];
  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }
  if (audios && audios.length > 0) {
    for (var i = 0, e = audios.length; i < e; i++) {
      mediaEls.push(audios[i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            var player = videojs(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

// Pause to let the DOM keep processing
var autoSetupTimeout = function autoSetupTimeout(wait, vjs) {
  videojs = vjs;
  setTimeout(autoSetup, wait);
};

if (_document2['default'].readyState === 'complete') {
  _windowLoaded = true;
} else {
  Events.one(_window2['default'], 'load', function () {
    _windowLoaded = true;
  });
}

var hasLoaded = function hasLoaded() {
  return _windowLoaded;
};

exports.autoSetup = autoSetup;
exports.autoSetupTimeout = autoSetupTimeout;
exports.hasLoaded = hasLoaded;

},{"./events":43,"global/document":1,"global/window":2}],57:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

/**
 * SeekBar Behavior includes play progress bar, and seek handle
 * Needed so it can determine seek position based on handle position/size
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SliderHandle = (function (_Component) {
  function SliderHandle() {
    _classCallCheck(this, SliderHandle);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(SliderHandle, _Component);

  _createClass(SliderHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      props = props || {};
      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider-handle';
      props = Lib.obj.merge({
        innerHTML: '<span class="vjs-control-text">' + (this.defaultValue || 0) + '</span>'
      }, props);

      return _get(Object.getPrototypeOf(SliderHandle.prototype), 'createEl', this).call(this, 'div', props);
    }
  }]);

  return SliderHandle;
})(_Component3['default']);

_Component3['default'].registerComponent('SliderHandle', SliderHandle);
exports['default'] = SliderHandle;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46}],58:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component.js');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/* Slider
================================================================================ */
/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var Slider = (function (_Component) {
  function Slider(player, options) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, player, options);

    // Set property names to bar and handle to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_.barName);
    this.handle = this.getChild(this.options_.handleName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    this.vertical(!!this.options().vertical);

    this.on('mousedown', this.onMouseDown);
    this.on('touchstart', this.onMouseDown);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
    this.on('click', this.onClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);
  }

  _inherits(Slider, _Component);

  _createClass(Slider, [{
    key: 'createEl',
    value: function createEl(type) {
      var props = arguments[1] === undefined ? {} : arguments[1];

      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider';
      props = Lib.obj.merge({
        role: 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        tabIndex: 0
      }, props);

      return _get(Object.getPrototypeOf(Slider.prototype), 'createEl', this).call(this, type, props);
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(event) {
      event.preventDefault();
      Lib.blockTextSelection();
      this.addClass('vjs-sliding');

      this.on(_document2['default'], 'mousemove', this.onMouseMove);
      this.on(_document2['default'], 'mouseup', this.onMouseUp);
      this.on(_document2['default'], 'touchmove', this.onMouseMove);
      this.on(_document2['default'], 'touchend', this.onMouseUp);

      this.onMouseMove(event);
    }
  }, {
    key: 'onMouseMove',

    // To be overridden by a subclass
    value: function onMouseMove() {}
  }, {
    key: 'onMouseUp',
    value: function onMouseUp() {
      Lib.unblockTextSelection();
      this.removeClass('vjs-sliding');

      this.off(_document2['default'], 'mousemove', this.onMouseMove);
      this.off(_document2['default'], 'mouseup', this.onMouseUp);
      this.off(_document2['default'], 'touchmove', this.onMouseMove);
      this.off(_document2['default'], 'touchend', this.onMouseUp);

      this.update();
    }
  }, {
    key: 'update',
    value: function update() {
      // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
      // execution stack. The player is destroyed before then update will cause an error
      if (!this.el_) {
        return;
      } // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
      // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
      // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
      var progress = this.getPercent();
      var bar = this.bar;

      // If there's no bar...
      if (!bar) {
        return;
      } // Protect against no duration and other division issues
      if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
        progress = 0;
      }

      // If there is a handle, we need to account for the handle in our calculation for progress bar
      // so that it doesn't fall short of or extend past the handle.
      var barProgress = this.updateHandlePosition(progress);

      // Convert to a percentage for setting
      var percentage = Lib.round(barProgress * 100, 2) + '%';

      // Set the new bar width or height
      if (this.vertical()) {
        bar.el().style.height = percentage;
      } else {
        bar.el().style.width = percentage;
      }
    }
  }, {
    key: 'updateHandlePosition',

    /**
    * Update the handle position.
    */
    value: function updateHandlePosition(progress) {
      var handle = this.handle;
      if (!handle) {
        return;
      }var vertical = this.vertical();
      var box = this.el_;

      var boxSize = undefined,
          handleSize = undefined;
      if (vertical) {
        boxSize = box.offsetHeight;
        handleSize = handle.el().offsetHeight;
      } else {
        boxSize = box.offsetWidth;
        handleSize = handle.el().offsetWidth;
      }

      // The width of the handle in percent of the containing box
      // In IE, widths may not be ready yet causing NaN
      var handlePercent = handleSize ? handleSize / boxSize : 0;

      // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
      // There is a margin of half the handle's width on both sides.
      var boxAdjustedPercent = 1 - handlePercent;

      // Adjust the progress that we'll use to set widths to the new adjusted box width
      var adjustedProgress = progress * boxAdjustedPercent;

      // The bar does reach the left side, so we need to account for this in the bar's width
      var barProgress = adjustedProgress + handlePercent / 2;

      var percentage = Lib.round(adjustedProgress * 100, 2) + '%';

      if (vertical) {
        handle.el().style.bottom = percentage;
      } else {
        handle.el().style.left = percentage;
      }

      return barProgress;
    }
  }, {
    key: 'calculateDistance',
    value: function calculateDistance(event) {
      var el = this.el_;
      var box = Lib.findPosition(el);
      var boxW = el.offsetWidth;
      var boxH = el.offsetHeight;
      var handle = this.handle;

      if (this.options().vertical) {
        var boxY = box.top;

        var pageY = undefined;
        if (event.changedTouches) {
          pageY = event.changedTouches[0].pageY;
        } else {
          pageY = event.pageY;
        }

        if (handle) {
          var handleH = handle.el().offsetHeight;
          // Adjusted X and Width, so handle doesn't go outside the bar
          boxY = boxY + handleH / 2;
          boxH = boxH - handleH;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
      } else {
        var boxX = box.left;

        var pageX = undefined;
        if (event.changedTouches) {
          pageX = event.changedTouches[0].pageX;
        } else {
          pageX = event.pageX;
        }

        if (handle) {
          var handleW = handle.el().offsetWidth;

          // Adjusted X and Width, so handle doesn't go outside the bar
          boxX = boxX + handleW / 2;
          boxW = boxW - handleW;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
      }
    }
  }, {
    key: 'onFocus',
    value: function onFocus() {
      this.on(_document2['default'], 'keydown', this.onKeyPress);
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(event) {
      if (event.which == 37 || event.which == 40) {
        // Left and Down Arrows
        event.preventDefault();
        this.stepBack();
      } else if (event.which == 38 || event.which == 39) {
        // Up and Right Arrows
        event.preventDefault();
        this.stepForward();
      }
    }
  }, {
    key: 'onBlur',
    value: function onBlur() {
      this.off(_document2['default'], 'keydown', this.onKeyPress);
    }
  }, {
    key: 'onClick',

    /**
     * Listener for click events on slider, used to prevent clicks
     *   from bubbling up to parent elements like button menus.
     * @param  {Object} event Event object
     */
    value: function onClick(event) {
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }, {
    key: 'vertical',
    value: function vertical(bool) {
      if (bool === undefined) {
        return this.vertical_ || false;
      }

      this.vertical_ = !!bool;

      if (this.vertical_) {
        this.addClass('vjs-slider-vertical');
      } else {
        this.addClass('vjs-slider-horizontal');
      }

      return this;
    }
  }]);

  return Slider;
})(_Component3['default']);

_Component3['default'].registerComponent('Slider', Slider);
exports['default'] = Slider;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46,"global/document":1}],59:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function FlashRtmpDecorator(Flash) {
  Flash.streamingFormats = {
    'rtmp/mp4': 'MP4',
    'rtmp/flv': 'FLV'
  };

  Flash.streamFromParts = function (connection, stream) {
    return connection + '&' + stream;
  };

  Flash.streamToParts = function (src) {
    var parts = {
      connection: '',
      stream: ''
    };

    if (!src) return parts;

    // Look for the normal URL separator we expect, '&'.
    // If found, we split the URL into two pieces around the
    // first '&'.
    var connEnd = src.indexOf('&');
    var streamBegin = undefined;
    if (connEnd !== -1) {
      streamBegin = connEnd + 1;
    } else {
      // If there's not a '&', we use the last '/' as the delimiter.
      connEnd = streamBegin = src.lastIndexOf('/') + 1;
      if (connEnd === 0) {
        // really, there's not a '/'?
        connEnd = streamBegin = src.length;
      }
    }
    parts.connection = src.substring(0, connEnd);
    parts.stream = src.substring(streamBegin, src.length);

    return parts;
  };

  Flash.isStreamingType = function (srcType) {
    return srcType in Flash.streamingFormats;
  };

  // RTMP has four variations, any string starting
  // with one of these protocols should be valid
  Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

  Flash.isStreamingSrc = function (src) {
    return Flash.RTMP_RE.test(src);
  };

  /**
   * A source handler for RTMP urls
   * @type {Object}
   */
  Flash.rtmpSourceHandler = {};

  /**
   * Check Flash can handle the source natively
   * @param  {Object} source  The source object
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canHandleSource = function (source) {
    if (Flash.isStreamingType(source.type) || Flash.isStreamingSrc(source.src)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Pass the source to the flash object
   * Adaptive source handlers will have more complicated workflows before passing
   * video data to the video element
   * @param  {Object} source    The source object
   * @param  {Flash} tech   The instance of the Flash tech
   */
  Flash.rtmpSourceHandler.handleSource = function (source, tech) {
    var srcParts = Flash.streamToParts(source.src);

    tech.setRtmpConnection(srcParts.connection);
    tech.setRtmpStream(srcParts.stream);
  };

  // Register the native source handler
  Flash.registerSourceHandler(Flash.rtmpSourceHandler);

  return Flash;
}

exports['default'] = FlashRtmpDecorator;
module.exports = exports['default'];

},{}],60:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

var _Tech2 = _dereq_('./tech');

var _Tech3 = _interopRequireWildcard(_Tech2);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _FlashRtmpDecorator = _dereq_('./flash-rtmp');

var _FlashRtmpDecorator2 = _interopRequireWildcard(_FlashRtmpDecorator);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var navigator = _window2['default'].navigator;

/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {Player} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Flash = (function (_Tech) {
  function Flash(player, options, ready) {
    _classCallCheck(this, Flash);

    _get(Object.getPrototypeOf(Flash.prototype), 'constructor', this).call(this, player, options, ready);

    var source = options.source;
    var parentEl = options.parentEl;

    // Create a temporary element to be replaced by swf object
    var placeHolder = this.el_ = Lib.createEl('div', { id: player.id() + '_temp_flash' });

    // Generate ID for swf object
    var objId = player.id() + '_flash_api';

    // Store player options in local var for optimization
    // TODO: switch to using player methods instead of options
    // e.g. player.autoplay();
    var playerOptions = player.options_;

    // Merge default flashvars with ones passed in to init
    var flashVars = Lib.obj.merge({

      // SWF Callback Functions
      readyFunction: 'videojs.Flash.onReady',
      eventProxyFunction: 'videojs.Flash.onEvent',
      errorEventProxyFunction: 'videojs.Flash.onError',

      // Player Settings
      autoplay: playerOptions.autoplay,
      preload: playerOptions.preload,
      loop: playerOptions.loop,
      muted: playerOptions.muted

    }, options.flashVars);

    // Merge default parames with ones passed in
    var params = Lib.obj.merge({
      wmode: 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
      bgcolor: '#000000' // Using bgcolor prevents a white flash when the object is loading
    }, options.params);

    // Merge default attributes with ones passed in
    var attributes = Lib.obj.merge({
      id: objId,
      name: objId, // Both ID and Name needed or swf to identify itself
      'class': 'vjs-tech'
    }, options.attributes);

    // If source was supplied pass as a flash var.
    if (source) {
      this.ready(function () {
        this.setSource(source);
      });
    }

    // Add placeholder to player div
    Lib.insertFirst(placeHolder, parentEl);

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options.startTime) {
      this.ready(function () {
        this.load();
        this.play();
        this.currentTime(options.startTime);
      });
    }

    // firefox doesn't bubble mousemove events to parent. videojs/video-js-swf#37
    // bugzilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=836786
    if (Lib.IS_FIREFOX) {
      this.ready(function () {
        this.on('mousemove', function () {
          // since it's a custom event, don't bubble higher than the player
          this.player().trigger({ type: 'mousemove', bubbles: false });
        });
      });
    }

    // native click events on the SWF aren't triggered on IE11, Win8.1RT
    // use stageclick events triggered from inside the SWF instead
    player.on('stageclick', player.reportUserActivity);

    this.el_ = Flash.embed(options.swf, placeHolder, flashVars, params, attributes);
  }

  _inherits(Flash, _Tech);

  _createClass(Flash, [{
    key: 'play',
    value: function play() {
      this.el_.vjs_play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.vjs_pause();
    }
  }, {
    key: 'src',
    value: (function (_src) {
      function src(_x) {
        return _src.apply(this, arguments);
      }

      src.toString = function () {
        return _src.toString();
      };

      return src;
    })(function (src) {
      if (src === undefined) {
        return this.currentSrc();
      }

      // Setting src through `src` not `setSrc` will be deprecated
      return this.setSrc(src);
    })
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      // Make sure source URL is absolute.
      src = Lib.getAbsoluteURL(src);
      this.el_.vjs_src(src);

      // Currently the SWF doesn't autoplay if you load a source later.
      // e.g. Load player w/ no source, wait 2s, set src.
      if (this.player_.autoplay()) {
        var tech = this;
        this.setTimeout(function () {
          tech.play();
        }, 0);
      }
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(time) {
      this.lastSeekTarget_ = time;
      this.el_.vjs_setProperty('currentTime', time);
      _get(Object.getPrototypeOf(Flash.prototype), 'setCurrentTime', this).call(this);
    }
  }, {
    key: 'currentTime',
    value: function currentTime(time) {
      // when seeking make the reported time keep up with the requested time
      // by reading the time we're seeking to
      if (this.seeking()) {
        return this.lastSeekTarget_ || 0;
      }
      return this.el_.vjs_getProperty('currentTime');
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      } else {
        return this.el_.vjs_getProperty('currentSrc');
      }
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.vjs_load();
    }
  }, {
    key: 'poster',
    value: function poster() {
      this.el_.vjs_getProperty('poster');
    }
  }, {
    key: 'setPoster',

    // poster images are not handled by the Flash tech so make this a no-op
    value: function setPoster() {}
  }, {
    key: 'buffered',
    value: function buffered() {
      return Lib.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      return false; // Flash does not allow fullscreen through javascript
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      return false;
    }
  }]);

  return Flash;
})(_Tech3['default']);

// Create setters and getters for attributes
var _api = Flash.prototype;
var _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');
var _readOnly = 'error,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight'.split(',');

function _createSetter(attr) {
  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
  _api['set' + attrUpper] = function (val) {
    return this.el_.vjs_setProperty(attr, val);
  };
}
function _createGetter(attr) {
  _api[attr] = function () {
    return this.el_.vjs_getProperty(attr);
  };
}

// Create getter and setters for all read/write attributes
for (var i = 0; i < _readWrite.length; i++) {
  _createGetter(_readWrite[i]);
  _createSetter(_readWrite[i]);
}

// Create getters for read-only attributes
for (var i = 0; i < _readOnly.length; i++) {
  _createGetter(_readOnly[i]);
}

/* Flash Support Testing -------------------------------------------------------- */

Flash.isSupported = function () {
  return Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

// Add Source Handler pattern functions to this tech
_Tech3['default'].withSourceHandlers(Flash);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Flash} tech  The instance of the Flash tech
 */
Flash.nativeSourceHandler = {};

/**
 * Check Flash can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canHandleSource = function (source) {
  var type;

  function guessMimeType(src) {
    var ext = Lib.getFileExtension(src);
    if (ext) {
      return 'video/' + ext;
    }
    return '';
  }

  if (!source.type) {
    type = guessMimeType(source.src);
  } else {
    // Strip code information from the type because we don't get that specific
    type = source.type.replace(/;.*/, '').toLowerCase();
  }

  if (type in Flash.formats) {
    return 'maybe';
  }

  return '';
};

/**
 * Pass the source to the flash object
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Flash} tech   The instance of the Flash tech
 */
Flash.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Flash.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Flash.registerSourceHandler(Flash.nativeSourceHandler);

Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

Flash.onReady = function (currSwf) {
  var el = Lib.el(currSwf);

  // get player from the player div property
  var player = el && el.parentNode && el.parentNode.player;

  // if there is no el or player then the tech has been disposed
  // and the tech element was removed from the player div
  if (player) {
    // reference player on tech element
    el.player = player;
    // check that the flash object is really ready
    Flash.checkReady(player.tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
Flash.checkReady = function (tech) {
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    this.setTimeout(function () {
      Flash.checkReady(tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
Flash.onEvent = function (swfID, eventName) {
  var player = Lib.el(swfID).player;
  player.trigger(eventName);
};

// Log errors from the swf
Flash.onError = function (swfID, err) {
  var player = Lib.el(swfID).player;
  var msg = 'FLASH: ' + err;

  if (err == 'srcnotfound') {
    player.error({ code: 4, message: msg });

    // errors we haven't categorized into the media errors
  } else {
    player.error(msg);
  }
};

// Flash Version Check
Flash.version = function () {
  var version = '0,0,0';

  // IE
  try {
    version = new _window2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
Flash.embed = function (swf, placeHolder, flashVars, params, attributes) {
  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);

  // Get element by embedding code and retrieving created element
  var obj = Lib.createEl('div', { innerHTML: code }).childNodes[0];

  var par = placeHolder.parentNode;

  placeHolder.parentNode.replaceChild(obj, placeHolder);
  return obj;
};

Flash.getEmbedCode = function (swf, flashVars, params, attributes) {
  var objTag = '<object type="application/x-shockwave-flash" ';
  var flashVarsString = '';
  var paramsString = '';
  var attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    Lib.obj.each(flashVars, function (key, val) {
      flashVarsString += '' + key + '=' + val + '&amp;';
    });
  }

  // Add swf, flashVars, and other default params
  params = Lib.obj.merge({
    movie: swf,
    flashvars: flashVarsString,
    allowScriptAccess: 'always', // Required to talk to swf
    allowNetworking: 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  Lib.obj.each(params, function (key, val) {
    paramsString += '<param name="' + key + '" value="' + val + '" />';
  });

  attributes = Lib.obj.merge({
    // Add swf to attributes (need both for IE and Others to work)
    data: swf,

    // Default to 100% width/height
    width: '100%',
    height: '100%'

  }, attributes);

  // Create Attributes string
  Lib.obj.each(attributes, function (key, val) {
    attrsString += '' + key + '="' + val + '" ';
  });

  return '' + objTag + '' + attrsString + '>' + paramsString + '</object>';
};

// Run Flash through the RTMP decorator
_FlashRtmpDecorator2['default'](Flash);

_Tech3['default'].registerComponent('Flash', Flash);
exports['default'] = Flash;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"./flash-rtmp":59,"./tech":63,"global/window":2}],61:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
 */

var _Tech2 = _dereq_('./tech.js');

var _Tech3 = _interopRequireWildcard(_Tech2);

var _Component = _dereq_('../component');

var _Component2 = _interopRequireWildcard(_Component);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('../util');

var VjsUtil = _interopRequireWildcard(_import2);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 * @param {Player|Object} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Html5 = (function (_Tech) {
  function Html5(player, options, ready) {
    _classCallCheck(this, Html5);

    _get(Object.getPrototypeOf(Html5.prototype), 'constructor', this).call(this, player, options, ready);

    this.setupTriggers();

    var source = options.source;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src || player.tag && player.tag.initNetworkState_ === 3)) {
      this.setSource(source);
    }

    if (this.el_.hasChildNodes()) {

      var nodes = this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === 'track') {
          if (!this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            this.remoteTextTracks().addTrack_(node.track);
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        this.el_.removeChild(removeNodes[i]);
      }
    }

    if (this.featuresNativeTextTracks) {
      this.on('loadstart', Lib.bind(this, this.hideCaptions));
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if (Lib.TOUCH_ENABLED && player.options().nativeControlsForTouch === true) {
      this.useNativeControls();
    }

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    player.ready(function () {
      if (this.tag && this.options_.autoplay && this.paused()) {
        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.
        this.play();
      }
    });

    this.triggerReady();
  }

  _inherits(Html5, _Tech);

  _createClass(Html5, [{
    key: 'dispose',
    value: function dispose() {
      Html5.disposeMediaElement(this.el_);
      _get(Object.getPrototypeOf(Html5.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var player = this.player_;
      var el = player.tag;

      // Check if this browser supports moving the element into the box.
      // On the iPhone video will break if you move the element,
      // So we have to create a brand new element.
      if (!el || this.movingMediaElementInDOM === false) {

        // If the original tag is still there, clone and remove it.
        if (el) {
          var clone = el.cloneNode(false);
          Html5.disposeMediaElement(el);
          el = clone;
          player.tag = null;
        } else {
          el = Lib.createEl('video');

          // determine if native controls should be used
          var attributes = VjsUtil.mergeOptions({}, player.tagAttributes);
          if (!Lib.TOUCH_ENABLED || player.options().nativeControlsForTouch !== true) {
            delete attributes.controls;
          }

          Lib.setElementAttributes(el, Lib.obj.merge(attributes, {
            id: player.id() + '_html5_api',
            'class': 'vjs-tech'
          }));
        }
        // associate the player with the new tag
        el.player = player;

        if (player.options_.tracks) {
          for (var i = 0; i < player.options_.tracks.length; i++) {
            var track = player.options_.tracks[i];
            var trackEl = _document2['default'].createElement('track');
            trackEl.kind = track.kind;
            trackEl.label = track.label;
            trackEl.srclang = track.srclang;
            trackEl.src = track.src;
            if ('default' in track) {
              trackEl.setAttribute('default', 'default');
            }
            el.appendChild(trackEl);
          }
        }

        Lib.insertFirst(el, player.el());
      }

      // Update specific tag settings, in case they were overridden
      var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];
      for (var i = settingsAttrs.length - 1; i >= 0; i--) {
        var attr = settingsAttrs[i];
        var overwriteAttrs = {};
        if (typeof player.options_[attr] !== 'undefined') {
          overwriteAttrs[attr] = player.options_[attr];
        }
        Lib.setElementAttributes(el, overwriteAttrs);
      }

      return el;
      // jenniisawesome = true;
    }
  }, {
    key: 'hideCaptions',
    value: function hideCaptions() {
      var tracks = this.el_.querySelectorAll('track');
      var i = tracks.length;
      var kinds = {
        captions: 1,
        subtitles: 1
      };

      while (i--) {
        var track = tracks[i].track;
        if (track && track.kind in kinds && !tracks[i]['default']) {
          track.mode = 'disabled';
        }
      }
    }
  }, {
    key: 'setupTriggers',

    // Make video events trigger player events
    // May seem verbose here, but makes other APIs possible.
    // Triggers removed using this.off when disposed
    value: function setupTriggers() {
      for (var i = Html5.Events.length - 1; i >= 0; i--) {
        this.on(Html5.Events[i], this.eventHandler);
      }
    }
  }, {
    key: 'eventHandler',
    value: function eventHandler(evt) {
      // In the case of an error on the video element, set the error prop
      // on the player and let the player handle triggering the event. On
      // some platforms, error events fire that do not cause the error
      // property on the video element to be set. See #1465 for an example.
      if (evt.type == 'error' && this.error()) {
        this.player().error(this.error().code);

        // in some cases we pass the event directly to the player
      } else {
        // No need for media events to bubble up.
        evt.bubbles = false;

        this.player().trigger(evt);
      }
    }
  }, {
    key: 'useNativeControls',
    value: function useNativeControls() {
      var tech = this;
      var player = this.player();

      // If the player controls are enabled turn on the native controls
      tech.setControls(player.controls());

      // Update the native controls when player controls state is updated
      var controlsOn = function controlsOn() {
        tech.setControls(true);
      };
      var controlsOff = function controlsOff() {
        tech.setControls(false);
      };
      player.on('controlsenabled', controlsOn);
      player.on('controlsdisabled', controlsOff);

      // Clean up when not using native controls anymore
      var cleanUp = function cleanUp() {
        player.off('controlsenabled', controlsOn);
        player.off('controlsdisabled', controlsOff);
      };
      tech.on('dispose', cleanUp);
      player.on('usingcustomcontrols', cleanUp);

      // Update the state of the player to using native controls
      player.usingNativeControls(true);
    }
  }, {
    key: 'play',
    value: function play() {
      this.el_.play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.pause();
    }
  }, {
    key: 'paused',
    value: function paused() {
      return this.el_.paused;
    }
  }, {
    key: 'currentTime',
    value: function currentTime() {
      return this.el_.currentTime;
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(seconds) {
      try {
        this.el_.currentTime = seconds;
      } catch (e) {
        Lib.log(e, 'Video is not ready. (Video.js)');
        // this.warning(VideoJS.warnings.videoNotReady);
      }
    }
  }, {
    key: 'duration',
    value: function duration() {
      return this.el_.duration || 0;
    }
  }, {
    key: 'buffered',
    value: function buffered() {
      return this.el_.buffered;
    }
  }, {
    key: 'volume',
    value: function volume() {
      return this.el_.volume;
    }
  }, {
    key: 'setVolume',
    value: function setVolume(percentAsDecimal) {
      this.el_.volume = percentAsDecimal;
    }
  }, {
    key: 'muted',
    value: function muted() {
      return this.el_.muted;
    }
  }, {
    key: 'setMuted',
    value: function setMuted(muted) {
      this.el_.muted = muted;
    }
  }, {
    key: 'width',
    value: function width() {
      return this.el_.offsetWidth;
    }
  }, {
    key: 'height',
    value: function height() {
      return this.el_.offsetHeight;
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      if (typeof this.el_.webkitEnterFullScreen == 'function') {

        // Seems to be broken in Chromium/Chrome && Safari in Leopard
        if (/Android/.test(Lib.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(Lib.USER_AGENT)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      var video = this.el_;

      if ('webkitDisplayingFullscreen' in video) {
        this.one('webkitbeginfullscreen', function () {
          this.player_.isFullscreen(true);

          this.one('webkitendfullscreen', function () {
            this.player_.isFullscreen(false);
            this.player_.trigger('fullscreenchange');
          });

          this.player_.trigger('fullscreenchange');
        });
      }

      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        // attempt to prime the video element for programmatic access
        // this isn't necessary on the desktop but shouldn't hurt
        this.el_.play();

        // playing and pausing synchronously during the transition to fullscreen
        // can get iOS ~6.1 devices into a play/pause loop
        this.setTimeout(function () {
          video.pause();
          video.webkitEnterFullScreen();
        }, 0);
      } else {
        video.webkitEnterFullScreen();
      }
    }
  }, {
    key: 'exitFullScreen',
    value: function exitFullScreen() {
      this.el_.webkitExitFullScreen();
    }
  }, {
    key: 'src',
    value: (function (_src) {
      function src(_x) {
        return _src.apply(this, arguments);
      }

      src.toString = function () {
        return _src.toString();
      };

      return src;
    })(function (src) {
      if (src === undefined) {
        return this.el_.src;
      } else {
        // Setting src through `src` instead of `setSrc` will be deprecated
        this.setSrc(src);
      }
    })
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      this.el_.src = src;
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.load();
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      return this.el_.currentSrc;
    }
  }, {
    key: 'poster',
    value: function poster() {
      return this.el_.poster;
    }
  }, {
    key: 'setPoster',
    value: function setPoster(val) {
      this.el_.poster = val;
    }
  }, {
    key: 'preload',
    value: function preload() {
      return this.el_.preload;
    }
  }, {
    key: 'setPreload',
    value: function setPreload(val) {
      this.el_.preload = val;
    }
  }, {
    key: 'autoplay',
    value: function autoplay() {
      return this.el_.autoplay;
    }
  }, {
    key: 'setAutoplay',
    value: function setAutoplay(val) {
      this.el_.autoplay = val;
    }
  }, {
    key: 'controls',
    value: function controls() {
      return this.el_.controls;
    }
  }, {
    key: 'setControls',
    value: function setControls(val) {
      this.el_.controls = !!val;
    }
  }, {
    key: 'loop',
    value: function loop() {
      return this.el_.loop;
    }
  }, {
    key: 'setLoop',
    value: function setLoop(val) {
      this.el_.loop = val;
    }
  }, {
    key: 'error',
    value: function error() {
      return this.el_.error;
    }
  }, {
    key: 'seeking',
    value: function seeking() {
      return this.el_.seeking;
    }
  }, {
    key: 'ended',
    value: function ended() {
      return this.el_.ended;
    }
  }, {
    key: 'defaultMuted',
    value: function defaultMuted() {
      return this.el_.defaultMuted;
    }
  }, {
    key: 'playbackRate',
    value: function playbackRate() {
      return this.el_.playbackRate;
    }
  }, {
    key: 'setPlaybackRate',
    value: function setPlaybackRate(val) {
      this.el_.playbackRate = val;
    }
  }, {
    key: 'networkState',
    value: function networkState() {
      return this.el_.networkState;
    }
  }, {
    key: 'readyState',
    value: function readyState() {
      return this.el_.readyState;
    }
  }, {
    key: 'textTracks',
    value: function textTracks() {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'textTracks', this).call(this);
      }

      return this.el_.textTracks;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addTextTrack', this).call(this, kind, label, language);
      }

      return this.el_.addTextTrack(kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack() {
      var options = arguments[0] === undefined ? {} : arguments[0];

      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addRemoteTextTrack', this).call(this, options);
      }

      var track = _document2['default'].createElement('track');

      if (options.kind) {
        track.kind = options.kind;
      }
      if (options.label) {
        track.label = options.label;
      }
      if (options.language || options.srclang) {
        track.srclang = options.language || options.srclang;
      }
      if (options['default']) {
        track['default'] = options['default'];
      }
      if (options.id) {
        track.id = options.id;
      }
      if (options.src) {
        track.src = options.src;
      }

      this.el().appendChild(track);

      if (track.track.kind === 'metadata') {
        track.track.mode = 'hidden';
      } else {
        track.track.mode = 'disabled';
      }

      track.onload = function () {
        var tt = track.track;
        if (track.readyState >= 2) {
          if (tt.kind === 'metadata' && tt.mode !== 'hidden') {
            tt.mode = 'hidden';
          } else if (tt.kind !== 'metadata' && tt.mode !== 'disabled') {
            tt.mode = 'disabled';
          }
          track.onload = null;
        }
      };

      this.remoteTextTracks().addTrack_(track.track);

      return track;
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      if (!this.featuresNativeTextTracks) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'removeRemoteTextTrack', this).call(this, track);
      }

      var tracks, i;

      this.remoteTextTracks().removeTrack_(track);

      tracks = this.el().querySelectorAll('track');

      for (i = 0; i < tracks.length; i++) {
        if (tracks[i] === track || tracks[i].track === track) {
          tracks[i].parentNode.removeChild(tracks[i]);
          break;
        }
      }
    }
  }]);

  return Html5;
})(_Tech3['default']);

/* HTML5 Support Testing ---------------------------------------------------- */

/**
 * Check if HTML5 video is supported by this browser/device
 * @return {Boolean}
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Lib.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!Lib.TEST_VID.canPlayType;
};

// Add Source Handler pattern functions to this tech
_Tech3['default'].withSourceHandlers(Html5);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Html5} tech  The instance of the HTML5 tech
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the video element can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canHandleSource = function (source) {
  var match, ext;

  function canPlayType(type) {
    // IE9 on Windows 7 without MediaPlayer throws an error here
    // https://github.com/videojs/video.js/issues/519
    try {
      return Lib.TEST_VID.canPlayType(type);
    } catch (e) {
      return '';
    }
  }

  // If a type was provided we should rely on that
  if (source.type) {
    return canPlayType(source.type);
  } else if (source.src) {
    // If no type, fall back to checking 'video/[EXTENSION]'
    ext = Lib.getFileExtension(source.src);

    return canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the video element
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Html5} tech   The instance of the Html5 tech
 */
Html5.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 * @return {Boolean}
 */
Html5.canControlVolume = function () {
  var volume = Lib.TEST_VID.volume;
  Lib.TEST_VID.volume = volume / 2 + 0.1;
  return volume !== Lib.TEST_VID.volume;
};

/**
 * Check if playbackRate is supported in this browser/device.
 * @return {[type]} [description]
 */
Html5.canControlPlaybackRate = function () {
  var playbackRate = Lib.TEST_VID.playbackRate;
  Lib.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
  return playbackRate !== Lib.TEST_VID.playbackRate;
};

/**
 * Check to see if native text tracks are supported by this browser/device
 * @return {Boolean}
 */
Html5.supportsNativeTextTracks = function () {
  var supportsTextTracks;

  // Figure out native text track support
  // If mode is a number, we cannot change it because it'll disappear from view.
  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
  // Firefox isn't playing nice either with modifying the mode
  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
  supportsTextTracks = !!Lib.TEST_VID.textTracks;
  if (supportsTextTracks && Lib.TEST_VID.textTracks.length > 0) {
    supportsTextTracks = typeof Lib.TEST_VID.textTracks[0].mode !== 'number';
  }
  if (supportsTextTracks && Lib.IS_FIREFOX) {
    supportsTextTracks = false;
  }

  return supportsTextTracks;
};

/**
 * Set the tech's volume control support status
 * @type {Boolean}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Set the tech's playbackRate support status
 * @type {Boolean}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Set the tech's status on moving the video element.
 * In iOS, if you move a video element in the DOM, it breaks video playback.
 * @type {Boolean}
 */
Html5.prototype.movingMediaElementInDOM = !Lib.IS_IOS;

/**
 * Set the the tech's fullscreen resize support status.
 * HTML video is able to automatically resize when going to fullscreen.
 * (No longer appears to be used. Can probably be removed.)
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Set the tech's progress event support status
 * (this disables the manual progress events of the Tech)
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Sets the tech's status on native text track support
 * @type {Boolean}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = undefined;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {
  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (Lib.ANDROID_VERSION >= 4) {
    if (!canPlayType) {
      canPlayType = Lib.TEST_VID.constructor.prototype.canPlayType;
    }

    Lib.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }

  // Override Android 2.2 and less canPlayType method which is broken
  if (Lib.IS_OLD_ANDROID) {
    if (!canPlayType) {
      canPlayType = Lib.TEST_VID.constructor.prototype.canPlayType;
    }

    Lib.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Lib.TEST_VID.constructor.prototype.canPlayType;
  Lib.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  canPlayType = null;
  return r;
};

// by default, patch the video element
Html5.patchCanPlayType();

// List of all HTML5 events (various uses).
Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  el.player = null;

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {}
    })();
  }
};

_Component2['default'].registerComponent('Html5', Html5);
exports['default'] = Html5;
module.exports = exports['default'];

// not supported

},{"../component":7,"../lib":46,"../util":70,"./tech.js":63,"global/document":1}],62:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @constructor
 */

var MediaLoader = (function (_Component) {
  function MediaLoader(player, options, ready) {
    _classCallCheck(this, MediaLoader);

    _get(Object.getPrototypeOf(MediaLoader.prototype), 'constructor', this).call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.
    if (!player.options_.sources || player.options_.sources.length === 0) {
      for (var i = 0, j = player.options_.techOrder; i < j.length; i++) {
        var techName = Lib.capitalize(j[i]);
        var tech = _Component3['default'].getComponent(techName);

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(player.options_.sources);
    }
  }

  _inherits(MediaLoader, _Component);

  return MediaLoader;
})(_Component3['default']);

_Component3['default'].registerComponent('MediaLoader', MediaLoader);
exports['default'] = MediaLoader;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"global/window":2}],63:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @fileoverview Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _TextTrack = _dereq_('../tracks/text-track');

var _TextTrack2 = _interopRequireWildcard(_TextTrack);

var _TextTrackList = _dereq_('../tracks/text-track-list');

var _TextTrackList2 = _interopRequireWildcard(_TextTrackList);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/**
 * Base class for media (HTML5 Video, Flash) controllers
 * @param {Player|Object} player  Central player instance
 * @param {Object=} options Options object
 * @constructor
 */

var Tech = (function (_Component) {
  function Tech(player) {
    var options = arguments[1] === undefined ? {} : arguments[1];
    var ready = arguments[2] === undefined ? function () {} : arguments[2];

    _classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    _get(Object.getPrototypeOf(Tech.prototype), 'constructor', this).call(this, player, options, ready);

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this.featuresProgressEvents) {
      this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!this.featuresTimeupdateEvents) {
      this.manualTimeUpdatesOn();
    }

    this.initControlsListeners();

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      this.featuresNativeTextTracks = false;
    }

    if (!this.featuresNativeTextTracks) {
      this.emulateTextTracks();
    }

    this.initTextTrackListeners();
  }

  _inherits(Tech, _Component);

  _createClass(Tech, [{
    key: 'initControlsListeners',

    /**
     * Set up click and touch listeners for the playback element
     * On desktops, a click on the video itself will toggle playback,
     * on a mobile device a click on the video toggles controls.
     * (toggling controls is done by toggling the user state between active and
     * inactive)
     *
     * A tap can signal that a user has become active, or has become inactive
     * e.g. a quick tap on an iPhone movie should reveal the controls. Another
     * quick tap should hide them again (signaling the user is in an inactive
     * viewing state)
     *
     * In addition to this, we still want the user to be considered inactive after
     * a few seconds of inactivity.
     *
     * Note: the only part of iOS interaction we can't mimic with this setup
     * is a touch and hold on the video element counting as activity in order to
     * keep the controls showing, but that shouldn't be an issue. A touch and hold on
     * any controls will still keep the user active
     */
    value: function initControlsListeners() {
      var player = this.player();

      var activateControls = function activateControls() {
        if (player.controls() && !player.usingNativeControls()) {
          this.addControlsListeners();
        }
      };

      // Set up event listeners once the tech is ready and has an element to apply
      // listeners to
      this.ready(activateControls);
      this.on(player, 'controlsenabled', activateControls);
      this.on(player, 'controlsdisabled', this.removeControlsListeners);

      // if we're loading the playback object after it has started loading or playing the
      // video (often with autoplay on) then the loadstart event has already fired and we
      // need to fire it manually because many things rely on it.
      // Long term we might consider how we would do this for other events like 'canplay'
      // that may also have fired.
      this.ready(function () {
        if (this.networkState && this.networkState() > 0) {
          this.player().trigger('loadstart');
        }
      });
    }
  }, {
    key: 'addControlsListeners',
    value: function addControlsListeners() {
      var userWasActive = undefined;

      // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
      // trigger mousedown/up.
      // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
      // Any touch events are set to block the mousedown event from happening
      this.on('mousedown', this.onClick);

      // If the controls were hidden we don't want that to change without a tap event
      // so we'll check if the controls were already showing before reporting user
      // activity
      this.on('touchstart', function (event) {
        userWasActive = this.player_.userActive();
      });

      this.on('touchmove', function (event) {
        if (userWasActive) {
          this.player().reportUserActivity();
        }
      });

      this.on('touchend', function (event) {
        // Stop the mouse events from also happening
        event.preventDefault();
      });

      // Turn on component tap events
      this.emitTapEvents();

      // The tap listener needs to come after the touchend listener because the tap
      // listener cancels out any reportedUserActivity when setting userActive(false)
      this.on('tap', this.onTap);
    }
  }, {
    key: 'removeControlsListeners',

    /**
     * Remove the listeners used for click and tap controls. This is needed for
     * toggling to controls disabled, where a tap/touch should do nothing.
     */
    value: function removeControlsListeners() {
      // We don't want to just use `this.off()` because there might be other needed
      // listeners added by techs that extend this.
      this.off('tap');
      this.off('touchstart');
      this.off('touchmove');
      this.off('touchleave');
      this.off('touchcancel');
      this.off('touchend');
      this.off('click');
      this.off('mousedown');
    }
  }, {
    key: 'onClick',

    /**
     * Handle a click on the media element. By default will play/pause the media.
     */
    value: function onClick(event) {
      // We're using mousedown to detect clicks thanks to Flash, but mousedown
      // will also be triggered with right-clicks, so we need to prevent that
      if (event.button !== 0) {
        return;
      } // When controls are disabled a click should not toggle playback because
      // the click is considered a control
      if (this.player().controls()) {
        if (this.player().paused()) {
          this.player().play();
        } else {
          this.player().pause();
        }
      }
    }
  }, {
    key: 'onTap',

    /**
     * Handle a tap on the media element. By default it will toggle the user
     * activity state, which hides and shows the controls.
     */
    value: function onTap() {
      this.player().userActive(!this.player().userActive());
    }
  }, {
    key: 'manualProgressOn',

    /* Fallbacks for unsupported event types
    ================================================================================ */
    // Manually trigger progress events based on changes to the buffered amount
    // Many flash players and older HTML5 browsers don't send progress or progress-like events
    value: function manualProgressOn() {
      this.manualProgress = true;

      // Trigger progress watching when a source begins loading
      this.trackProgress();
    }
  }, {
    key: 'manualProgressOff',
    value: function manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();
    }
  }, {
    key: 'trackProgress',
    value: function trackProgress() {
      this.progressInterval = this.setInterval(function () {
        // Don't trigger unless buffered amount is greater than last time

        var bufferedPercent = this.player().bufferedPercent();

        if (this.bufferedPercent_ != bufferedPercent) {
          this.player().trigger('progress');
        }

        this.bufferedPercent_ = bufferedPercent;

        if (bufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }, 500);
    }
  }, {
    key: 'stopTrackingProgress',
    value: function stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }
  }, {
    key: 'manualTimeUpdatesOn',

    /*! Time Tracking -------------------------------------------------------------- */
    value: function manualTimeUpdatesOn() {
      var player = this.player_;

      this.manualTimeUpdates = true;

      this.on(player, 'play', this.trackCurrentTime);
      this.on(player, 'pause', this.stopTrackingCurrentTime);
      // timeupdate is also called by .currentTime whenever current time is set

      // Watch for native timeupdate event
      this.one('timeupdate', function () {
        // Update known progress support for this playback technology
        this.featuresTimeupdateEvents = true;
        // Turn off manual progress tracking
        this.manualTimeUpdatesOff();
      });
    }
  }, {
    key: 'manualTimeUpdatesOff',
    value: function manualTimeUpdatesOff() {
      var player = this.player_;

      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off(player, 'play', this.trackCurrentTime);
      this.off(player, 'pause', this.stopTrackingCurrentTime);
    }
  }, {
    key: 'trackCurrentTime',
    value: function trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function () {
        this.player().trigger('timeupdate');
      }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }
  }, {
    key: 'stopTrackingCurrentTime',

    // Turn off play progress tracking (when paused or dragging)
    value: function stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);

      // #1002 - if the video ends right before the next timeupdate would happen,
      // the progress bar won't make it all the way to the end
      this.player().trigger('timeupdate');
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Turn off any manual progress or timeupdate tracking
      if (this.manualProgress) {
        this.manualProgressOff();
      }

      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }

      _get(Object.getPrototypeOf(Tech.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime() {
      // improve the accuracy of manual timeupdates
      if (this.manualTimeUpdates) {
        this.player().trigger('timeupdate');
      }
    }
  }, {
    key: 'initTextTrackListeners',

    // TODO: Consider looking at moving this into the text track display directly
    // https://github.com/videojs/video.js/issues/1863
    value: function initTextTrackListeners() {
      var player = this.player_;

      var textTrackListChanges = function textTrackListChanges() {
        var textTrackDisplay = player.getChild('textTrackDisplay');

        if (textTrackDisplay) {
          textTrackDisplay.updateDisplay();
        }
      };

      var tracks = this.textTracks();

      if (!tracks) {
        return;
      }tracks.addEventListener('removetrack', textTrackListChanges);
      tracks.addEventListener('addtrack', textTrackListChanges);

      this.on('dispose', Lib.bind(this, function () {
        tracks.removeEventListener('removetrack', textTrackListChanges);
        tracks.removeEventListener('addtrack', textTrackListChanges);
      }));
    }
  }, {
    key: 'emulateTextTracks',
    value: function emulateTextTracks() {
      var player = this.player_;

      if (!_window2['default'].WebVTT) {
        var script = _document2['default'].createElement('script');
        script.src = player.options()['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
        player.el().appendChild(script);
        _window2['default'].WebVTT = true;
      }

      var tracks = this.textTracks();
      if (!tracks) {
        return;
      }

      var textTracksChanges = function textTracksChanges() {
        var textTrackDisplay = player.getChild('textTrackDisplay');

        textTrackDisplay.updateDisplay();

        for (var i = 0; i < this.length; i++) {
          var track = this[i];
          track.removeEventListener('cuechange', Lib.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
          if (track.mode === 'showing') {
            track.addEventListener('cuechange', Lib.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
          }
        }
      };

      tracks.addEventListener('change', textTracksChanges);

      this.on('dispose', Lib.bind(this, function () {
        tracks.removeEventListener('change', textTracksChanges);
      }));
    }
  }, {
    key: 'textTracks',

    /**
     * Provide default methods for text tracks.
     *
     * Html5 tech overrides these.
     */

    value: function textTracks() {
      this.player_.textTracks_ = this.player_.textTracks_ || new _TextTrackList2['default']();
      return this.player_.textTracks_;
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      this.player_.remoteTextTracks_ = this.player_.remoteTextTracks_ || new _TextTrackList2['default']();
      return this.player_.remoteTextTracks_;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error('TextTrack kind is required but was not provided');
      }

      return createTrackHelper(this, kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      var track = createTrackHelper(this, options.kind, options.label, options.language, options);
      this.remoteTextTracks().addTrack_(track);
      return {
        track: track
      };
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.textTracks().removeTrack_(track);
      this.remoteTextTracks().removeTrack_(track);
    }
  }, {
    key: 'setPoster',

    /**
     * Provide a default setPoster method for techs
     *
     * Poster support for techs should be optional, so we don't want techs to
     * break if they don't have a way to set a poster.
     */
    value: function setPoster() {}
  }]);

  return Tech;
})(_Component3['default']);

/**
 * List of associated text tracks
 * @type {Array}
 * @private
 */
Tech.prototype.textTracks_;

var createTrackHelper = function createTrackHelper(self, kind, label, language) {
  var options = arguments[4] === undefined ? {} : arguments[4];

  var tracks = self.textTracks();

  options.kind = kind;
  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.player = self.player_;

  var track = new _TextTrack2['default'](options);
  tracks.addTrack_(track);

  return track;
};

Tech.prototype.featuresVolumeControl = true;

// Resizing plugins using request fullscreen reloads the plugin
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresTimeupdateEvents = false;

Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 *
 * ##### EXAMPLE:
 *
 *   Tech.withSourceHandlers.call(MyTech);
 *
 */
Tech.withSourceHandlers = function (_Tech) {
  /**
   * Register a source handler
   * Source handlers are scripts for handling specific formats.
   * The source handler pattern is used for adaptive formats (HLS, DASH) that
   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
   * @param  {Function} handler  The source handler
   * @param  {Boolean}  first    Register it before any existing handlers
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Return the first source handler that supports the source
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   * @param  {Object} source The source object
   * @returns {Object}       The first source handler that supports the source
   * @returns {null}         Null if no source handler is found
   */
  _Tech.selectSourceHandler = function (source) {
    var handlers = _Tech.sourceHandlers || [];
    var can = undefined;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
  * Check if the tech can support the given source
  * @param  {Object} srcObj  The source object
  * @return {String}         'probably', 'maybe', or '' (empty string)
  */
  _Tech.canPlaySource = function (srcObj) {
    var sh = _Tech.selectSourceHandler(srcObj);

    if (sh) {
      return sh.canHandleSource(srcObj);
    }

    return '';
  };

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   * @param {Object} source  A source object with src and type keys
   * @return {Tech} self
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        Lib.log.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    this.currentSource_ = source;
    this.sourceHandler_ = sh.handleSource(source, this);
    this.on('dispose', this.disposeSourceHandler);

    return this;
  };

  /**
   * Clean up any existing source handler
   */
  _Tech.prototype.disposeSourceHandler = function () {
    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
      this.sourceHandler_.dispose();
    }
  };
};

_Component3['default'].registerComponent('Tech', Tech);
// Old name for Tech
_Component3['default'].registerComponent('MediaTechController', Tech);
exports['default'] = Tech;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"../tracks/text-track":69,"../tracks/text-track-list":67,"global/document":1,"global/window":2}],64:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
 *
 * interface TextTrackCueList {
 *   readonly attribute unsigned long length;
 *   getter TextTrackCue (unsigned long index);
 *   TextTrackCue? getCueById(DOMString id);
 * };
 */

var TextTrackCueList = (function (_TextTrackCueList) {
  function TextTrackCueList(_x) {
    return _TextTrackCueList.apply(this, arguments);
  }

  TextTrackCueList.toString = function () {
    return _TextTrackCueList.toString();
  };

  return TextTrackCueList;
})(function (cues) {
  var list = this;

  if (Lib.IS_IE8) {
    list = _document2['default'].createElement('custom');

    for (var prop in TextTrackCueList.prototype) {
      list[prop] = TextTrackCueList.prototype[prop];
    }
  }

  TextTrackCueList.prototype.setCues_.call(list, cues);

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.length_;
    }
  });

  if (Lib.IS_IE8) {
    return list;
  }
});

TextTrackCueList.prototype.setCues_ = function (cues) {
  var oldLength = this.length || 0;
  var i = 0;
  var l = cues.length;

  this.cues_ = cues;
  this.length_ = cues.length;

  var defineProp = function defineProp(i) {
    if (!('' + i in this)) {
      Object.defineProperty(this, '' + i, {
        get: function get() {
          return this.cues_[i];
        }
      });
    }
  };

  if (oldLength < l) {
    i = oldLength;

    for (; i < l; i++) {
      defineProp.call(this, i);
    }
  }
};

TextTrackCueList.prototype.getCueById = function (id) {
  var result = null;
  for (var i = 0, l = this.length; i < l; i++) {
    var cue = this[i];
    if (cue.id === id) {
      result = cue;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackCueList;
module.exports = exports['default'];

},{"../lib":46,"global/document":1}],65:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _Menu = _dereq_('../menu/menu.js');

var _Menu2 = _interopRequireWildcard(_Menu);

var _MenuItem = _dereq_('../menu/menu-item.js');

var _MenuItem2 = _interopRequireWildcard(_MenuItem);

var _MenuButton = _dereq_('../menu/menu-button.js');

var _MenuButton2 = _interopRequireWildcard(_MenuButton);

var _import = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * The component for displaying text track cues
 *
 * @constructor
 */

var TextTrackDisplay = (function (_Component) {
  function TextTrackDisplay(player, options, ready) {
    _classCallCheck(this, TextTrackDisplay);

    _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'constructor', this).call(this, player, options, ready);

    player.on('loadstart', Lib.bind(this, this.toggleDisplay));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(Lib.bind(this, function () {
      if (player.tech && player.tech.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', Lib.bind(this, this.updateDisplay));

      var tracks = player.options_.tracks || [];
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        this.player_.addRemoteTextTrack(track);
      }
    }));
  }

  _inherits(TextTrackDisplay, _Component);

  _createClass(TextTrackDisplay, [{
    key: 'toggleDisplay',
    value: function toggleDisplay() {
      if (this.player_.tech && this.player_.tech.featuresNativeTextTracks) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-text-track-display'
      });
    }
  }, {
    key: 'clearDisplay',
    value: function clearDisplay() {
      if (typeof _window2['default'].WebVTT === 'function') {
        _window2['default'].WebVTT.processCues(_window2['default'], [], this.el_);
      }
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var tracks = this.player_.textTracks();

      this.clearDisplay();

      if (!tracks) {
        return;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track.mode === 'showing') {
          this.updateForTrack(track);
        }
      }
    }
  }, {
    key: 'updateForTrack',
    value: function updateForTrack(track) {
      if (typeof _window2['default'].WebVTT !== 'function' || !track.activeCues) {
        return;
      }

      var overrides = this.player_.textTrackSettings.getValues();

      var cues = [];
      for (var _i = 0; _i < track.activeCues.length; _i++) {
        cues.push(track.activeCues[_i]);
      }

      _window2['default'].WebVTT.processCues(_window2['default'], track.activeCues, this.el_);

      var i = cues.length;
      while (i--) {
        var cueDiv = cues[i].displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === 'dropshadow') {
            cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
          } else if (overrides.edgeStyle === 'raised') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
          } else if (overrides.edgeStyle === 'depressed') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
          } else if (overrides.edgeStyle === 'uniform') {
            cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          var fontSize = _window2['default'].parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
          cueDiv.style.height = 'auto';
          cueDiv.style.top = 'auto';
          cueDiv.style.bottom = '2px';
        }
        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
          if (overrides.fontFamily === 'small-caps') {
            cueDiv.firstChild.style.fontVariant = 'small-caps';
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }
  }]);

  return TextTrackDisplay;
})(_Component3['default']);

// Add cue HTML to display
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

function tryUpdateStyle(el, style, rule) {
  // some style changes will throw an error, particularly in IE8. Those should be noops.
  try {
    el.style[style] = rule;
  } catch (e) {}
}

_Component3['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);
exports['default'] = TextTrackDisplay;
module.exports = exports['default'];

},{"../component":7,"../lib.js":46,"../menu/menu-button.js":49,"../menu/menu-item.js":50,"../menu/menu.js":51,"global/document":1,"global/window":2}],66:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 *
 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
 *
 * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

exports.TextTrackMode = TextTrackMode;
exports.TextTrackKind = TextTrackKind;

},{}],67:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _EventEmitter = _dereq_('../event-emitter');

var _EventEmitter2 = _interopRequireWildcard(_EventEmitter);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
 *
 * interface TextTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter TextTrack (unsigned long index);
 *   TextTrack? getTrackById(DOMString id);
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 */
var TextTrackList = (function (_TextTrackList) {
  function TextTrackList(_x) {
    return _TextTrackList.apply(this, arguments);
  }

  TextTrackList.toString = function () {
    return _TextTrackList.toString();
  };

  return TextTrackList;
})(function (tracks) {
  var list = this;

  if (Lib.IS_IE8) {
    list = _document2['default'].createElement('custom');

    for (var prop in TextTrackList.prototype) {
      list[prop] = TextTrackList.prototype[prop];
    }
  }

  tracks = tracks || [];
  list.tracks_ = [];

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.tracks_.length;
    }
  });

  for (var i = 0; i < tracks.length; i++) {
    list.addTrack_(tracks[i]);
  }

  if (Lib.IS_IE8) {
    return list;
  }
});

TextTrackList.prototype = Lib.obj.create(_EventEmitter2['default'].prototype);
TextTrackList.prototype.constructor = TextTrackList;

/*
 * change - One or more tracks in the track list have been enabled or disabled.
 * addtrack - A track has been added to the track list.
 * removetrack - A track has been removed from the track list.
*/
TextTrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var _event in TextTrackList.prototype.allowedEvents_) {
  TextTrackList.prototype['on' + _event] = null;
}

TextTrackList.prototype.addTrack_ = function (track) {
  var index = this.tracks_.length;
  if (!('' + index in this)) {
    Object.defineProperty(this, index, {
      get: function get() {
        return this.tracks_[index];
      }
    });
  }

  track.addEventListener('modechange', Lib.bind(this, function () {
    this.trigger('change');
  }));
  this.tracks_.push(track);

  this.trigger({
    type: 'addtrack',
    track: track
  });
};

TextTrackList.prototype.removeTrack_ = function (rtrack) {
  var result = null;
  var track = undefined;

  for (var i = 0, l = this.length; i < l; i++) {
    track = this[i];
    if (track === rtrack) {
      this.tracks_.splice(i, 1);
      break;
    }
  }

  this.trigger({
    type: 'removetrack',
    track: track
  });
};

TextTrackList.prototype.getTrackById = function (id) {
  var result = null;

  for (var i = 0, l = this.length; i < l; i++) {
    var track = this[i];
    if (track.id === id) {
      result = track;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackList;
module.exports = exports['default'];

},{"../event-emitter":42,"../lib":46,"global/document":1}],68:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Component2 = _dereq_('../component');

var _Component3 = _interopRequireWildcard(_Component2);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('../events');

var Events = _interopRequireWildcard(_import2);

var _safeParseTuple = _dereq_('safe-json-parse/tuple');

var _safeParseTuple2 = _interopRequireWildcard(_safeParseTuple);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var TextTrackSettings = (function (_Component) {
  function TextTrackSettings(player, options) {
    _classCallCheck(this, TextTrackSettings);

    _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'constructor', this).call(this, player, options);
    this.hide();

    Events.on(this.el().querySelector('.vjs-done-button'), 'click', Lib.bind(this, function () {
      this.saveSettings();
      this.hide();
    }));

    Events.on(this.el().querySelector('.vjs-default-button'), 'click', Lib.bind(this, function () {
      this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
      this.el().querySelector('.window-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
      this.updateDisplay();
    }));

    Events.on(this.el().querySelector('.vjs-fg-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.window-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-percent select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-edge-style select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-family select'), 'change', Lib.bind(this, this.updateDisplay));

    if (player.options().persistTextTrackSettings) {
      this.restoreSettings();
    }
  }

  _inherits(TextTrackSettings, _Component);

  _createClass(TextTrackSettings, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-caption-settings vjs-modal-overlay',
        innerHTML: captionOptionsMenuTemplate()
      });
    }
  }, {
    key: 'getValues',
    value: function getValues() {
      var el = this.el();

      var textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
      var fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
      var fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
      var textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
      var bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
      var bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
      var windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
      var windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
      var fontPercent = _window2['default'].parseFloat(getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

      var result = {
        backgroundOpacity: bgOpacity,
        textOpacity: textOpacity,
        windowOpacity: windowOpacity,
        edgeStyle: textEdge,
        fontFamily: fontFamily,
        color: fgColor,
        backgroundColor: bgColor,
        windowColor: windowColor,
        fontPercent: fontPercent
      };
      for (var _name in result) {
        if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1) {
          delete result[_name];
        }
      }
      return result;
    }
  }, {
    key: 'setValues',
    value: function setValues(values) {
      var el = this.el();

      setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
      setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
      setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
      setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
      setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
      setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
      setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
      setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

      var fontPercent = values.fontPercent;

      if (fontPercent) {
        fontPercent = fontPercent.toFixed(2);
      }

      setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
    }
  }, {
    key: 'restoreSettings',
    value: function restoreSettings() {
      var values = undefined;
      try {
        values = _safeParseTuple2['default'](_window2['default'].localStorage.getItem('vjs-text-track-settings'))[1];
      } catch (e) {}

      if (values) {
        this.setValues(values);
      }
    }
  }, {
    key: 'saveSettings',
    value: function saveSettings() {
      if (!this.player_.options().persistTextTrackSettings) {
        return;
      }

      var values = this.getValues();
      try {
        if (!Lib.isEmpty(values)) {
          _window2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
        } else {
          _window2['default'].localStorage.removeItem('vjs-text-track-settings');
        }
      } catch (e) {}
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var ttDisplay = this.player_.getChild('textTrackDisplay');
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }
  }]);

  return TextTrackSettings;
})(_Component3['default']);

_Component3['default'].registerComponent('TextTrackSettings', TextTrackSettings);

function getSelectedOptionValue(target) {
  var selectedOption = undefined;
  // not all browsers support selectedOptions, so, fallback to options
  if (target.selectedOptions) {
    selectedOption = target.selectedOptions[0];
  } else if (target.options) {
    selectedOption = target.options[target.options.selectedIndex];
  }

  return selectedOption.value;
}

function setSelectedOption(target, value) {
  if (!value) {
    return;
  }

  var i = undefined;
  for (i = 0; i < target.options.length; i++) {
    var option = target.options[i];
    if (option.value === value) {
      break;
    }
  }

  target.selectedIndex = i;
}

function captionOptionsMenuTemplate() {
  var template = '<div class="vjs-tracksettings">\n      <div class="vjs-tracksettings-colors">\n        <div class="vjs-fg-color vjs-tracksetting">\n            <label class="vjs-label">Foreground</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-text-opacity vjs-opacity">\n              <select>\n                <option value="">---</option>\n                <option value="1">Opaque</option>\n                <option value="0.5">Semi-Opaque</option>\n              </select>\n            </span>\n        </div> <!-- vjs-fg-color -->\n        <div class="vjs-bg-color vjs-tracksetting">\n            <label class="vjs-label">Background</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-bg-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-bg-color -->\n        <div class="window-color vjs-tracksetting">\n            <label class="vjs-label">Window</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-window-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-window-color -->\n      </div> <!-- vjs-tracksettings -->\n      <div class="vjs-tracksettings-font">\n        <div class="vjs-font-percent vjs-tracksetting">\n          <label class="vjs-label">Font Size</label>\n          <select>\n            <option value="0.50">50%</option>\n            <option value="0.75">75%</option>\n            <option value="1.00" selected>100%</option>\n            <option value="1.25">125%</option>\n            <option value="1.50">150%</option>\n            <option value="1.75">175%</option>\n            <option value="2.00">200%</option>\n            <option value="3.00">300%</option>\n            <option value="4.00">400%</option>\n          </select>\n        </div> <!-- vjs-font-percent -->\n        <div class="vjs-edge-style vjs-tracksetting">\n          <label class="vjs-label">Text Edge Style</label>\n          <select>\n            <option value="none">None</option>\n            <option value="raised">Raised</option>\n            <option value="depressed">Depressed</option>\n            <option value="uniform">Uniform</option>\n            <option value="dropshadow">Dropshadow</option>\n          </select>\n        </div> <!-- vjs-edge-style -->\n        <div class="vjs-font-family vjs-tracksetting">\n          <label class="vjs-label">Font Family</label>\n          <select>\n            <option value="">Default</option>\n            <option value="monospaceSerif">Monospace Serif</option>\n            <option value="proportionalSerif">Proportional Serif</option>\n            <option value="monospaceSansSerif">Monospace Sans-Serif</option>\n            <option value="proportionalSansSerif">Proportional Sans-Serif</option>\n            <option value="casual">Casual</option>\n            <option value="script">Script</option>\n            <option value="small-caps">Small Caps</option>\n          </select>\n        </div> <!-- vjs-font-family -->\n      </div>\n    </div>\n    <div class="vjs-tracksettings-controls">\n      <button class="vjs-default-button">Defaults</button>\n      <button class="vjs-done-button">Done</button>\n    </div>';

  return template;
}

exports['default'] = TextTrackSettings;
module.exports = exports['default'];

},{"../component":7,"../events":43,"../lib":46,"global/window":2,"safe-json-parse/tuple":4}],69:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _TextTrackCueList = _dereq_('./text-track-cue-list');

var _TextTrackCueList2 = _interopRequireWildcard(_TextTrackCueList);

var _import = _dereq_('../lib');

var Lib = _interopRequireWildcard(_import);

var _import2 = _dereq_('./text-track-enums');

var TextTrackEnum = _interopRequireWildcard(_import2);

var _EventEmitter = _dereq_('../event-emitter');

var _EventEmitter2 = _interopRequireWildcard(_EventEmitter);

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

var _XHR = _dereq_('../xhr.js');

var _XHR2 = _interopRequireWildcard(_XHR);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
 *
 * interface TextTrack : EventTarget {
 *   readonly attribute TextTrackKind kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
 *
 *   attribute TextTrackMode mode;
 *
 *   readonly attribute TextTrackCueList? cues;
 *   readonly attribute TextTrackCueList? activeCues;
 *
 *   void addCue(TextTrackCue cue);
 *   void removeCue(TextTrackCue cue);
 *
 *   attribute EventHandler oncuechange;
 * };
 */
var TextTrack = (function (_TextTrack) {
  function TextTrack() {
    return _TextTrack.apply(this, arguments);
  }

  TextTrack.toString = function () {
    return _TextTrack.toString();
  };

  return TextTrack;
})(function () {
  var options = arguments[0] === undefined ? {} : arguments[0];

  if (!options.player) {
    throw new Error('A player was not provided.');
  }

  var tt = this;
  if (Lib.IS_IE8) {
    tt = _document2['default'].createElement('custom');

    for (var prop in TextTrack.prototype) {
      tt[prop] = TextTrack.prototype[prop];
    }
  }

  tt.player_ = options.player;

  var mode = TextTrackEnum.TextTrackMode[options.mode] || 'disabled';
  var kind = TextTrackEnum.TextTrackKind[options.kind] || 'subtitles';
  var label = options.label || '';
  var language = options.language || options.srclang || '';
  var id = options.id || 'vjs_text_track_' + Lib.guid++;

  if (kind === 'metadata' || kind === 'chapters') {
    mode = 'hidden';
  }

  tt.cues_ = [];
  tt.activeCues_ = [];

  var cues = new _TextTrackCueList2['default'](tt.cues_);
  var activeCues = new _TextTrackCueList2['default'](tt.activeCues_);

  var changed = false;
  var timeupdateHandler = Lib.bind(tt, function () {
    this.activeCues;
    if (changed) {
      this.trigger('cuechange');
      changed = false;
    }
  });
  if (mode !== 'disabled') {
    tt.player_.on('timeupdate', timeupdateHandler);
  }

  Object.defineProperty(tt, 'kind', {
    get: function get() {
      return kind;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'label', {
    get: function get() {
      return label;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'language', {
    get: function get() {
      return language;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'id', {
    get: function get() {
      return id;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'mode', {
    get: function get() {
      return mode;
    },
    set: function set(newMode) {
      if (!TextTrackEnum.TextTrackMode[newMode]) {
        return;
      }
      mode = newMode;
      if (mode === 'showing') {
        this.player_.on('timeupdate', timeupdateHandler);
      }
      this.trigger('modechange');
    }
  });

  Object.defineProperty(tt, 'cues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      return cues;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'activeCues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      if (this.cues.length === 0) {
        return activeCues; // nothing to do
      }

      var ct = this.player_.currentTime();
      var active = [];

      for (var i = 0, l = this.cues.length; i < l; i++) {
        var cue = this.cues[i];
        if (cue.startTime <= ct && cue.endTime >= ct) {
          active.push(cue);
        } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
          active.push(cue);
        }
      }

      changed = false;

      if (active.length !== this.activeCues_.length) {
        changed = true;
      } else {
        for (var i = 0; i < active.length; i++) {
          if (indexOf.call(this.activeCues_, active[i]) === -1) {
            changed = true;
          }
        }
      }

      this.activeCues_ = active;
      activeCues.setCues_(this.activeCues_);

      return activeCues;
    },
    set: Function.prototype
  });

  if (options.src) {
    loadTrack(options.src, tt);
  } else {
    tt.loaded_ = true;
  }

  if (Lib.IS_IE8) {
    return tt;
  }
});

TextTrack.prototype = Lib.obj.create(_EventEmitter2['default'].prototype);
TextTrack.prototype.constructor = TextTrack;

/*
 * cuechange - One or more cues in the track have become active or stopped being active.
 */
TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

TextTrack.prototype.addCue = function (cue) {
  var tracks = this.player_.textTracks();

  if (tracks) {
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
  }

  this.cues_.push(cue);
  this.cues.setCues_(this.cues_);
};

TextTrack.prototype.removeCue = function (removeCue) {
  var removed = false;

  for (var i = 0, l = this.cues_.length; i < l; i++) {
    var cue = this.cues_[i];
    if (cue === removeCue) {
      this.cues_.splice(i, 1);
      removed = true;
    }
  }

  if (removed) {
    this.cues.setCues_(this.cues_);
  }
};

/*
 * Downloading stuff happens below this point
 */
var parseCues = (function (_parseCues) {
  function parseCues(_x, _x2) {
    return _parseCues.apply(this, arguments);
  }

  parseCues.toString = function () {
    return _parseCues.toString();
  };

  return parseCues;
})(function (srcContent, track) {
  if (typeof _window2['default'].WebVTT !== 'function') {
    //try again a bit later
    return _window2['default'].setTimeout(function () {
      parseCues(srcContent, track);
    }, 25);
  }

  var parser = new _window2['default'].WebVTT.Parser(_window2['default'], _window2['default'].vttjs, _window2['default'].WebVTT.StringDecoder());

  parser.oncue = function (cue) {
    track.addCue(cue);
  };
  parser.onparsingerror = function (error) {
    Lib.log.error(error);
  };

  parser.parse(srcContent);
  parser.flush();
});

var loadTrack = function loadTrack(src, track) {
  _XHR2['default'](src, Lib.bind(this, function (err, response, responseBody) {
    if (err) {
      return Lib.log.error(err);
    }

    track.loaded_ = true;
    parseCues(responseBody, track);
  }));
};

var indexOf = function indexOf(searchElement, fromIndex) {
  if (this == null) {
    throw new TypeError('"this" is null or not defined');
  }

  var O = Object(this);

  var len = O.length >>> 0;

  if (len === 0) {
    return -1;
  }

  var n = +fromIndex || 0;

  if (Math.abs(n) === Infinity) {
    n = 0;
  }

  if (n >= len) {
    return -1;
  }

  var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

  while (k < len) {
    if (k in O && O[k] === searchElement) {
      return k;
    }
    k++;
  }
  return -1;
};

exports['default'] = TextTrack;
module.exports = exports['default'];

},{"../event-emitter":42,"../lib":46,"../xhr.js":72,"./text-track-cue-list":64,"./text-track-enums":66,"global/document":1,"global/window":2}],70:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _obj = _dereq_('./lib');

/**
 * Utility functions namespace
 * @namespace
 * @type {Object}
 */
var util = {};

/**
 * Merge two options objects, recursively merging any plain object properties as
 * well.  Previously `deepMerge`
 *
 * @param  {Object} obj1 Object to override values in
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object -- obj1 and obj2 will be untouched
 */
var mergeOptions = (function (_mergeOptions) {
  function mergeOptions(_x, _x2) {
    return _mergeOptions.apply(this, arguments);
  }

  mergeOptions.toString = function () {
    return _mergeOptions.toString();
  };

  return mergeOptions;
})(function (obj1, obj2) {
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = _obj.obj.copy(obj1);

  for (key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (_obj.obj.isPlain(val1) && _obj.obj.isPlain(val2)) {
        obj1[key] = mergeOptions(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
});

exports.mergeOptions = mergeOptions;

},{"./lib":46}],71:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _document = _dereq_('global/document');

var _document2 = _interopRequireWildcard(_document);

var _MediaLoader = _dereq_('./tech/loader.js');

var _MediaLoader2 = _interopRequireWildcard(_MediaLoader);

var _Html5 = _dereq_('./tech/html5.js');

var _Html52 = _interopRequireWildcard(_Html5);

var _Flash = _dereq_('./tech/flash.js');

var _Flash2 = _interopRequireWildcard(_Flash);

var _PosterImage = _dereq_('./poster-image.js');

var _PosterImage2 = _interopRequireWildcard(_PosterImage);

var _TextTrackDisplay = _dereq_('./tracks/text-track-display.js');

var _TextTrackDisplay2 = _interopRequireWildcard(_TextTrackDisplay);

var _LoadingSpinner = _dereq_('./loading-spinner.js');

var _LoadingSpinner2 = _interopRequireWildcard(_LoadingSpinner);

var _BigPlayButton = _dereq_('./big-play-button.js');

var _BigPlayButton2 = _interopRequireWildcard(_BigPlayButton);

var _ControlBar = _dereq_('./control-bar/control-bar.js');

var _ControlBar2 = _interopRequireWildcard(_ControlBar);

var _ErrorDisplay = _dereq_('./error-display.js');

var _ErrorDisplay2 = _interopRequireWildcard(_ErrorDisplay);

var _videojs = _dereq_('./core');

var _videojs2 = _interopRequireWildcard(_videojs);

var _import = _dereq_('./setup');

var setup = _interopRequireWildcard(_import);

var _Component = _dereq_('./component');

var _Component2 = _interopRequireWildcard(_Component);

var _import2 = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import2);

var _import3 = _dereq_('./util.js');

var Util = _interopRequireWildcard(_import3);

var _Player = _dereq_('./player');

var _Player2 = _interopRequireWildcard(_Player);

var _extendsFn = _dereq_('./extends.js');

var _extendsFn2 = _interopRequireWildcard(_extendsFn);

if (typeof HTMLVideoElement === 'undefined') {
  _document2['default'].createElement('video');
  _document2['default'].createElement('audio');
  _document2['default'].createElement('track');
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
setup.autoSetupTimeout(1, _videojs2['default']);

_videojs2['default'].getComponent = _Component2['default'].getComponent;
_videojs2['default'].registerComponent = _Component2['default'].registerComponent;

// APIs that will be removed with 5.0, but need them to get tests passing
// in ES6 transition
_videojs2['default'].TOUCH_ENABLED = Lib.TOUCH_ENABLED;
_videojs2['default'].util = Util;

// Probably want to keep this one for 5.0?
_videojs2['default'].players = _Player2['default'].players;

_videojs2['default']['extends'] = _extendsFn2['default'];

// REMOVING: We probably should not include this in 5.0 thought it would make it
// more backwards compatible
// // Expose but deprecate the window[componentName] method for accessing components
// Lib.obj.each(Component.components, function(name, component){
//   // A deprecation warning as the constuctor
//   module.exports[name] = function(player, options, ready){
//     Lib.log.warn('Using videojs.'+name+' to access the '+name+' component has been deprecated. Please use videojs.getComponent("componentName")');
//
//     return new Component(player, options, ready);
//   };
//
//   // Allow the prototype and class methods to be accessible still this way
//   // Though anything that attempts to override class methods will no longer work
//   Lib.obj.merge(module.exports[name], component);
// });

exports['default'] = _videojs2['default'];
module.exports = exports['default'];

},{"./big-play-button.js":5,"./component":7,"./control-bar/control-bar.js":8,"./core":40,"./error-display.js":41,"./extends.js":44,"./lib":46,"./loading-spinner.js":47,"./player":53,"./poster-image.js":55,"./setup":56,"./tech/flash.js":60,"./tech/html5.js":61,"./tech/loader.js":62,"./tracks/text-track-display.js":65,"./util.js":70,"global/document":1}],72:[function(_dereq_,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _import = _dereq_('./util');

var VjsUtils = _interopRequireWildcard(_import);

var _import2 = _dereq_('./lib');

var Lib = _interopRequireWildcard(_import2);

var _window = _dereq_('global/window');

var _window2 = _interopRequireWildcard(_window);

/**
 * Simple http request for retrieving external files (e.g. text tracks)
 *
 * ##### Example
 *
 *     // using url string
 *     videojs.xhr('http://example.com/myfile.vtt', function(error, response, responseBody){});
 *
 *     // or options block
 *     videojs.xhr({
 *       uri: 'http://example.com/myfile.vtt',
 *       method: 'GET',
 *       responseType: 'text'
 *     }, function(error, response, responseBody){
 *       if (error) {
 *         // log the error
 *       } else {
 *         // successful, do something with the response
 *       }
 *     });
 *
 *
 * API is modeled after the Raynos/xhr, which we hope to use after
 * getting browserify implemented.
 * https://github.com/Raynos/xhr/blob/master/index.js
 *
 * @param  {Object|String}  options   Options block or URL string
 * @param  {Function}       callback  The callback function
 * @returns {Object}                  The request
 */
var xhr = function xhr(options, callback) {
  var abortTimeout = undefined;

  // If options is a string it's the url
  if (typeof options === 'string') {
    options = {
      uri: options
    };
  }

  // Merge with default options
  VjsUtils.mergeOptions({
    method: 'GET',
    timeout: 45 * 1000
  }, options);

  callback = callback || function () {};

  var XHR = _window2['default'].XMLHttpRequest;

  if (typeof XHR === 'undefined') {
    // Shim XMLHttpRequest for older IEs
    XHR = function () {
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e) {}
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (f) {}
      try {
        return new _window2['default'].ActiveXObject('Msxml2.XMLHTTP');
      } catch (g) {}
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  }

  var request = new XHR();
  // Store a reference to the url on the request instance
  request.uri = options.uri;

  var urlInfo = Lib.parseUrl(options.uri);
  var winLoc = _window2['default'].location;

  var successHandler = function successHandler() {
    _window2['default'].clearTimeout(abortTimeout);
    callback(null, request, request.response || request.responseText);
  };

  var errorHandler = function errorHandler(err) {
    _window2['default'].clearTimeout(abortTimeout);

    if (!err || typeof err === 'string') {
      err = new Error(err);
    }

    callback(err, request);
  };

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = urlInfo.protocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  // XDomainRequest -- Use for IE if XMLHTTPRequest2 isn't available
  // 'withCredentials' is only available in XMLHTTPRequest2
  // Also XDomainRequest has a lot of gotchas, so only use if cross domain
  if (crossOrigin && _window2['default'].XDomainRequest && !('withCredentials' in request)) {
    request = new _window2['default'].XDomainRequest();
    request.onload = successHandler;
    request.onerror = errorHandler;
    // These blank handlers need to be set to fix ie9
    // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/
    request.onprogress = function () {};
    request.ontimeout = function () {};

    // XMLHTTPRequest
  } else {
    (function () {
      var fileUrl = urlInfo.protocol == 'file:' || winLoc.protocol == 'file:';

      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.timedout) {
            return errorHandler('timeout');
          }

          if (request.status === 200 || fileUrl && request.status === 0) {
            successHandler();
          } else {
            errorHandler();
          }
        }
      };

      if (options.timeout) {
        abortTimeout = _window2['default'].setTimeout(function () {
          if (request.readyState !== 4) {
            request.timedout = true;
            request.abort();
          }
        }, options.timeout);
      }
    })();
  }

  // open the connection
  try {
    // Third arg is async, or ignored by XDomainRequest
    request.open(options.method || 'GET', options.uri, true);
  } catch (err) {
    return errorHandler(err);
  }

  // withCredentials only supported by XMLHttpRequest2
  if (options.withCredentials) {
    request.withCredentials = true;
  }

  if (options.responseType) {
    request.responseType = options.responseType;
  }

  // send the request
  try {
    request.send();
  } catch (err) {
    return errorHandler(err);
  }

  return request;
};

exports['default'] = xhr;
module.exports = exports['default'];

},{"./lib":46,"./util":70,"global/window":2}]},{},[71])(71)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtanNvbi1wYXJzZS90dXBsZS5qcyIsImJpZy1wbGF5LWJ1dHRvbi5qcyIsImJ1dHRvbi5qcyIsImNvbXBvbmVudC5qcyIsImNvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzIiwiY29udHJvbC1iYXIvZnVsbHNjcmVlbi10b2dnbGUuanMiLCJjb250cm9sLWJhci9saXZlLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci9tdXRlLXRvZ2dsZS5qcyIsImNvbnRyb2wtYmFyL3BsYXktdG9nZ2xlLmpzIiwiY29udHJvbC1iYXIvcGxheWJhY2stcmF0ZS1tZW51L3BsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanMiLCJjb250cm9sLWJhci9wbGF5YmFjay1yYXRlLW1lbnUvcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci9wcm9ncmVzcy1jb250cm9sL2xvYWQtcHJvZ3Jlc3MtYmFyLmpzIiwiY29udHJvbC1iYXIvcHJvZ3Jlc3MtY29udHJvbC9wbGF5LXByb2dyZXNzLWJhci5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvcHJvZ3Jlc3MtY29udHJvbC5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvc2Vlay1iYXIuanMiLCJjb250cm9sLWJhci9wcm9ncmVzcy1jb250cm9sL3NlZWstaGFuZGxlLmpzIiwiY29udHJvbC1iYXIvc3BhY2VyLWNvbnRyb2xzL2N1c3RvbS1jb250cm9sLXNwYWNlci5qcyIsImNvbnRyb2wtYmFyL3NwYWNlci1jb250cm9scy9zcGFjZXIuanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy9jYXB0aW9ucy1idXR0b24uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL2NoYXB0ZXJzLWJ1dHRvbi5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvY2hhcHRlcnMtdHJhY2stbWVudS1pdGVtLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy9vZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL3N1YnRpdGxlcy1idXR0b24uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL3RleHQtdHJhY2stYnV0dG9uLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcyIsImNvbnRyb2wtYmFyL3RpbWUtY29udHJvbHMvY3VycmVudC10aW1lLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL2R1cmF0aW9uLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL3JlbWFpbmluZy10aW1lLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL3RpbWUtZGl2aWRlci5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1iYXIuanMiLCJjb250cm9sLWJhci92b2x1bWUtY29udHJvbC92b2x1bWUtY29udHJvbC5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1oYW5kbGUuanMiLCJjb250cm9sLWJhci92b2x1bWUtY29udHJvbC92b2x1bWUtbGV2ZWwuanMiLCJjb250cm9sLWJhci92b2x1bWUtbWVudS1idXR0b24uanMiLCJjb3JlLW9iamVjdC5qcyIsImNvcmUuanMiLCJlcnJvci1kaXNwbGF5LmpzIiwiZXZlbnQtZW1pdHRlci5qcyIsImV2ZW50cy5qcyIsImV4dGVuZHMuanMiLCJmdWxsc2NyZWVuLWFwaS5qcyIsImxpYi5qcyIsImxvYWRpbmctc3Bpbm5lci5qcyIsIm1lZGlhLWVycm9yLmpzIiwibWVudS9tZW51LWJ1dHRvbi5qcyIsIm1lbnUvbWVudS1pdGVtLmpzIiwibWVudS9tZW51LmpzIiwib3B0aW9ucy5qcyIsInBsYXllci5qcyIsInBsdWdpbnMuanMiLCJwb3N0ZXItaW1hZ2UuanMiLCJzZXR1cC5qcyIsInNsaWRlci9zbGlkZXItaGFuZGxlLmpzIiwic2xpZGVyL3NsaWRlci5qcyIsInRlY2gvZmxhc2gtcnRtcC5qcyIsInRlY2gvZmxhc2guanMiLCJ0ZWNoL2h0bWw1LmpzIiwidGVjaC9sb2FkZXIuanMiLCJ0ZWNoL3RlY2guanMiLCJ0cmFja3MvdGV4dC10cmFjay1jdWUtbGlzdC5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWRpc3BsYXkuanMiLCJ0cmFja3MvdGV4dC10cmFjay1lbnVtcy5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWxpc3QuanMiLCJ0cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLmpzIiwidXRpbC5qcyIsInZpZGVvLmpzIiwieGhyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4RSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0RSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDhCQUE4QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUMxRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHlCQUF5QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNyRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0RSxVQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDdEIsQ0FBQyxDQUFDLENBQUM7O0FBRUosVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQzNHLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUMzRyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsd0JBQXdCLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDM0csVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQy9HLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUM3RyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsOEJBQThCLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDakgsVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQzdHLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUMzRyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMseUJBQXlCLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7O0FBRTVHLFFBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSx5QkFBNEIsRUFBRTtBQUNoRCxVQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7S0FDeEI7R0FDRjs7WUFyQ0csaUJBQWlCOztlQUFqQixpQkFBaUI7O1dBdUNiLG9CQUFHO0FBQ1Qsd0NBeENFLGlCQUFpQiwwQ0F3Q0csS0FBSyxFQUFFO0FBQzNCLGlCQUFTLEVBQUUsd0NBQXdDO0FBQ25ELGlCQUFTLEVBQUUsMEJBQTBCLEVBQUU7T0FDeEMsRUFBRTtLQUNKOzs7V0FFUSxxQkFBRztBQUNWLFVBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7QUFFckIsVUFBTSxRQUFRLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7QUFDcEYsVUFBTSxVQUFVLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7QUFDdkYsVUFBTSxPQUFPLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7QUFDbkYsVUFBTSxXQUFXLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUM7QUFDM0YsVUFBTSxPQUFPLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7QUFDbkYsVUFBTSxTQUFTLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7QUFDdkYsVUFBTSxXQUFXLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7QUFDdkYsVUFBTSxhQUFhLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUM7QUFDL0YsVUFBTSxXQUFXLEdBQUcsOEJBQW9CLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFakgsVUFBSSxNQUFNLEdBQUc7QUFDWCwyQkFBcUIsU0FBUztBQUM5QixxQkFBZSxXQUFXO0FBQzFCLHVCQUFpQixhQUFhO0FBQzlCLG1CQUFhLFFBQVE7QUFDckIsb0JBQWMsVUFBVTtBQUN4QixlQUFTLE9BQU87QUFDaEIseUJBQW1CLE9BQU87QUFDMUIscUJBQWUsV0FBVztBQUMxQixxQkFBZSxXQUFXO09BQzNCLENBQUM7QUFDRixXQUFLLElBQUksS0FBSSxJQUFJLE1BQU0sRUFBRTtBQUN2QixZQUFJLE1BQU0sQ0FBQyxLQUFJLENBQUMsS0FBSyxFQUFFLElBQUksTUFBTSxDQUFDLEtBQUksQ0FBQyxLQUFLLE1BQU0sSUFBSyxLQUFJLEtBQUssYUFBYSxJQUFJLE1BQU0sQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFJLEFBQUMsRUFBRTtBQUN2RyxpQkFBTyxNQUFNLENBQUMsS0FBSSxDQUFDLENBQUM7U0FDckI7T0FDRjtBQUNELGFBQU8sTUFBTSxDQUFDO0tBQ2Y7OztXQUVRLG1CQUFDLE1BQU0sRUFBRTtBQUNoQixVQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7O0FBRXJCLHVCQUFpQixDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsd0JBQXdCLENBQUMsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDaEYsdUJBQWlCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNsRix1QkFBaUIsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVFLHVCQUFpQixDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsNEJBQTRCLENBQUMsRUFBRSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDdEYsdUJBQWlCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN0Rix1QkFBaUIsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDMUYsdUJBQWlCLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNsRix1QkFBaUIsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLDhCQUE4QixDQUFDLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDOztBQUUxRixVQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDOztBQUVyQyxVQUFJLFdBQVcsRUFBRTtBQUNmLG1CQUFXLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUN0Qzs7QUFFRCx1QkFBaUIsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7S0FDaEY7OztXQUVjLDJCQUFHO0FBQ2hCLFVBQUksTUFBTSxZQUFBLENBQUM7QUFDWCxVQUFJO0FBQ0YsY0FBTSxHQUFHLDRCQUFlLG9CQUFPLFlBQVksQ0FBQyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ3BGLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTs7QUFFZCxVQUFJLE1BQU0sRUFBRTtBQUNWLFlBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDeEI7S0FDRjs7O1dBRVcsd0JBQUc7QUFDYixVQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUseUJBQTRCLEVBQUU7QUFDdkQsZUFBTztPQUNSOztBQUVELFVBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUM5QixVQUFJO0FBQ0YsWUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDeEIsOEJBQU8sWUFBWSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDaEYsTUFBTTtBQUNMLDhCQUFPLFlBQVksQ0FBQyxVQUFVLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUMzRDtPQUNGLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtLQUNmOzs7V0FFWSx5QkFBRztBQUNkLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDMUQsVUFBSSxTQUFTLEVBQUU7QUFDYixpQkFBUyxDQUFDLGFBQWEsRUFBRSxDQUFDO09BQzNCO0tBQ0Y7OztTQWxJRyxpQkFBaUI7OztBQXNJdkIsdUJBQVUsaUJBQWlCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FBQzs7QUFFcEUsU0FBUyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUU7QUFDdEMsTUFBSSxjQUFjLFlBQUEsQ0FBQzs7QUFFbkIsTUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFO0FBQzFCLGtCQUFjLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUM1QyxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUN6QixrQkFBYyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztHQUMvRDs7QUFFRCxTQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUM7Q0FDN0I7O0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQ3hDLE1BQUksQ0FBQyxLQUFLLEVBQUU7QUFDVixXQUFPO0dBQ1I7O0FBRUQsTUFBSSxDQUFDLFlBQUEsQ0FBQztBQUNOLE9BQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUMsUUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqQyxRQUFJLE1BQU0sQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFO0FBQzFCLFlBQU07S0FDUDtHQUNGOztBQUVELFFBQU0sQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0NBQzFCOztBQUVELFNBQVMsMEJBQTBCLEdBQUc7QUFDcEMsTUFBSSxRQUFRLGsvSkErR0gsQ0FBQzs7QUFFUixTQUFPLFFBQVEsQ0FBQztDQUNuQjs7cUJBRWMsaUJBQWlCOzs7Ozs7Ozs7Ozs7Z0NDL1JILHVCQUF1Qjs7OztzQkFDL0IsUUFBUTs7SUFBakIsR0FBRzs7dUJBQ2dCLG9CQUFvQjs7SUFBdkMsYUFBYTs7NEJBQ0Esa0JBQWtCOzs7O3dCQUN0QixpQkFBaUI7Ozs7c0JBQ25CLGVBQWU7Ozs7bUJBQ2xCLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0IzQixJQUFJLFNBQVM7Ozs7Ozs7Ozs7R0FBRyxZQUFxQjtNQUFaLE9BQU8sZ0NBQUMsRUFBRTs7QUFDakMsTUFBSSxDQUFDLE9BQU8sT0FBVSxFQUFFO0FBQ3RCLFVBQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztHQUMvQzs7QUFFRCxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDZCxNQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUU7QUFDZCxNQUFFLEdBQUcsc0JBQVMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUV0QyxTQUFLLElBQUksSUFBSSxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUU7QUFDcEMsUUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEM7R0FDRjs7QUFFRCxJQUFFLENBQUMsT0FBTyxHQUFHLE9BQU8sT0FBVSxDQUFDOztBQUUvQixNQUFJLElBQUksR0FBRyxhQUFhLENBQUMsYUFBYSxDQUFDLE9BQU8sS0FBUSxDQUFDLElBQUksVUFBVSxDQUFDO0FBQ3RFLE1BQUksSUFBSSxHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUMsT0FBTyxLQUFRLENBQUMsSUFBSSxXQUFXLENBQUM7QUFDdkUsTUFBSSxLQUFLLEdBQUcsT0FBTyxNQUFTLElBQUksRUFBRSxDQUFDO0FBQ25DLE1BQUksUUFBUSxHQUFHLE9BQU8sU0FBWSxJQUFJLE9BQU8sUUFBVyxJQUFJLEVBQUUsQ0FBQztBQUMvRCxNQUFJLEVBQUUsR0FBRyxPQUFPLEdBQU0sSUFBSSxpQkFBaUIsR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7O0FBRXpELE1BQUksSUFBSSxLQUFLLFVBQVUsSUFBSSxJQUFJLEtBQUssVUFBVSxFQUFFO0FBQzlDLFFBQUksR0FBRyxRQUFRLENBQUM7R0FDakI7O0FBRUQsSUFBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZCxJQUFFLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQzs7QUFFcEIsTUFBSSxJQUFJLEdBQUcsa0NBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQyxNQUFJLFVBQVUsR0FBRyxrQ0FBcUIsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUV0RCxNQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDcEIsTUFBSSxpQkFBaUIsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxZQUFXO0FBQzlDLFFBQUksV0FBYyxDQUFDO0FBQ25CLFFBQUksT0FBTyxFQUFFO0FBQ1gsVUFBSSxRQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDN0IsYUFBTyxHQUFHLEtBQUssQ0FBQztLQUNqQjtHQUNGLENBQUMsQ0FBQztBQUNILE1BQUksSUFBSSxLQUFLLFVBQVUsRUFBRTtBQUN2QixNQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztHQUNoRDs7QUFFRCxRQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUU7QUFDaEMsT0FBRyxFQUFFLGVBQVc7QUFDZCxhQUFPLElBQUksQ0FBQztLQUNiO0FBQ0QsT0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTO0dBQ3hCLENBQUMsQ0FBQzs7QUFFSCxRQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUU7QUFDakMsT0FBRyxFQUFFLGVBQVc7QUFDZCxhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsT0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTO0dBQ3hCLENBQUMsQ0FBQzs7QUFFSCxRQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxVQUFVLEVBQUU7QUFDcEMsT0FBRyxFQUFFLGVBQVc7QUFDZCxhQUFPLFFBQVEsQ0FBQztLQUNqQjtBQUNELE9BQUcsRUFBRSxRQUFRLENBQUMsU0FBUztHQUN4QixDQUFDLENBQUM7O0FBRUgsUUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQzlCLE9BQUcsRUFBRSxlQUFXO0FBQ2QsYUFBTyxFQUFFLENBQUM7S0FDWDtBQUNELE9BQUcsRUFBRSxRQUFRLENBQUMsU0FBUztHQUN4QixDQUFDLENBQUM7O0FBRUgsUUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFO0FBQ2hDLE9BQUcsRUFBRSxlQUFXO0FBQ2QsYUFBTyxJQUFJLENBQUM7S0FDYjtBQUNELE9BQUcsRUFBRSxhQUFTLE9BQU8sRUFBRTtBQUNyQixVQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUN6QyxlQUFPO09BQ1I7QUFDRCxVQUFJLEdBQUcsT0FBTyxDQUFDO0FBQ2YsVUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO0FBQ3RCLFlBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO09BQ2xEO0FBQ0QsVUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUM1QjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxRQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUU7QUFDaEMsT0FBRyxFQUFFLGVBQVc7QUFDZCxVQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNqQixlQUFPLElBQUksQ0FBQztPQUNiOztBQUVELGFBQU8sSUFBSSxDQUFDO0tBQ2I7QUFDRCxPQUFHLEVBQUUsUUFBUSxDQUFDLFNBQVM7R0FDeEIsQ0FBQyxDQUFDOztBQUVILFFBQU0sQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLFlBQVksRUFBRTtBQUN0QyxPQUFHLEVBQUUsZUFBVztBQUNkLFVBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ2pCLGVBQU8sSUFBSSxDQUFDO09BQ2I7O0FBRUQsVUFBSSxJQUFJLEtBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQzdCLGVBQU8sVUFBVSxDQUFDO09BQ25COztBQUVELFVBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDcEMsVUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDOztBQUVoQixXQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxLQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbkQsWUFBSSxHQUFHLEdBQUcsSUFBSSxLQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsWUFBSSxHQUFHLFVBQWEsSUFBSSxFQUFFLElBQUksR0FBRyxRQUFXLElBQUksRUFBRSxFQUFFO0FBQ2xELGdCQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2xCLE1BQU0sSUFBSSxHQUFHLFVBQWEsS0FBSyxHQUFHLFFBQVcsSUFBSSxHQUFHLFVBQWEsSUFBSSxFQUFFLElBQUksR0FBRyxVQUFhLEdBQUcsR0FBRyxJQUFJLEVBQUUsRUFBRTtBQUN4RyxnQkFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNsQjtPQUNGOztBQUVELGFBQU8sR0FBRyxLQUFLLENBQUM7O0FBRWhCLFVBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUM3QyxlQUFPLEdBQUcsSUFBSSxDQUFDO09BQ2hCLE1BQU07QUFDTCxhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxjQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNwRCxtQkFBTyxHQUFHLElBQUksQ0FBQztXQUNoQjtTQUNGO09BQ0Y7O0FBRUQsVUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUM7QUFDMUIsZ0JBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUV0QyxhQUFPLFVBQVUsQ0FBQztLQUNuQjtBQUNELE9BQUcsRUFBRSxRQUFRLENBQUMsU0FBUztHQUN4QixDQUFDLENBQUM7O0FBRUgsTUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsYUFBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDNUIsTUFBTTtBQUNMLE1BQUUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0dBQ25COztBQUVELE1BQUksR0FBRyxDQUFDLE1BQU0sRUFBRTtBQUNkLFdBQU8sRUFBRSxDQUFDO0dBQ1g7Q0FDRixDQUFBLENBQUM7O0FBRUYsU0FBUyxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQywwQkFBYSxTQUFTLENBQUMsQ0FBQztBQUM3RCxTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUM7Ozs7O0FBSzVDLFNBQVMsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHO0FBQ25DLGFBQWEsV0FBVztDQUN6QixDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsR0FBRyxFQUFFO0FBQ3pDLE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7O0FBRXZDLE1BQUksTUFBTSxFQUFFO0FBQ1YsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdEMsVUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQ3RCLGNBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDMUI7S0FDRjtHQUNGOztBQUVELE1BQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLE1BQUksS0FBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbkMsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLFNBQVMsRUFBRTtBQUNsRCxNQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7O0FBRXBCLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2pELFFBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEIsUUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO0FBQ3JCLFVBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN4QixhQUFPLEdBQUcsSUFBSSxDQUFDO0tBQ2hCO0dBQ0Y7O0FBRUQsTUFBSSxPQUFPLEVBQUU7QUFDWCxRQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDaEM7Q0FDRixDQUFDOzs7OztBQUtGLElBQUksU0FBUzs7Ozs7Ozs7OztHQUFHLFVBQVMsVUFBVSxFQUFFLEtBQUssRUFBRTtBQUMxQyxNQUFJLE9BQU8sMEJBQWdCLEtBQUssVUFBVSxFQUFFOztBQUUxQyxXQUFPLG9CQUFPLFVBQVUsQ0FBQyxZQUFXO0FBQ2xDLGVBQVMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDOUIsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNSOztBQUVELE1BQUksTUFBTSxHQUFHLElBQUksMEJBQWdCLE9BQVUsc0JBQVMseUJBQWUsRUFBRSwwQkFBZ0IsY0FBaUIsRUFBRSxDQUFDLENBQUM7O0FBRTFHLFFBQU0sTUFBUyxHQUFHLFVBQVMsR0FBRyxFQUFFO0FBQzlCLFNBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDbkIsQ0FBQztBQUNGLFFBQU0sZUFBa0IsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUN6QyxPQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUN0QixDQUFDOztBQUVGLFFBQU0sTUFBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzVCLFFBQU0sTUFBUyxFQUFFLENBQUM7Q0FDbkIsQ0FBQSxDQUFDOztBQUVGLElBQUksU0FBUyxHQUFHLG1CQUFTLEdBQUcsRUFBRSxLQUFLLEVBQUU7QUFDbkMsbUJBQUksR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVMsR0FBRyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUM7QUFDM0QsUUFBSSxHQUFHLEVBQUU7QUFDUCxhQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzNCOztBQUdELFNBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLGFBQVMsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDaEMsQ0FBQyxDQUFDLENBQUM7Q0FDTCxDQUFDOztBQUVGLElBQUksT0FBTyxHQUFHLGlCQUFTLGFBQWEsRUFBRSxTQUFTLEVBQUU7QUFDL0MsTUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQ2hCLFVBQU0sSUFBSSxTQUFTLENBQUMsK0JBQStCLENBQUMsQ0FBQztHQUN0RDs7QUFFRCxNQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXJCLE1BQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDOztBQUV6QixNQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7QUFDYixXQUFPLENBQUMsQ0FBQyxDQUFDO0dBQ1g7O0FBRUQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDOztBQUV4QixNQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO0FBQzVCLEtBQUMsR0FBRyxDQUFDLENBQUM7R0FDUDs7QUFFRCxNQUFJLENBQUMsSUFBSSxHQUFHLEVBQUU7QUFDWixXQUFPLENBQUMsQ0FBQyxDQUFDO0dBQ1g7O0FBRUQsTUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFcEQsU0FBTyxDQUFDLEdBQUcsR0FBRyxFQUFFO0FBQ2QsUUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxhQUFhLEVBQUU7QUFDcEMsYUFBTyxDQUFDLENBQUM7S0FDVjtBQUNELEtBQUMsRUFBRSxDQUFDO0dBQ0w7QUFDRCxTQUFPLENBQUMsQ0FBQyxDQUFDO0NBQ1gsQ0FBQzs7cUJBRWEsU0FBUzs7Ozs7Ozs7OzttQkNyU0osT0FBTzs7Ozs7OztBQU8zQixJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7Ozs7Ozs7Ozs7QUFVZCxJQUFJLFlBQVk7Ozs7Ozs7Ozs7R0FBRyxVQUFTLElBQUksRUFBRSxJQUFJLEVBQUM7QUFDckMsTUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQzs7OztBQUlwQixNQUFJLEdBQUcsS0F0QkEsR0FBRyxDQXNCQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXRCLE9BQUssR0FBRyxJQUFJLElBQUksRUFBQztBQUNmLFFBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUM1QixVQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLFVBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7OztBQUdqQixVQUFJLEtBOUJELEdBQUcsQ0E4QkUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBOUJ0QixHQUFHLENBOEJ1QixPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDMUMsWUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDdEMsTUFBTTtBQUNMLFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdkI7S0FDRjtHQUNGO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFBLENBQUM7O1FBRU8sWUFBWSxHQUFaLFlBQVk7Ozs7Ozs7Ozs7O3dCQ3hDQSxpQkFBaUI7Ozs7MkJBRWQsa0JBQWtCOzs7O3FCQUN4QixpQkFBaUI7Ozs7cUJBQ2pCLGlCQUFpQjs7OzsyQkFDWCxtQkFBbUI7Ozs7Z0NBQ2QsZ0NBQWdDOzs7OzhCQUNsQyxzQkFBc0I7Ozs7NkJBQ3ZCLHNCQUFzQjs7OzswQkFDekIsOEJBQThCOzs7OzRCQUM1QixvQkFBb0I7Ozs7dUJBRXpCLFFBQVE7Ozs7c0JBQ0wsU0FBUzs7SUFBcEIsS0FBSzs7eUJBQ0ssYUFBYTs7Ozt1QkFDZCxPQUFPOztJQUFoQixHQUFHOzt1QkFDTyxXQUFXOztJQUFyQixJQUFJOztzQkFDRyxVQUFVOzs7O3lCQUNQLGNBQWM7Ozs7QUFFcEMsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFdBQVcsRUFBRTtBQUMzQyx3QkFBUyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsd0JBQVMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ2hDLHdCQUFTLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUNqQzs7OztBQUlELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLHVCQUFVLENBQUM7O0FBRW5DLHFCQUFRLFlBQVksR0FBRyx1QkFBVSxZQUFZLENBQUM7QUFDOUMscUJBQVEsaUJBQWlCLEdBQUcsdUJBQVUsaUJBQWlCLENBQUM7Ozs7QUFJeEQscUJBQVEsYUFBYSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUM7QUFDMUMscUJBQVEsSUFBSSxHQUFHLElBQUksQ0FBQzs7O0FBR3BCLHFCQUFRLE9BQU8sR0FBRyxvQkFBTyxPQUFPLENBQUM7O0FBRWpDLCtCQUFlLHlCQUFZLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkN6Q0YsUUFBUTs7SUFBdEIsUUFBUTs7dUJBQ0MsT0FBTzs7SUFBaEIsR0FBRzs7c0JBQ0ksZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDbEMsSUFBSSxHQUFHLEdBQUcsYUFBUyxPQUFPLEVBQUUsUUFBUSxFQUFDO0FBQ25DLE1BQUksWUFBWSxZQUFBLENBQUM7OztBQUdqQixNQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtBQUMvQixXQUFPLEdBQUc7QUFDUixTQUFHLEVBQUUsT0FBTztLQUNiLENBQUM7R0FDSDs7O0FBR0QsVUFBUSxDQUFDLFlBQVksQ0FBQztBQUNwQixVQUFNLEVBQUUsS0FBSztBQUNiLFdBQU8sRUFBRSxFQUFFLEdBQUcsSUFBSTtHQUNuQixFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUVaLFVBQVEsR0FBRyxRQUFRLElBQUksWUFBVSxFQUFFLENBQUM7O0FBRXBDLE1BQUksR0FBRyxHQUFHLG9CQUFPLGNBQWMsQ0FBQzs7QUFFaEMsTUFBSSxPQUFPLEdBQUcsS0FBSyxXQUFXLEVBQUU7O0FBRTlCLE9BQUcsR0FBRyxZQUFZO0FBQ2hCLFVBQUk7QUFBRSxlQUFPLElBQUksb0JBQU8sYUFBYSxDQUFDLG9CQUFvQixDQUFDLENBQUM7T0FBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUU7QUFDM0UsVUFBSTtBQUFFLGVBQU8sSUFBSSxvQkFBTyxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQztPQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtBQUMzRSxVQUFJO0FBQUUsZUFBTyxJQUFJLG9CQUFPLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO09BQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFO0FBQ3ZFLFlBQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztLQUNsRSxDQUFDO0dBQ0g7O0FBRUQsTUFBSSxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7QUFFeEIsU0FBTyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDOztBQUUxQixNQUFJLE9BQU8sR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QyxNQUFJLE1BQU0sR0FBRyxvQkFBTyxRQUFRLENBQUM7O0FBRTdCLE1BQUksY0FBYyxHQUFHLDBCQUFVO0FBQzdCLHdCQUFPLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNsQyxZQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxJQUFJLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztHQUNuRSxDQUFDOztBQUVGLE1BQUksWUFBWSxHQUFHLHNCQUFTLEdBQUcsRUFBQztBQUM5Qix3QkFBTyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7O0FBRWxDLFFBQUksQ0FBQyxHQUFHLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO0FBQ25DLFNBQUcsR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN0Qjs7QUFFRCxZQUFRLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQ3hCLENBQUM7Ozs7QUFJRixNQUFNLFdBQVcsR0FBRyxBQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLElBQUksS0FBTyxNQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEFBQUMsQ0FBQzs7Ozs7QUFLMUYsTUFBSSxXQUFXLElBQUksb0JBQU8sY0FBYyxJQUFJLEVBQUUsaUJBQWlCLElBQUksT0FBTyxDQUFBLEFBQUMsRUFBRTtBQUMzRSxXQUFPLEdBQUcsSUFBSSxvQkFBTyxjQUFjLEVBQUUsQ0FBQztBQUN0QyxXQUFPLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQztBQUNoQyxXQUFPLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQzs7O0FBRy9CLFdBQU8sQ0FBQyxVQUFVLEdBQUcsWUFBVSxFQUFFLENBQUM7QUFDbEMsV0FBTyxDQUFDLFNBQVMsR0FBRyxZQUFVLEVBQUUsQ0FBQzs7O0dBR2xDLE1BQU07O0FBQ0wsVUFBTSxPQUFPLEdBQUksT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLElBQUksTUFBTSxDQUFDLFFBQVEsSUFBSSxPQUFPLEFBQUMsQ0FBQzs7QUFFNUUsYUFBTyxDQUFDLGtCQUFrQixHQUFHLFlBQVc7QUFDdEMsWUFBSSxPQUFPLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRTtBQUM1QixjQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7QUFDcEIsbUJBQU8sWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1dBQ2hDOztBQUVELGNBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQzdELDBCQUFjLEVBQUUsQ0FBQztXQUNsQixNQUFNO0FBQ0wsd0JBQVksRUFBRSxDQUFDO1dBQ2hCO1NBQ0Y7T0FDRixDQUFDOztBQUVGLFVBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUNuQixvQkFBWSxHQUFHLG9CQUFPLFVBQVUsQ0FBQyxZQUFXO0FBQzFDLGNBQUksT0FBTyxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUU7QUFDNUIsbUJBQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLG1CQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7V0FDakI7U0FDRixFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztPQUNyQjs7R0FDRjs7O0FBR0QsTUFBSTs7QUFFRixXQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksS0FBSyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7R0FDMUQsQ0FBQyxPQUFNLEdBQUcsRUFBRTtBQUNYLFdBQU8sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQzFCOzs7QUFHRCxNQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUU7QUFDMUIsV0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7R0FDaEM7O0FBRUQsTUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO0FBQ3hCLFdBQU8sQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztHQUM3Qzs7O0FBR0QsTUFBSTtBQUNGLFdBQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztHQUNoQixDQUFDLE9BQU0sR0FBRyxFQUFFO0FBQ1gsV0FBTyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDMUI7O0FBRUQsU0FBTyxPQUFPLENBQUM7Q0FDaEIsQ0FBQzs7cUJBRWEsR0FBRyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuIiwiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIixudWxsLCJtb2R1bGUuZXhwb3J0cyA9IFNhZmVQYXJzZVR1cGxlXG5cbmZ1bmN0aW9uIFNhZmVQYXJzZVR1cGxlKG9iaiwgcmV2aXZlcikge1xuICAgIHZhciBqc29uXG4gICAgdmFyIGVycm9yID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2Uob2JqLCByZXZpdmVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvciA9IGVyclxuICAgIH1cblxuICAgIHJldHVybiBbZXJyb3IsIGpzb25dXG59XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4vYnV0dG9uJztcblxuLyogQmlnIFBsYXkgQnV0dG9uXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBJbml0aWFsIHBsYXkgYnV0dG9uLiBTaG93cyBiZWZvcmUgdGhlIHZpZGVvIGhhcyBwbGF5ZWQuIFRoZSBoaWRpbmcgb2YgdGhlXG4gKiBiaWcgcGxheSBidXR0b24gaXMgZG9uZSB2aWEgQ1NTIGFuZCBwbGF5ZXIgc3RhdGVzLlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQmlnUGxheUJ1dHRvbiBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtYmlnLXBsYXktYnV0dG9uJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nLFxuICAgICAgJ2FyaWEtbGFiZWwnOiAncGxheSB2aWRlbydcbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2xpY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgfVxuXG59XG5cbkJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnQmlnUGxheUJ1dHRvbicsIEJpZ1BsYXlCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgQmlnUGxheUJ1dHRvbjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyogQnV0dG9uIC0gQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidXR0b25zXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIHRoaXMub24oJ3RhcCcsIHRoaXMub25DbGljayk7XG4gICAgdGhpcy5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vbkZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuICB9XG5cbiAgY3JlYXRlRWwodHlwZSwgcHJvcHMpIHtcbiAgICAvLyBBZGQgc3RhbmRhcmQgQXJpYSBhbmQgVGFiaW5kZXggaW5mb1xuICAgIHByb3BzID0gTGliLm9iai5tZXJnZSh7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJywgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBidXR0b24gbWF5IGNoYW5nZVxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBsZXQgZWwgPSBzdXBlci5jcmVhdGVFbCh0eXBlLCBwcm9wcyk7XG5cbiAgICAvLyBpZiBpbm5lckhUTUwgaGFzbid0IGJlZW4gb3ZlcnJpZGRlbiAoYmlnUGxheUJ1dHRvbiksIGFkZCBjb250ZW50IGVsZW1lbnRzXG4gICAgaWYgKCFwcm9wcy5pbm5lckhUTUwpIHtcbiAgICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1jb250ZW50J1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udHJvbFRleHRfID0gTGliLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKHRoaXMuYnV0dG9uVGV4dCkgfHwgJ05lZWQgVGV4dCdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNvbnRlbnRFbF8uYXBwZW5kQ2hpbGQodGhpcy5jb250cm9sVGV4dF8pO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICBidWlsZENTU0NsYXNzKCkge1xuICAgIC8vIFRPRE86IENoYW5nZSB2anMtY29udHJvbCB0byB2anMtYnV0dG9uP1xuICAgIHJldHVybiBgdmpzLWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIC8vIENsaWNrIC0gT3ZlcnJpZGUgd2l0aCBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5IGZvciBidXR0b25cbiAgb25DbGljaygpIHt9XG5cbiAgLy8gRm9jdXMgLSBBZGQga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50XG4gIG9uRm9jdXMoKSB7XG4gICAgRXZlbnRzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIExpYi5iaW5kKHRoaXMsIHRoaXMub25LZXlQcmVzcykpO1xuICB9XG5cbiAgLy8gS2V5UHJlc3MgKGRvY3VtZW50IGxldmVsKSAtIFRyaWdnZXIgY2xpY2sgd2hlbiBrZXlzIGFyZSBwcmVzc2VkXG4gIG9uS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmFyICgzMikgb3IgZW50ZXIgKDEzKSBrZXlzXG4gICAgaWYgKGV2ZW50LndoaWNoID09IDMyIHx8IGV2ZW50LndoaWNoID09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQmx1ciAtIFJlbW92ZSBrZXlib2FyZCB0cmlnZ2Vyc1xuICBvbkJsdXIoKSB7XG4gICAgRXZlbnRzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBMaWIuYmluZCh0aGlzLCB0aGlzLm9uS2V5UHJlc3MpKTtcbiAgfVxuXG59XG5cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBsYXllciBDb21wb25lbnQgLSBCYXNlIGNsYXNzIGZvciBhbGwgVUkgb2JqZWN0c1xuICpcbiAqL1xuXG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWIuanMnO1xuaW1wb3J0ICogYXMgVmpzVXRpbCBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbi8qKlxuICogQmFzZSBVSSBDb21wb25lbnQgY2xhc3NcbiAqXG4gKiBDb21wb25lbnRzIGFyZSBlbWJlZGRhYmxlIFVJIG9iamVjdHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgYnkgYm90aCBhXG4gKiBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudCBpbiB0aGUgRE9NLiBUaGV5IGNhbiBiZSBjaGlsZHJlbiBvZiBvdGhlclxuICogY29tcG9uZW50cywgYW5kIGNhbiBoYXZlIG1hbnkgY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqXG4gKiAgICAgLy8gYWRkaW5nIGEgYnV0dG9uIHRvIHRoZSBwbGF5ZXJcbiAqICAgICB2YXIgYnV0dG9uID0gcGxheWVyLmFkZENoaWxkKCdidXR0b24nKTtcbiAqICAgICBidXR0b24uZWwoKTsgLy8gLT4gYnV0dG9uIGVsZW1lbnRcbiAqXG4gKiAgICAgPGRpdiBjbGFzcz1cInZpZGVvLWpzXCI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWJ1dHRvblwiPkJ1dHRvbjwvZGl2PlxuICogICAgIDwvZGl2PlxuICpcbiAqIENvbXBvbmVudHMgYXJlIGFsc28gZXZlbnQgZW1pdHRlcnMuXG4gKlxuICogICAgIGJ1dHRvbi5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICogICAgICAgY29uc29sZS5sb2coJ0J1dHRvbiBDbGlja2VkIScpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBidXR0b24udHJpZ2dlcignY3VzdG9tZXZlbnQnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyICBNYWluIFBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucywgcmVhZHkpe1xuXG4gICAgLy8gVGhlIGNvbXBvbmVudCBtaWdodCBiZSB0aGUgcGxheWVyIGl0c2VsZiBhbmQgd2UgY2FuJ3QgcGFzcyBgdGhpc2AgdG8gc3VwZXJcbiAgICBpZiAoIXBsYXllciAmJiB0aGlzLnBsYXkpIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllciA9IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgY29weSBvZiBwcm90b3R5cGUub3B0aW9uc18gdG8gcHJvdGVjdCBhZ2FpbnN0IG92ZXJyaWRpbmcgZ2xvYmFsIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IExpYi5vYmouY29weSh0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIFVwZGF0ZWQgb3B0aW9ucyB3aXRoIHN1cHBsaWVkIG9wdGlvbnNcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gR2V0IElEIGZyb20gb3B0aW9ucyBvciBvcHRpb25zIGVsZW1lbnQgaWYgb25lIGlzIHN1cHBsaWVkXG4gICAgdGhpcy5pZF8gPSBvcHRpb25zLmlkIHx8IChvcHRpb25zLmVsICYmIG9wdGlvbnMuZWwuaWQpO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIG5vIElEIGZyb20gdGhlIG9wdGlvbnMsIGdlbmVyYXRlIG9uZVxuICAgIGlmICghdGhpcy5pZF8pIHtcbiAgICAgIC8vIERvbid0IHJlcXVpcmUgdGhlIHBsYXllciBJRCBmdW5jdGlvbiBpbiB0aGUgY2FzZSBvZiBtb2NrIHBsYXllcnNcbiAgICAgIGxldCBpZCA9IHBsYXllci5pZCAmJiBwbGF5ZXIuaWQoKSB8fCAnbm9fcGxheWVyJztcbiAgICAgIHRoaXMuaWRfID0gYCR7aWR9X2NvbXBvbmVudF8ke0xpYi5ndWlkKyt9YDtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gb3B0aW9uc1snbmFtZSddIHx8IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgZWxlbWVudCBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy5lbF8gPSBvcHRpb25zLmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jcmVhdGVFbCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fID0gW107XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IHt9O1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0ge307XG5cbiAgICAvLyBBZGQgYW55IGNoaWxkIGNvbXBvbmVudHMgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmluaXRDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeShyZWFkeSk7XG4gICAgLy8gRG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHJlYWR5IGhlcmUgb3IgaXQgd2lsbCBiZWZvcmUgaW5pdCBpcyBhY3R1YWxseVxuICAgIC8vIGZpbmlzaGVkIGZvciBhbGwgY2hpbGRyZW4gdGhhdCBydW4gdGhpcyBjb25zdHJ1Y3RvclxuXG4gICAgaWYgKG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZW5hYmxlVG91Y2hBY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRlbXAgZm9yIEVTNiBjbGFzcyB0cmFuc2l0aW9uLCByZW1vdmUgYmVmb3JlIDUuMFxuICBpbml0KCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdpbml0IGNhbGxlZCBvbiBDb21wb25lbnQnKTtcbiAgICBDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBjb21wb25lbnQgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdkaXNwb3NlJywgJ2J1YmJsZXMnOiBmYWxzZSB9KTtcblxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxuICAgIGlmICh0aGlzLmNoaWxkcmVuXykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcbiAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgIH1cblxuICAgIExpYi5yZW1vdmVEYXRhKHRoaXMuZWxfKTtcbiAgICB0aGlzLmVsXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb21wb25lbnQncyBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cbiAgcGxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcl87XG4gIH1cblxuICAvKipcbiAgICogRGVlcCBtZXJnZSBvZiBvcHRpb25zIG9iamVjdHNcbiAgICpcbiAgICogV2hlbmV2ZXIgYSBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgb24gYm90aCBvcHRpb25zIG9iamVjdHNcbiAgICogdGhlIHR3byBwcm9wZXJ0aWVzIHdpbGwgYmUgbWVyZ2VkIHVzaW5nIExpYi5vYmouZGVlcE1lcmdlLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIG1lcmdpbmcgb3B0aW9ucyBmb3IgY2hpbGQgY29tcG9uZW50cy4gV2VcbiAgICogd2FudCBpdCB0byBiZSBlYXN5IHRvIG92ZXJyaWRlIGluZGl2aWR1YWwgb3B0aW9ucyBvbiBhIGNoaWxkXG4gICAqIGNvbXBvbmVudCB3aXRob3V0IGhhdmluZyB0byByZXdyaXRlIGFsbCB0aGUgb3RoZXIgZGVmYXVsdCBvcHRpb25zLlxuICAgKlxuICAgKiAgICAgUGFyZW50LnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgICogICAgICAgY2hpbGRyZW46IHtcbiAgICogICAgICAgICAnY2hpbGRPbmUnOiB7ICdmb28nOiAnYmFyJywgJ2FzZGYnOiAnZmRzYScgfSxcbiAgICogICAgICAgICAnY2hpbGRUd28nOiB7fSxcbiAgICogICAgICAgICAnY2hpbGRUaHJlZSc6IHt9XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICAgIG5ld09wdGlvbnMgPSB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JheicsICdhYmMnOiAnMTIzJyB9XG4gICAqICAgICAgICAgJ2NoaWxkVHdvJzogbnVsbCxcbiAgICogICAgICAgICAnY2hpbGRGb3VyJzoge31cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgdGhpcy5vcHRpb25zKG5ld09wdGlvbnMpO1xuICAgKlxuICAgKiBSRVNVTFRcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgY2hpbGRyZW46IHtcbiAgICogICAgICAgICAnY2hpbGRPbmUnOiB7ICdmb28nOiAnYmF6JywgJ2FzZGYnOiAnZmRzYScsICdhYmMnOiAnMTIzJyB9LFxuICAgKiAgICAgICAgICdjaGlsZFR3byc6IG51bGwsIC8vIERpc2FibGVkLiBXb24ndCBiZSBpbml0aWFsaXplZC5cbiAgICogICAgICAgICAnY2hpbGRUaHJlZSc6IHt9LFxuICAgKiAgICAgICAgICdjaGlsZEZvdXInOiB7fVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCBvZiBuZXcgb3B0aW9uIHZhbHVlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBBIE5FVyBvYmplY3Qgb2YgdGhpcy5vcHRpb25zXyBhbmQgb2JqIG1lcmdlZFxuICAgKi9cbiAgb3B0aW9ucyhvYmope1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMub3B0aW9uc187XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXyA9IFZqc1V0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIG9iaik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiAgICAgdmFyIGRvbUVsID0gbXlDb21wb25lbnQuZWwoKTtcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGVsKCl7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nPX0gdGFnTmFtZSAgRWxlbWVudCdzIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xuICAgKiBAcGFyYW0gIHtPYmplY3Q9fSBhdHRyaWJ1dGVzIEFuIG9iamVjdCBvZiBlbGVtZW50IGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVFbCh0YWdOYW1lLCBhdHRyaWJ1dGVzKXtcbiAgICByZXR1cm4gTGliLmNyZWF0ZUVsKHRhZ05hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgbG9jYWxpemUoc3RyaW5nKXtcbiAgICBsZXQgbGFuZyA9IHRoaXMucGxheWVyXy5sYW5ndWFnZSgpO1xuICAgIGxldCBsYW5ndWFnZXMgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzKCk7XG5cbiAgICBpZiAobGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tsYW5nXSAmJiBsYW5ndWFnZXNbbGFuZ11bc3RyaW5nXSkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlc1tsYW5nXVtzdHJpbmddO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudCB3aGVyZSBjaGlsZHJlbiBhcmUgaW5zZXJ0ZWQuXG4gICAqIFdpbGwgZWl0aGVyIGJlIHRoZSBzYW1lIGFzIGVsKCkgb3IgYSBuZXcgZWxlbWVudCBkZWZpbmVkIGluIGNyZWF0ZUVsKCkuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjb250ZW50RWwoKXtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50RWxfIHx8IHRoaXMuZWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50J3MgSURcbiAgICpcbiAgICogICAgIHZhciBpZCA9IG15Q29tcG9uZW50LmlkKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGlkKCl7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50J3MgbmFtZS4gVGhlIG5hbWUgaXMgb2Z0ZW4gdXNlZCB0byByZWZlcmVuY2UgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogICAgIHZhciBuYW1lID0gbXlDb21wb25lbnQubmFtZSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBuYW1lKCl7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAqXG4gICAqICAgICB2YXIga2lkcyA9IG15Q29tcG9uZW50LmNoaWxkcmVuKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgY2hpbGRyZW5cbiAgICovXG4gIGNoaWxkcmVuKCl7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgSURcbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Q2hpbGRCeUlkKGlkKXtcbiAgICByZXR1cm4gdGhpcy5jaGlsZEluZGV4X1tpZF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNoaWxkIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIGdldENoaWxkKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgY29tcG9uZW50IGluc2lkZSB0aGlzIGNvbXBvbmVudFxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQuZWwoKTtcbiAgICogICAgIC8vIC0+IDxkaXYgY2xhc3M9J215LWNvbXBvbmVudCc+PC9kaXY+XG4gICAqICAgICBteUNvbXBvbmVudC5jaGlsZHJlbigpO1xuICAgKiAgICAgLy8gW2VtcHR5IGFycmF5XVxuICAgKlxuICAgKiAgICAgdmFyIG15QnV0dG9uID0gbXlDb21wb25lbnQuYWRkQ2hpbGQoJ015QnV0dG9uJyk7XG4gICAqICAgICAvLyAtPiA8ZGl2IGNsYXNzPSdteS1jb21wb25lbnQnPjxkaXYgY2xhc3M9XCJteS1idXR0b25cIj5teUJ1dHRvbjxkaXY+PC9kaXY+XG4gICAqICAgICAvLyAtPiBteUJ1dHRvbiA9PT0gbXlDb21vbmVudC5jaGlsZHJlbigpWzBdO1xuICAgKlxuICAgKiBQYXNzIGluIG9wdGlvbnMgZm9yIGNoaWxkIGNvbnN0cnVjdG9ycyBhbmQgb3B0aW9ucyBmb3IgY2hpbGRyZW4gb2YgdGhlIGNoaWxkXG4gICAqXG4gICAqICAgICB2YXIgbXlCdXR0b24gPSBteUNvbXBvbmVudC5hZGRDaGlsZCgnTXlCdXR0b24nLCB7XG4gICAqICAgICAgIHRleHQ6ICdQcmVzcyBNZScsXG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgYnV0dG9uQ2hpbGRFeGFtcGxlOiB7XG4gICAqICAgICAgICAgICBidXR0b25DaGlsZE9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfENvbXBvbmVudH0gY2hpbGQgVGhlIGNsYXNzIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMsIGluY2x1ZGluZyBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBjaGlsZHJlbiBvZiB0aGUgY2hpbGQuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhlIGNoaWxkIGNvbXBvbmVudCAoY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MgaWYgYSBzdHJpbmcgd2FzIHVzZWQpXG4gICAqIEBzdXBwcmVzcyB7YWNjZXNzQ29udHJvbHN8Y2hlY2tSZWdFeHB8Y2hlY2tUeXBlc3xjaGVja1ZhcnN8Y29uc3R8Y29uc3RhbnRQcm9wZXJ0eXxkZXByZWNhdGVkfGR1cGxpY2F0ZXxlczVTdHJpY3R8ZmlsZW92ZXJ2aWV3VGFnc3xnbG9iYWxUaGlzfGludmFsaWRDYXN0c3xtaXNzaW5nUHJvcGVydGllc3xub25TdGFuZGFyZEpzRG9jc3xzdHJpY3RNb2R1bGVEZXBDaGVja3x1bmRlZmluZWROYW1lc3x1bmRlZmluZWRWYXJzfHVua25vd25EZWZpbmVzfHVzZWxlc3NDb2RlfHZpc2liaWxpdHl9XG4gICAqL1xuICBhZGRDaGlsZChjaGlsZCwgb3B0aW9ucz17fSl7XG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBsZXQgY29tcG9uZW50TmFtZTtcblxuICAgIC8vIElmIGNoaWxkIGlzIGEgc3RyaW5nLCBjcmVhdGUgbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjaGlsZDtcblxuICAgICAgLy8gT3B0aW9ucyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBib29sZWFuLCBzbyBjb252ZXJ0IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBmYWxzZS5cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCB0cnVlIGlzIGRlcHJlY2F0ZWQgc28gc2hvdyBhIHdhcm5pbmcuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBMaWIubG9nLndhcm4oJ0luaXRpYWxpemluZyBhIGNoaWxkIGNvbXBvbmVudCB3aXRoIGB0cnVlYCBpcyBkZXByZWNhdGVkLiBDaGlsZHJlbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBhbiBhcnJheSB3aGVuIHBvc3NpYmxlLCBidXQgaWYgbmVjZXNzYXJ5IHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBgdHJ1ZWAuJyk7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gY29tcG9uZW50Q2xhc3MgaW4gb3B0aW9ucywgYXNzdW1lIGNvbXBvbmVudENsYXNzIGlzIHRoZSBuYW1lIGxvd2VyY2FzZWRcbiAgICAgIC8vIChlLmcuIHBsYXlCdXR0b24pXG4gICAgICBsZXQgY29tcG9uZW50Q2xhc3NOYW1lID0gb3B0aW9uc1snY29tcG9uZW50Q2xhc3MnXSB8fCBMaWIuY2FwaXRhbGl6ZShjb21wb25lbnROYW1lKTtcblxuICAgICAgLy8gU2V0IG5hbWUgdGhyb3VnaCBvcHRpb25zXG4gICAgICBvcHRpb25zWyduYW1lJ10gPSBjb21wb25lbnROYW1lO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0ICYgZWxlbWVudCBmb3IgdGhpcyBjb250cm9scyBzZXRcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gLnBsYXllcl8sIHRoaXMgaXMgYSBwbGF5ZXJcbiAgICAgIGxldCBjb21wb25lbnRDbGFzcyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY29tcG9uZW50Q2xhc3NOYW1lKTtcblxuICAgICAgY29tcG9uZW50ID0gbmV3IGNvbXBvbmVudENsYXNzKHRoaXMucGxheWVyXyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IGNoaWxkO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnB1c2goY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgKGNvbXBvbmVudC5uYW1lICYmIGNvbXBvbmVudC5uYW1lKCkpO1xuXG4gICAgaWYgKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfW2NvbXBvbmVudE5hbWVdID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgVUkgb2JqZWN0J3MgZWxlbWVudCB0byB0aGUgY29udGFpbmVyIGRpdiAoYm94KVxuICAgIC8vIEhhdmluZyBhbiBlbGVtZW50IGlzIG5vdCByZXF1aXJlZFxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmVsID09PSAnZnVuY3Rpb24nICYmIGNvbXBvbmVudC5lbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLmFwcGVuZENoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gc28gaXQgY2FuIHN0b3JlZCBvbiBwYXJlbnQgb2JqZWN0IGlmIGRlc2lyZWQuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBjb21wb25lbnQgZnJvbSB0aGlzIGNvbXBvbmVudCdzIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZCB0aGVcbiAgICogY2hpbGQgY29tcG9uZW50J3MgZWxlbWVudCBmcm9tIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDaGlsZChjb21wb25lbnQpe1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykgcmV0dXJuO1xuXG4gICAgbGV0IGNoaWxkRm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZEZvdW5kKSByZXR1cm47XG5cbiAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50Lm5hbWUoKV0gPSBudWxsO1xuXG4gICAgdmFyIGNvbXBFbCA9IGNvbXBvbmVudC5lbCgpO1xuICAgIGlmIChjb21wRWwgJiYgY29tcEVsLnBhcmVudE5vZGUgPT09IHRoaXMuY29udGVudEVsKCkpIHtcbiAgICAgIHRoaXMuY29udGVudEVsKCkucmVtb3ZlQ2hpbGQoY29tcG9uZW50LmVsKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBjb21wb25lbnRzIGZyb20gb3B0aW9uc1xuICAgKlxuICAgKiAgICAgLy8gd2hlbiBhbiBpbnN0YW5jZSBvZiBNeUNvbXBvbmVudCBpcyBjcmVhdGVkLCBhbGwgY2hpbGRyZW4gaW4gb3B0aW9uc1xuICAgKiAgICAgLy8gd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5zdGFuY2UgYnkgdGhlaXIgbmFtZSBzdHJpbmdzIGFuZCBvcHRpb25zXG4gICAqICAgICBNeUNvbXBvbmVudC5wcm90b3R5cGUub3B0aW9uc18uY2hpbGRyZW4gPSB7XG4gICAqICAgICAgIG15Q2hpbGRDb21wb25lbnQ6IHtcbiAgICogICAgICAgICBteUNoaWxkT3B0aW9uOiB0cnVlXG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIC8vIE9yIHdoZW4gY3JlYXRpbmcgdGhlIGNvbXBvbmVudFxuICAgKiAgICAgdmFyIG15Q29tcCA9IG5ldyBNeUNvbXBvbmVudChwbGF5ZXIsIHtcbiAgICogICAgICAgY2hpbGRyZW46IHtcbiAgICogICAgICAgICBteUNoaWxkQ29tcG9uZW50OiB7XG4gICAqICAgICAgICAgICBteUNoaWxkT3B0aW9uOiB0cnVlXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogVGhlIGNoaWxkcmVuIG9wdGlvbiBjYW4gYWxzbyBiZSBhbiBBcnJheSBvZiBjaGlsZCBuYW1lcyBvclxuICAgKiBjaGlsZCBvcHRpb25zIG9iamVjdHMgKHRoYXQgYWxzbyBpbmNsdWRlIGEgJ25hbWUnIGtleSkuXG4gICAqXG4gICAqICAgICB2YXIgbXlDb21wID0gbmV3IE15Q29tcG9uZW50KHBsYXllciwge1xuICAgKiAgICAgICBjaGlsZHJlbjogW1xuICAgKiAgICAgICAgICdidXR0b24nLFxuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgIG5hbWU6ICdidXR0b24nLFxuICAgKiAgICAgICAgICAgc29tZU90aGVyT3B0aW9uOiB0cnVlXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9KTtcbiAgICpcbiAgICovXG4gIGluaXRDaGlsZHJlbigpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLm9wdGlvbnNfLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgIGxldCBwYXJlbnRPcHRpb25zID0gcGFyZW50Lm9wdGlvbnMoKTtcbiAgICAgIGxldCBoYW5kbGVBZGQgPSBmdW5jdGlvbihuYW1lLCBvcHRzKXtcbiAgICAgICAgLy8gQWxsb3cgb3B0aW9ucyBmb3IgY2hpbGRyZW4gdG8gYmUgc2V0IGF0IHRoZSBwYXJlbnQgb3B0aW9uc1xuICAgICAgICAvLyBlLmcuIHZpZGVvanMoaWQsIHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIC8vIGluc3RlYWQgb2YgdmlkZW9qcyhpZCwgeyBjaGlsZHJlbjogeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKHBhcmVudE9wdGlvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdHMgPSBwYXJlbnRPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgZm9yIGRpc2FibGluZyBkZWZhdWx0IGNvbXBvbmVudHNcbiAgICAgICAgLy8gZS5nLiBvcHRpb25zWydjaGlsZHJlbiddWydwb3N0ZXJJbWFnZSddID0gZmFsc2VcbiAgICAgICAgaWYgKG9wdHMgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gQWRkIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgYnkgbmFtZSBvbiB0aGUgcGFyZW50IGluc3RhbmNlLlxuICAgICAgICAvLyBJZiB0d28gb2YgdGhlIHNhbWUgY29tcG9uZW50IGFyZSB1c2VkLCBkaWZmZXJlbnQgbmFtZXMgc2hvdWxkIGJlIHN1cHBsaWVkXG4gICAgICAgIC8vIGZvciBlYWNoXG4gICAgICAgIHBhcmVudFtuYW1lXSA9IHBhcmVudC5hZGRDaGlsZChuYW1lLCBvcHRzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEFsbG93IGZvciBhbiBhcnJheSBvZiBjaGlsZHJlbiBkZXRhaWxzIHRvIHBhc3NlZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgaWYgKExpYi5vYmouaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgbGV0IG5hbWUsIG9wdHM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gWydteUNvbXBvbmVudCddXG4gICAgICAgICAgICBuYW1lID0gY2hpbGQ7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFt7IG5hbWU6ICdteUNvbXBvbmVudCcsIG90aGVyT3B0aW9uOiB0cnVlIH1dXG4gICAgICAgICAgICBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgICAgIG9wdHMgPSBjaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVBZGQobmFtZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExpYi5vYmouZWFjaChjaGlsZHJlbiwgaGFuZGxlQWRkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqL1xuICBidWlsZENTU0NsYXNzKCl7XG4gICAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgICAgLy8gcmV0dXJuICdDTEFTUyBOQU1FJyArIHRoaXMuX3N1cGVyKCk7XG4gICAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiAgICAgdmFyIG15RnVuYyA9IGZ1bmN0aW9uKCl7XG4gICAqICAgICAgIHZhciBteUNvbXBvbmVudCA9IHRoaXM7XG4gICAqICAgICAgIC8vIERvIHNvbWV0aGluZyB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgKiAgICAgfTtcbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50Lm9uKCdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBUaGUgY29udGV4dCBvZiBteUZ1bmMgd2lsbCBiZSBteUNvbXBvbmVudCB1bmxlc3MgcHJldmlvdXNseSBib3VuZC5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBhZGQgYSBsaXN0ZW5lciB0byBhbm90aGVyIGVsZW1lbnQgb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub24ob3RoZXJFbGVtZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICogICAgIG15Q29tcG9uZW50Lm9uKG90aGVyQ29tcG9uZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICpcbiAgICogVGhlIGJlbmVmaXQgb2YgdXNpbmcgdGhpcyBvdmVyIGBWanNFdmVudHMub24ob3RoZXJFbGVtZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKWBcbiAgICogYW5kIGBvdGhlckNvbXBvbmVudC5vbignZXZlbnROYW1lJywgbXlGdW5jKWAgaXMgdGhhdCB0aGlzIHdheSB0aGUgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIHdoZW4gZWl0aGVyIGNvbXBvbmVudCBpcyBkaXNwb3NlZC5cbiAgICogSXQgd2lsbCBhbHNvIGJpbmQgbXlDb21wb25lbnQgYXMgdGhlIGNvbnRleHQgb2YgbXlGdW5jLlxuICAgKlxuICAgKiAqKk5PVEUqKjogV2hlbiB1c2luZyB0aGlzIG9uIGVsZW1lbnRzIGluIHRoZSBwYWdlIG90aGVyIHRoYW4gd2luZG93XG4gICAqIGFuZCBkb2N1bWVudCAoYm90aCBwZXJtYW5lbnQpLCBpZiB5b3UgcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgKiB5b3UgbmVlZCB0byBjYWxsIGBteUNvbXBvbmVudC50cmlnZ2VyKGVsLCAnZGlzcG9zZScpYCBvbiBpdCB0byBjbGVhbiB1cFxuICAgKiByZWZlcmVuY2VzIHRvIGl0IGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBnYXJiYWdlIGNvbGxlY3QgaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ3xDb21wb25lbnR9IGZpcnN0ICAgVGhlIGV2ZW50IHR5cGUgb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufFN0cmluZ30gICAgICBzZWNvbmQgIFRoZSBldmVudCBoYW5kbGVyIG9yIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICAgICAgIHRoaXJkICAgVGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSAgICAgICAgc2VsZlxuICAgKi9cbiAgb24oZmlyc3QsIHNlY29uZCwgdGhpcmQpe1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IExpYi5vYmouaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIEV2ZW50cy5vbih0aGlzLmVsXywgZmlyc3QsIExpYi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuXG4gICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICBjb25zdCB0eXBlID0gc2Vjb25kO1xuICAgICAgY29uc3QgZm4gPSBMaWIuYmluZCh0aGlzLCB0aGlyZCk7XG4gICAgICBjb25zdCB0aGlzQ29tcG9uZW50ID0gdGhpcztcblxuICAgICAgLy8gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBvdGhlciBjb21wb25lbnRcbiAgICAgIGNvbnN0IHJlbW92ZU9uRGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXNDb21wb25lbnQub2ZmKHRhcmdldCwgdHlwZSwgZm4pO1xuICAgICAgfTtcbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyIGl0IHVzaW5nIHRoZSBJRFxuICAgICAgLy8gb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyXG4gICAgICByZW1vdmVPbkRpc3Bvc2UuZ3VpZCA9IGZuLmd1aWQ7XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgcmVtb3ZlT25EaXNwb3NlKTtcblxuICAgICAgLy8gSWYgdGhlIG90aGVyIGNvbXBvbmVudCBpcyBkaXNwb3NlZCBmaXJzdCB3ZSBuZWVkIHRvIGNsZWFuIHRoZSByZWZlcmVuY2VcbiAgICAgIC8vIHRvIHRoZSBvdGhlciBjb21wb25lbnQgaW4gdGhpcyBjb21wb25lbnQncyByZW1vdmVPbkRpc3Bvc2UgbGlzdGVuZXJcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBjcmVhdGUgYSBtZW1vcnkgbGVhay5cbiAgICAgIGNvbnN0IGNsZWFuUmVtb3ZlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXNDb21wb25lbnQub2ZmKCdkaXNwb3NlJywgcmVtb3ZlT25EaXNwb3NlKTtcbiAgICAgIH07XG4gICAgICAvLyBBZGQgdGhlIHNhbWUgZnVuY3Rpb24gSUQgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIGNsZWFuUmVtb3Zlci5ndWlkID0gZm4uZ3VpZDtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIERPTSBub2RlXG4gICAgICBpZiAoZmlyc3Qubm9kZU5hbWUpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUgb3RoZXIgZWxlbWVudFxuICAgICAgICBFdmVudHMub24odGFyZ2V0LCB0eXBlLCBmbik7XG4gICAgICAgIEV2ZW50cy5vbih0YXJnZXQsICdkaXNwb3NlJywgY2xlYW5SZW1vdmVyKTtcblxuICAgICAgLy8gU2hvdWxkIGJlIGEgY29tcG9uZW50XG4gICAgICAvLyBOb3QgdXNpbmcgYGluc3RhbmNlb2YgQ29tcG9uZW50YCBiZWNhdXNlIGl0IG1ha2VzIG1vY2sgcGxheWVycyBkaWZmaWN1bHRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0Lm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIG90aGVyIGNvbXBvbmVudFxuICAgICAgICB0YXJnZXQub24odHlwZSwgZm4pO1xuICAgICAgICB0YXJnZXQub24oJ2Rpc3Bvc2UnLCBjbGVhblJlbW92ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub2ZmKCdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBJZiBteUZ1bmMgaXMgZXhjbHVkZWQsIEFMTCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogSWYgZXZlbnRUeXBlIGlzIGV4Y2x1ZGVkLCBBTEwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHkgeW91IGNhbiB1c2UgYG9mZmAgdG8gcmVtb3ZlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdG8gb3RoZXJcbiAgICogZWxlbWVudHMgb3IgY29tcG9uZW50cyB1c2luZyBgbXlDb21wb25lbnQub24ob3RoZXJDb21wb25lbnQuLi5gLlxuICAgKiBJbiB0aGlzIGNhc2UgYm90aCB0aGUgZXZlbnQgdHlwZSBhbmQgbGlzdGVuZXIgZnVuY3Rpb24gYXJlIFJFUVVJUkVELlxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub2ZmKG90aGVyRWxlbWVudCwgJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqICAgICBteUNvbXBvbmVudC5vZmYob3RoZXJDb21wb25lbnQsICdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmc9fENvbXBvbmVudH0gIGZpcnN0ICBUaGUgZXZlbnQgdHlwZSBvciBvdGhlciBjb21wb25lbnRcbiAgICogQHBhcmFtICB7RnVuY3Rpb249fFN0cmluZ30gICAgICAgc2Vjb25kIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBldmVudCB0eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9uPX0gICAgICAgICAgICAgIHRoaXJkICBUaGUgbGlzdGVuZXIgZm9yIG90aGVyIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBvZmYoZmlyc3QsIHNlY29uZCwgdGhpcmQpe1xuICAgIGlmICghZmlyc3QgfHwgdHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fCBMaWIub2JqLmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBFdmVudHMub2ZmKHRoaXMuZWxfLCBmaXJzdCwgc2Vjb25kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICBjb25zdCB0eXBlID0gc2Vjb25kO1xuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXG4gICAgICBjb25zdCBmbiA9IExpYi5iaW5kKHRoaXMsIHRoaXJkKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXNwb3NlIGxpc3RlbmVyIG9uIHRoaXMgY29tcG9uZW50LFxuICAgICAgLy8gd2hpY2ggd2FzIGdpdmVuIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGZuKTtcblxuICAgICAgaWYgKGZpcnN0Lm5vZGVOYW1lKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsIHR5cGUsIGZuKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lciBmb3IgY2xlYW5pbmcgdGhlIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsICdkaXNwb3NlJywgZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBmbik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBmbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZCBvbmx5IG9uY2UgYW5kIHRoZW4gcmVtb3ZlZFxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub25lKCdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gYWRkIGEgbGlzdGVuZXIgdG8gYW5vdGhlciBlbGVtZW50IG9yIGNvbXBvbmVudFxuICAgKiB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIG9ubHkgb25jZS5cbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50Lm9uZShvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKiAgICAgbXlDb21wb25lbnQub25lKG90aGVyQ29tcG9uZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfENvbXBvbmVudH0gIGZpcnN0ICAgVGhlIGV2ZW50IHR5cGUgb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufFN0cmluZ30gICAgICAgc2Vjb25kICBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbj19ICAgICAgICAgICAgIHRoaXJkICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBvdGhlciBjb21wb25lbnRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgb25lKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgTGliLm9iai5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgRXZlbnRzLm9uZSh0aGlzLmVsXywgZmlyc3QsIExpYi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBmaXJzdDtcbiAgICAgIGNvbnN0IHR5cGUgPSBzZWNvbmQ7XG4gICAgICBjb25zdCBmbiA9IExpYi5iaW5kKHRoaXMsIHRoaXJkKTtcbiAgICAgIGNvbnN0IHRoaXNDb21wb25lbnQgPSB0aGlzO1xuXG4gICAgICBjb25zdCBuZXdGdW5jID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpc0NvbXBvbmVudC5vZmYodGFyZ2V0LCB0eXBlLCBuZXdGdW5jKTtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICAvLyBLZWVwIHRoZSBzYW1lIGZ1bmN0aW9uIElEIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIG5ld0Z1bmMuZ3VpZCA9IGZuLmd1aWQ7XG5cbiAgICAgIHRoaXMub24odGFyZ2V0LCB0eXBlLCBuZXdGdW5jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIGFuIGVsZW1lbnRcbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50LnRyaWdnZXIoJ2V2ZW50TmFtZScpO1xuICAgKiAgICAgbXlDb21wb25lbnQudHJpZ2dlcih7J3R5cGUnOidldmVudE5hbWUnfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge0V2ZW50fE9iamVjdHxTdHJpbmd9IGV2ZW50ICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSAgICAgICBzZWxmXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50KXtcbiAgICBFdmVudHMudHJpZ2dlcih0aGlzLmVsXywgZXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgYSBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3MgcmVhZHkgc3RhdGVcbiAgICpcbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG4gICAqIGl0IHdpbGwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBSZWFkeSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICByZWFkeShmbil7XG4gICAgaWYgKGZuKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5Xykge1xuICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IHRoaXMucmVhZHlRdWV1ZV8gfHwgW107XG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8ucHVzaChmbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIHJlYWR5IGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICB0cmlnZ2VyUmVhZHkoKXtcbiAgICB0aGlzLmlzUmVhZHlfID0gdHJ1ZTtcblxuICAgIHZhciByZWFkeVF1ZXVlID0gdGhpcy5yZWFkeVF1ZXVlXztcblxuICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJlYWR5UXVldWUubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHJlYWR5UXVldWVbaV0uY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgUmVhZHkgUXVldWVcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSBbXTtcblxuICAgICAgLy8gQWxsb3cgZm9yIHVzaW5nIGV2ZW50IGxpc3RlbmVycyBhbHNvLCBpbiBjYXNlIHlvdSB3YW50IHRvIGRvIHNvbWV0aGluZyBldmVyeXRpbWUgYSBzb3VyY2UgaXMgcmVhZHkuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc1RvQ2hlY2spe1xuICAgIHJldHVybiBMaWIuaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc1RvQWRkKXtcbiAgICBMaWIuYWRkQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9BZGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9SZW1vdmUgQ2xhc3NuYW1lIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKXtcbiAgICBMaWIucmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlmIGhpZGRlblxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBzaG93KCl7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlmIGN1cnJlbnRseSBzaG93aW5nXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIGhpZGUoKXtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTG9jayBhbiBpdGVtIGluIGl0cyB2aXNpYmxlIHN0YXRlXG4gICAqIFRvIGJlIHVzZWQgd2l0aCBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbG9ja1Nob3dpbmcoKXtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIGFuIGl0ZW0gdG8gYmUgaGlkZGVuXG4gICAqIFRvIGJlIHVzZWQgd2l0aCBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5sb2NrU2hvd2luZygpe1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3IgZ2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IChDU1MgdmFsdWVzKVxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSB2aWRlbyB0YWcgZGltZW5zaW9uIHZhbHVlcyBvbmx5IHdvcmtzIHdpdGggdmFsdWVzIGluIHBpeGVscy5cbiAgICogUGVyY2VudCB2YWx1ZXMgd2lsbCBub3Qgd29yay5cbiAgICogU29tZSBwZXJjZW50cyBjYW4gYmUgdXNlZCwgYnV0IHdpZHRoKCkvaGVpZ2h0KCkgd2lsbCByZXR1cm4gdGhlIG51bWJlciArICUsXG4gICAqIG5vdCB0aGUgYWN0dWFsIGNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZz19IG51bSAgIE9wdGlvbmFsIHdpZHRoIG51bWJlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwTGlzdGVuZXJzIFNraXAgdGhlICdyZXNpemUnIGV2ZW50IHRyaWdnZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGlzIGNvbXBvbmVudCwgd2hlbiBzZXR0aW5nIHRoZSB3aWR0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBUaGUgd2lkdGgsIHdoZW4gZ2V0dGluZ1xuICAgKi9cbiAgd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKXtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgbnVtLCBza2lwTGlzdGVuZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCAoQ1NTIHZhbHVlcylcbiAgICpcbiAgICogU2V0dGluZyB0aGUgdmlkZW8gdGFnIGRpbWVuc2lvbiB2YWx1ZXMgb25seSB3b3JrcyB3aXRoIHZhbHVlcyBpbiBwaXhlbHMuXG4gICAqIFBlcmNlbnQgdmFsdWVzIHdpbGwgbm90IHdvcmsuXG4gICAqIFNvbWUgcGVyY2VudHMgY2FuIGJlIHVzZWQsIGJ1dCB3aWR0aCgpL2hlaWdodCgpIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgKyAlLFxuICAgKiBub3QgdGhlIGFjdHVhbCBjb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBudW0gICAgIE5ldyBjb21wb25lbnQgaGVpZ2h0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW49fSBza2lwTGlzdGVuZXJzIFNraXAgdGhlIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhpcyBjb21wb25lbnQsIHdoZW4gc2V0dGluZyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IFRoZSBoZWlnaHQsIHdoZW4gZ2V0dGluZ1xuICAgKi9cbiAgaGVpZ2h0KG51bSwgc2tpcExpc3RlbmVycyl7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXQgdGhlIHNhbWUgdGltZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBoZWlnaHRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGUgY29tcG9uZW50XG4gICAqL1xuICBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpe1xuICAgIC8vIFNraXAgcmVzaXplIGxpc3RlbmVycyBvbiB3aWR0aCBmb3Igb3B0aW1pemF0aW9uXG4gICAgcmV0dXJuIHRoaXMud2lkdGgod2lkdGgsIHRydWUpLmhlaWdodChoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0XG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGUgd2lkdGgoKSBhbmQgaGVpZ2h0KCkgbWV0aG9kcy5cbiAgICogQWxsIGZvciBhbiBpbnRlZ2VyLCBpbnRlZ2VyICsgJ3B4JyBvciBpbnRlZ2VyICsgJyUnO1xuICAgKlxuICAgKiBLbm93biBpc3N1ZTogSGlkZGVuIGVsZW1lbnRzIG9mZmljaWFsbHkgaGF2ZSBhIHdpZHRoIG9mIDAuIFdlJ3JlIGRlZmF1bHRpbmdcbiAgICogdG8gdGhlIHN0eWxlLndpZHRoIHZhbHVlIGFuZCBmYWxsaW5nIGJhY2sgdG8gY29tcHV0ZWRTdHlsZSB3aGljaCBoYXMgdGhlXG4gICAqIGhpZGRlbiBlbGVtZW50IGlzc3VlLiBJbmZvLCBidXQgcHJvYmFibHkgbm90IGFuIGVmZmljaWVudCBmaXg6XG4gICAqIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC9cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB3aWR0aE9ySGVpZ2h0ICAnd2lkdGgnIG9yICdoZWlnaHQnXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBudW0gICAgIE5ldyBkaW1lbnNpb25cbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IHNraXBMaXN0ZW5lcnMgU2tpcCByZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoZSBjb21wb25lbnQgaWYgYSBkaW1lbnNpb24gd2FzIHNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBUaGUgZGltZW5zaW9uIGlmIG5vdGhpbmcgd2FzIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycyl7XG4gICAgaWYgKG51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTZXQgdG8gemVybyBpZiBudWxsIG9yIGxpdGVyYWxseSBOYU4gKE5hTiAhPT0gTmFOKVxuICAgICAgaWYgKG51bSA9PT0gbnVsbCB8fCBudW0gIT09IG51bSkge1xuICAgICAgICBudW0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2luZyBjc3Mgd2lkdGgvaGVpZ2h0ICglIG9yIHB4KSBhbmQgYWRqdXN0XG4gICAgICBpZiAoKCcnK251bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycrbnVtKS5pbmRleE9mKCdweCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bTtcbiAgICAgIH0gZWxzZSBpZiAobnVtID09PSAnYXV0bycpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtKydweCc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIXNraXBMaXN0ZW5lcnMpIHsgdGhpcy50cmlnZ2VyKCdyZXNpemUnKTsgfVxuXG4gICAgICAvLyBSZXR1cm4gY29tcG9uZW50XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBOb3Qgc2V0dGluZyBhIHZhbHVlLCBzbyBnZXR0aW5nIGl0XG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmVsXykgcmV0dXJuIDA7XG5cbiAgICAvLyBHZXQgZGltZW5zaW9uIHZhbHVlIGZyb20gc3R5bGVcbiAgICB2YXIgdmFsID0gdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgdmFyIHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgdmFsdWUgd2l0aCBubyAncHgnXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsLnNsaWNlKDAscHhJbmRleCksIDEwKTtcblxuICAgIC8vIE5vIHB4IHNvIHVzaW5nICUgb3Igbm8gc3R5bGUgd2FzIHNldCwgc28gZmFsbGluZyBiYWNrIHRvIG9mZnNldFdpZHRoL2hlaWdodFxuICAgIC8vIElmIGNvbXBvbmVudCBoYXMgZGlzcGxheTpub25lLCBvZmZzZXQgd2lsbCByZXR1cm4gMFxuICAgIC8vIFRPRE86IGhhbmRsZSBkaXNwbGF5Om5vbmUgYW5kIG5vIGRpbWVuc2lvbiBzdHlsZSB1c2luZyBweFxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmVsX1snb2Zmc2V0JytMaWIuY2FwaXRhbGl6ZSh3aWR0aE9ySGVpZ2h0KV0sIDEwKTtcblxuICAgICAgLy8gQ29tcHV0ZWRTdHlsZSB2ZXJzaW9uLlxuICAgICAgLy8gT25seSBkaWZmZXJlbmNlIGlzIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBpdCB3aWxsIHJldHVyblxuICAgICAgLy8gdGhlIHBlcmNlbnQgdmFsdWUgKGUuZy4gJzEwMCUnJylcbiAgICAgIC8vIGluc3RlYWQgb2YgemVybyBsaWtlIG9mZnNldFdpZHRoIHJldHVybnMuXG4gICAgICAvLyB2YXIgdmFsID0gTGliLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLmVsXywgd2lkdGhPckhlaWdodCk7XG4gICAgICAvLyB2YXIgcHhJbmRleCA9IHZhbC5pbmRleE9mKCdweCcpO1xuXG4gICAgICAvLyBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vICAgcmV0dXJuIHZhbC5zbGljZSgwLCBweEluZGV4KTtcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHJldHVybiB2YWw7XG4gICAgICAvLyB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgJ3RhcCcgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnRzIGFyZSBzdXBwb3J0ZWRcbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIHRvIHN1cHBvcnQgdG9nZ2xpbmcgdGhlIGNvbnRyb2xzIHRocm91Z2ggYSB0YXAgb24gdGhlIHZpZGVvLlxuICAgKlxuICAgKiBXZSdyZSByZXF1aXJpbmcgdGhlbSB0byBiZSBlbmFibGVkIGJlY2F1c2Ugb3RoZXJ3aXNlIGV2ZXJ5IGNvbXBvbmVudCB3b3VsZFxuICAgKiBoYXZlIHRoaXMgZXh0cmEgb3ZlcmhlYWQgdW5uZWNlc3NhcmlseSwgb24gbW9iaWxlIGRldmljZXMgd2hlcmUgZXh0cmFcbiAgICogb3ZlcmhlYWQgaXMgZXNwZWNpYWxseSBiYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0VGFwRXZlbnRzKCl7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgbGV0IHRvdWNoU3RhcnQgPSAwO1xuICAgIGxldCBmaXJzdFRvdWNoID0gbnVsbDtcblxuICAgIC8vIE1heGltdW0gbW92ZW1lbnQgYWxsb3dlZCBkdXJpbmcgYSB0b3VjaCBldmVudCB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgdGFwXG4gICAgLy8gT3RoZXIgcG9wdWxhciBsaWJzIHVzZSBhbnl3aGVyZSBmcm9tIDIgKGhhbW1lci5qcykgdG8gMTUsIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgY29uc3QgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgY29uc3QgdG91Y2hUaW1lVGhyZXNob2xkID0gMjAwO1xuXG4gICAgbGV0IGNvdWxkQmVUYXA7XG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIGZpbmdlciwgZG9uJ3QgY29uc2lkZXIgdHJlYXRpbmcgdGhpcyBhcyBhIGNsaWNrXG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmlyc3RUb3VjaCA9IExpYi5vYmouY29weShldmVudC50b3VjaGVzWzBdKTtcbiAgICAgICAgLy8gUmVjb3JkIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVjdCBhIHRhcCB2cy4gXCJ0b3VjaCBhbmQgaG9sZFwiXG4gICAgICAgIHRvdWNoU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xuICAgICAgICBjb3VsZEJlVGFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIGZpbmdlciwgZG9uJ3QgY29uc2lkZXIgdHJlYXRpbmcgdGhpcyBhcyBhIGNsaWNrXG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RUb3VjaCkge1xuICAgICAgICAvLyBTb21lIGRldmljZXMgd2lsbCB0aHJvdyB0b3VjaG1vdmVzIGZvciBhbGwgYnV0IHRoZSBzbGlnaHRlc3Qgb2YgdGFwcy5cbiAgICAgICAgLy8gU28sIGlmIHdlIG1vdmVkIG9ubHkgYSBzbWFsbCBkaXN0YW5jZSwgdGhpcyBjb3VsZCBzdGlsbCBiZSBhIHRhcFxuICAgICAgICBjb25zdCB4ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBmaXJzdFRvdWNoLnBhZ2VYO1xuICAgICAgICBjb25zdCB5ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBmaXJzdFRvdWNoLnBhZ2VZO1xuICAgICAgICBjb25zdCB0b3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9UYXAgPSBmdW5jdGlvbigpe1xuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgIH07XG4gICAgLy8gVE9ETzogTGlzdGVuIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQuIGh0dHA6Ly95b3V0dS5iZS9EdWpmcFhPS1VwOD90PTEzbThzXG4gICAgdGhpcy5vbigndG91Y2hsZWF2ZScsIG5vVGFwKTtcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIG5vVGFwKTtcblxuICAgIC8vIFdoZW4gdGhlIHRvdWNoIGVuZHMsIG1lYXN1cmUgaG93IGxvbmcgaXQgdG9vayBhbmQgdHJpZ2dlciB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBldmVudFxuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICBjb25zdCB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG91Y2ggd2FzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAgICAgaWYgKHRvdWNoVGltZSA8IHRvdWNoVGltZVRocmVzaG9sZCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RhcCcpO1xuICAgICAgICAgIC8vIEl0IG1heSBiZSBnb29kIHRvIGNvcHkgdGhlIHRvdWNoZW5kIGV2ZW50IG9iamVjdCBhbmQgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIHR5cGUgdG8gdGFwLCBpZiB0aGUgb3RoZXIgZXZlbnQgcHJvcGVydGllcyBhcmVuJ3QgZXhhY3QgYWZ0ZXJcbiAgICAgICAgICAvLyBMaWIuZml4RXZlbnQgcnVucyAoZS5nLiBldmVudC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBvcnQgdXNlciB0b3VjaCBhY3Rpdml0eSB3aGVuIHRvdWNoIGV2ZW50cyBvY2N1clxuICAgKlxuICAgKiBVc2VyIGFjdGl2aXR5IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gY29udHJvbHMgc2hvdWxkIHNob3cvaGlkZS4gSXQnc1xuICAgKiByZWxhdGl2ZWx5IHNpbXBsZSB3aGVuIGl0IGNvbWVzIHRvIG1vdXNlIGV2ZW50cywgYmVjYXVzZSBhbnkgbW91c2UgZXZlbnRcbiAgICogc2hvdWxkIHNob3cgdGhlIGNvbnRyb2xzLiBTbyB3ZSBjYXB0dXJlIG1vdXNlIGV2ZW50cyB0aGF0IGJ1YmJsZSB1cCB0byB0aGVcbiAgICogcGxheWVyIGFuZCByZXBvcnQgYWN0aXZpdHkgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIFdpdGggdG91Y2ggZXZlbnRzIGl0IGlzbid0IGFzIGVhc3kuIFdlIGNhbid0IHJlbHkgb24gdG91Y2ggZXZlbnRzIGF0IHRoZVxuICAgKiBwbGF5ZXIgbGV2ZWwsIGJlY2F1c2UgYSB0YXAgKHRvdWNoc3RhcnQgKyB0b3VjaGVuZCkgb24gdGhlIHZpZGVvIGl0c2VsZiBvblxuICAgKiBtb2JpbGUgZGV2aWNlcyBpcyBtZWFudCB0byB0dXJuIGNvbnRyb2xzIG9mZiAoYW5kIG9uKS4gVXNlciBhY3Rpdml0eSBpc1xuICAgKiBjaGVja2VkIGFzeW5jaHJvbm91c2x5LCBzbyB3aGF0IGNvdWxkIGhhcHBlbiBpcyBhIHRhcCBldmVudCBvbiB0aGUgdmlkZW9cbiAgICogdHVybnMgdGhlIGNvbnRyb2xzIG9mZiwgdGhlbiB0aGUgdG91Y2hlbmQgZXZlbnQgYnViYmxlcyB1cCB0byB0aGUgcGxheWVyLFxuICAgKiB3aGljaCBpZiBpdCByZXBvcnRlZCB1c2VyIGFjdGl2aXR5LCB3b3VsZCB0dXJuIHRoZSBjb250cm9scyByaWdodCBiYWNrIG9uLlxuICAgKiAoV2UgYWxzbyBkb24ndCB3YW50IHRvIGNvbXBsZXRlbHkgYmxvY2sgdG91Y2ggZXZlbnRzIGZyb20gYnViYmxpbmcgdXApXG4gICAqXG4gICAqIEFsc28gYSB0b3VjaG1vdmUsIHRvdWNoK2hvbGQsIGFuZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgdGFwIGlzIG5vdCBzdXBwb3NlZFxuICAgKiB0byB0dXJuIHRoZSBjb250cm9scyBiYWNrIG9uIG9uIGEgbW9iaWxlIGRldmljZS5cbiAgICpcbiAgICogSGVyZSB3ZSdyZSBzZXR0aW5nIHRoZSBkZWZhdWx0IGNvbXBvbmVudCBiZWhhdmlvciB0byByZXBvcnQgdXNlciBhY3Rpdml0eVxuICAgKiB3aGVuZXZlciB0b3VjaCBldmVudHMgaGFwcGVuLCBhbmQgdGhpcyBjYW4gYmUgdHVybmVkIG9mZiBieSBjb21wb25lbnRzIHRoYXRcbiAgICogd2FudCB0b3VjaCBldmVudHMgdG8gYWN0IGRpZmZlcmVudGx5LlxuICAgKi9cbiAgZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcbiAgICAvLyBEb24ndCBjb250aW51ZSBpZiB0aGUgcm9vdCBwbGF5ZXIgZG9lc24ndCBzdXBwb3J0IHJlcG9ydGluZyB1c2VyIGFjdGl2aXR5XG4gICAgaWYgKCF0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICBjb25zdCByZXBvcnQgPSBMaWIuYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICBsZXQgdG91Y2hIb2xkaW5nO1xuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aW1lb3V0IGFuZCBzZXRzIHVwIGRpc3Bvc2FsIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IE51bWJlciBvZiBtcyB0byBkZWxheSBiZWZvcmUgZXhlY3V0aW5nIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lb3V0IElEXG4gICAqL1xuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgZm4gPSBMaWIuYmluZCh0aGlzLCBmbik7XG5cbiAgICAvLyB3aW5kb3cuc2V0VGltZW91dCB3b3VsZCBiZSBwcmVmZXJhYmxlIGhlcmUsIGJ1dCBkdWUgdG8gc29tZSBiaXphcnJlIGlzc3VlIHdpdGggU2lub24gYW5kL29yIFBoYW50b21qcywgd2UgY2FuJ3QuXG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSBgdmpzLXRpbWVvdXQtJHt0aW1lb3V0SWR9YDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENsZWFycyBhIHRpbWVvdXQgYW5kIHJlbW92ZXMgdGhlIGFzc29jaWF0ZWQgZGlzcG9zZSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dElkIFRoZSBpZCBvZiB0aGUgdGltZW91dCB0byBjbGVhclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHRpbWVvdXQgSURcbiAgICovXG4gIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbigpe307XG4gICAgZGlzcG9zZUZuLmd1aWQgPSBgdmpzLXRpbWVvdXQtJHt0aW1lb3V0SWR9YDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnRlcnZhbCBhbmQgc2V0cyB1cCBkaXNwb3NhbCBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGV2ZXJ5IE4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIE51bWJlciBvZiBtcyB0byBkZWxheSBiZWZvcmUgZXhlY3V0aW5nIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbnRlcnZhbCBJRFxuICAgKi9cbiAgc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgZm4gPSBMaWIuYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZuLCBpbnRlcnZhbCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gYHZqcy1pbnRlcnZhbC0ke2ludGVydmFsSWR9YDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFuIGludGVydmFsIGFuZCByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsSWQgVGhlIGlkIG9mIHRoZSBpbnRlcnZhbCB0byBjbGVhclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGludGVydmFsIElEXG4gICAqL1xuICBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCl7fTtcbiAgICBkaXNwb3NlRm4uZ3VpZCA9IGB2anMtaW50ZXJ2YWwtJHtpbnRlcnZhbElkfWA7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb21wKXtcbiAgICBpZiAoIUNvbXBvbmVudC5jb21wb25lbnRzXykge1xuICAgICAgQ29tcG9uZW50LmNvbXBvbmVudHNfID0ge307XG4gICAgfVxuXG4gICAgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdID0gY29tcDtcbiAgICByZXR1cm4gY29tcDtcbiAgfVxuXG4gIHN0YXRpYyBnZXRDb21wb25lbnQobmFtZSl7XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cudmlkZW9qcyAmJiB3aW5kb3cudmlkZW9qc1tuYW1lXSkge1xuICAgICAgTGliLmxvZy53YXJuKGBUaGUgJHtuYW1lfSBjb21wb25lbnQgd2FzIGFkZGVkIHRvIHRoZSB2aWRlb2pzIG9iamVjdCB3aGVuIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQobmFtZSwgY29tcG9uZW50KWApO1xuICAgICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQocHJvcHMpe1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgLy8gU2V0IHVwIHRoZSBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc3VwcGxpZWQgaW5pdCBtZXRob2RcbiAgICAvLyBvciB1c2luZyB0aGUgaW5pdCBvZiB0aGUgcGFyZW50IG9iamVjdFxuICAgIC8vIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgdW5vYmZ1c2NhdGVkIHZlcnNpb24gZm9yIGV4dGVybmFsIGxpYnNcbiAgICBsZXQgaW5pdCA9IHByb3BzWydpbml0J10gfHwgcHJvcHMuaW5pdCB8fCB0aGlzLnByb3RvdHlwZVsnaW5pdCddIHx8IHRoaXMucHJvdG90eXBlLmluaXQgfHwgZnVuY3Rpb24oKXt9O1xuICAgIC8vIEluIFJlc2lnJ3Mgc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlIChwcmV2aW91c2x5IHVzZWQpIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vICBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgYHRoaXMuaW5pdC5hcHBseShhcmd1bWVudHMpYFxuICAgIC8vIEhvd2V2ZXIgdGhhdCB3b3VsZCBwcmV2ZW50IHVzIGZyb20gdXNpbmcgYFBhcmVudE9iamVjdC5jYWxsKHRoaXMpO2BcbiAgICAvLyAgaW4gYSBDaGlsZCBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZSBgdGhpc2AgaW4gYHRoaXMuaW5pdGBcbiAgICAvLyAgd291bGQgc3RpbGwgcmVmZXIgdG8gdGhlIENoaWxkIGFuZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLlxuICAgIC8vIFdlIHdvdWxkIGluc3RlYWQgaGF2ZSB0byBkb1xuICAgIC8vICAgIGBQYXJlbnRPYmplY3QucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtgXG4gICAgLy8gIEJsZWguIFdlJ3JlIG5vdCBjcmVhdGluZyBhIF9zdXBlcigpIGZ1bmN0aW9uLCBzbyBpdCdzIGdvb2QgdG8ga2VlcFxuICAgIC8vICB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHJlZmVyZW5jZSBzaW1wbGUuXG4gICAgbGV0IHN1Yk9iaiA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSB0aGlzIG9iamVjdCdzIHByb3RvdHlwZVxuICAgIHN1Yk9iai5wcm90b3R5cGUgPSBMaWIub2JqLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgLy8gUmVzZXQgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5IGZvciBzdWJPYmogb3RoZXJ3aXNlXG4gICAgLy8gaW5zdGFuY2VzIG9mIHN1Yk9iaiB3b3VsZCBoYXZlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGFyZW50IE9iamVjdFxuICAgIHN1Yk9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJPYmo7XG5cbiAgICAvLyBNYWtlIHRoZSBjbGFzcyBleHRlbmRhYmxlXG4gICAgc3ViT2JqLmV4dGVuZCA9IENvbXBvbmVudC5leHRlbmQ7XG4gICAgLy8gTWFrZSBhIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBpbnN0YW5jZXNcbiAgICAvLyBzdWJPYmouY3JlYXRlID0gQ29yZU9iamVjdC5jcmVhdGU7XG5cbiAgICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgICBmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgc3ViT2JqLnByb3RvdHlwZVtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWJPYmo7XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb21wb25lbnQnLCBDb21wb25lbnQpO1xuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYi5qcyc7XG5cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG5pbXBvcnQgUGxheVRvZ2dsZSBmcm9tICcuL3BsYXktdG9nZ2xlLmpzJztcbmltcG9ydCBDdXJyZW50VGltZURpc3BsYXkgZnJvbSAnLi90aW1lLWNvbnRyb2xzL2N1cnJlbnQtdGltZS1kaXNwbGF5LmpzJztcbmltcG9ydCBEdXJhdGlvbkRpc3BsYXkgZnJvbSAnLi90aW1lLWNvbnRyb2xzL2R1cmF0aW9uLWRpc3BsYXkuanMnO1xuaW1wb3J0IFRpbWVEaXZpZGVyIGZyb20gJy4vdGltZS1jb250cm9scy90aW1lLWRpdmlkZXIuanMnO1xuaW1wb3J0IFJlbWFpbmluZ1RpbWVEaXNwbGF5IGZyb20gJy4vdGltZS1jb250cm9scy9yZW1haW5pbmctdGltZS1kaXNwbGF5LmpzJztcbmltcG9ydCBMaXZlRGlzcGxheSBmcm9tICcuL2xpdmUtZGlzcGxheS5qcyc7XG5pbXBvcnQgUHJvZ3Jlc3NDb250cm9sIGZyb20gJy4vcHJvZ3Jlc3MtY29udHJvbC9wcm9ncmVzcy1jb250cm9sLmpzJztcbmltcG9ydCBGdWxsc2NyZWVuVG9nZ2xlIGZyb20gJy4vZnVsbHNjcmVlbi10b2dnbGUuanMnO1xuaW1wb3J0IFZvbHVtZUNvbnRyb2wgZnJvbSAnLi92b2x1bWUtY29udHJvbC92b2x1bWUtY29udHJvbC5qcyc7XG5pbXBvcnQgVm9sdW1lTWVudUJ1dHRvbiBmcm9tICcuL3ZvbHVtZS1tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgTXV0ZVRvZ2dsZSBmcm9tICcuL211dGUtdG9nZ2xlLmpzJztcbmltcG9ydCBDaGFwdGVyc0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stY29udHJvbHMvY2hhcHRlcnMtYnV0dG9uLmpzJztcbmltcG9ydCBTdWJ0aXRsZXNCdXR0b24gZnJvbSAnLi90ZXh0LXRyYWNrLWNvbnRyb2xzL3N1YnRpdGxlcy1idXR0b24uanMnO1xuaW1wb3J0IENhcHRpb25zQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1jb250cm9scy9jYXB0aW9ucy1idXR0b24uanMnO1xuaW1wb3J0IFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gZnJvbSAnLi9wbGF5YmFjay1yYXRlLW1lbnUvcGxheWJhY2stcmF0ZS1tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgQ3VzdG9tQ29udHJvbFNwYWNlciBmcm9tICcuL3NwYWNlci1jb250cm9scy9jdXN0b20tY29udHJvbC1zcGFjZXIuanMnO1xuXG4vKipcbiAqIENvbnRhaW5lciBvZiBtYWluIGNvbnRyb2xzXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmNsYXNzIENvbnRyb2xCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1iYXInXG4gICAgfSk7XG4gIH1cbn1cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGxvYWRFdmVudDogJ3BsYXknLFxuICBjaGlsZHJlbjogW1xuICAgICdwbGF5VG9nZ2xlJyxcbiAgICAnY3VycmVudFRpbWVEaXNwbGF5JyxcbiAgICAndGltZURpdmlkZXInLFxuICAgICdkdXJhdGlvbkRpc3BsYXknLFxuICAgICdwcm9ncmVzc0NvbnRyb2wnLFxuICAgICdsaXZlRGlzcGxheScsXG4gICAgJ3JlbWFpbmluZ1RpbWVEaXNwbGF5JyxcbiAgICAnY3VzdG9tQ29udHJvbFNwYWNlcicsXG4gICAgJ3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLFxuICAgICdtdXRlVG9nZ2xlJyxcbiAgICAndm9sdW1lQ29udHJvbCcsXG4gICAgJ2NoYXB0ZXJzQnV0dG9uJyxcbiAgICAnc3VidGl0bGVzQnV0dG9uJyxcbiAgICAnY2FwdGlvbnNCdXR0b24nLFxuICAgICd2b2x1bWVNZW51QnV0dG9uJyxcbiAgICAnZnVsbHNjcmVlblRvZ2dsZSdcbiAgXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5leHBvcnQgZGVmYXVsdCBDb250cm9sQmFyO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24nO1xuXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIHZqcy5CdXR0b25cbiAqL1xuY2xhc3MgRnVsbHNjcmVlblRvZ2dsZSBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1mdWxsc2NyZWVuLWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIG9uQ2xpY2soKSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgdGhpcy5jb250cm9sVGV4dF8uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB0aGlzLmNvbnRyb2xUZXh0Xy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCdGdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9XG5cbn1cblxuRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuYnV0dG9uVGV4dCA9ICdGdWxsc2NyZWVuJztcblxuQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5leHBvcnQgZGVmYXVsdCBGdWxsc2NyZWVuVG9nZ2xlO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGxpdmUgaW5kaWNhdG9yXG4gKiBUT0RPIC0gRnV0dXJlIG1ha2UgaXQgY2xpY2sgdG8gc25hcCB0byBsaXZlXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTGl2ZURpc3BsYXkgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1kaXNwbGF5JyxcbiAgICAgIGlubmVySFRNTDogYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7dGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKX08L3NwYW4+JHt0aGlzLmxvY2FsaXplKCdMSVZFJyl9YCxcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XG5leHBvcnQgZGVmYXVsdCBMaXZlRGlzcGxheTtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi9saWInO1xuXG4vKipcbiAqIEEgYnV0dG9uIGNvbXBvbmVudCBmb3IgbXV0aW5nIHRoZSBhdWRpb1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNdXRlVG9nZ2xlIGV4dGVuZHMgQnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd2b2x1bWVjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XG5cbiAgICAvLyBoaWRlIG11dGUgdG9nZ2xlIGlmIHRoZSBjdXJyZW50IHRlY2ggZG9lc24ndCBzdXBwb3J0IHZvbHVtZSBjb250cm9sXG4gICAgaWYgKHBsYXllci50ZWNoICYmIHBsYXllci50ZWNoWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAocGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tdXRlLWNvbnRyb2wgdmpzLWNvbnRyb2wnLFxuICAgICAgaW5uZXJIVE1MOiBgPGRpdj48c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ011dGUnKX08L3NwYW4+PC9kaXY+YFxuICAgIH0pO1xuICB9XG5cbiAgb25DbGljaygpIHtcbiAgICB0aGlzLnBsYXllcl8ubXV0ZWQoIHRoaXMucGxheWVyXy5tdXRlZCgpID8gZmFsc2UgOiB0cnVlICk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKSxcbiAgICAgICAgbGV2ZWwgPSAzO1xuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIERvbid0IHJld3JpdGUgdGhlIGJ1dHRvbiB0ZXh0IGlmIHRoZSBhY3R1YWwgdGV4dCBkb2Vzbid0IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNhdXNlcyB1bm5lY2Vzc2FyeSBhbmQgY29uZnVzaW5nIGluZm9ybWF0aW9uIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB2b2x1bWUgbGV2ZWwgaXMgY2hhbmdlZC5cbiAgICBsZXQgdG9NdXRlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAnVW5tdXRlJyA6ICdNdXRlJztcbiAgICBsZXQgbG9jYWxpemVkTXV0ZSA9IHRoaXMubG9jYWxpemUodG9NdXRlKTtcbiAgICBpZiAodGhpcy5lbF8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MICE9PSBsb2NhbGl6ZWRNdXRlKSB7XG4gICAgICB0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBsb2NhbGl6ZWRNdXRlO1xuICAgIH1cblxuICAgIC8qIFRPRE8gaW1wcm92ZSBtdXRlZCBpY29uIGNsYXNzZXMgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgTGliLnJlbW92ZUNsYXNzKHRoaXMuZWxfLCBgdmpzLXZvbC0ke2l9YCk7XG4gICAgfVxuICAgIExpYi5hZGRDbGFzcyh0aGlzLmVsXywgYHZqcy12b2wtJHtsZXZlbH1gKTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuZXhwb3J0IGRlZmF1bHQgTXV0ZVRvZ2dsZTtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi9saWInO1xuXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUGxheVRvZ2dsZSBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdwbGF5JywgdGhpcy5vblBsYXkpO1xuICAgIHRoaXMub24ocGxheWVyLCAncGF1c2UnLCB0aGlzLm9uUGF1c2UpO1xuICB9XG5cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1wbGF5LWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIC8vIE9uQ2xpY2sgLSBUb2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZVxuICBvbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9uUGxheSAtIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlXG4gIG9uUGxheSgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCdQYXVzZScpOyAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGF1c2VcIlxuICB9XG5cbiAgLy8gT25QYXVzZSAtIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2VcbiAgb25QYXVzZSgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCdQbGF5Jyk7IC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcbiAgfVxuXG59XG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnUGxheSc7XG5cbkJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnUGxheVRvZ2dsZScsIFBsYXlUb2dnbGUpO1xuZXhwb3J0IGRlZmF1bHQgUGxheVRvZ2dsZTtcbiIsImltcG9ydCBNZW51QnV0dG9uIGZyb20gJy4uLy4uL21lbnUvbWVudS1idXR0b24uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCBQbGF5YmFja1JhdGVNZW51SXRlbSBmcm9tICcuL3BsYXliYWNrLXJhdGUtbWVudS1pdGVtLmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwbGF5YmFjayByYXRlXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gZXh0ZW5kcyBNZW51QnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIHRoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgdGhpcy51cGRhdGVMYWJlbCk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSBzdXBlci5jcmVhdGVFbCgpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXliYWNrLXJhdGUtdmFsdWUnLFxuICAgICAgaW5uZXJIVE1MOiAxLjBcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gTWVudSBjcmVhdGlvblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XG4gICAgbGV0IHJhdGVzID0gdGhpcy5wbGF5ZXIoKS5vcHRpb25zKClbJ3BsYXliYWNrUmF0ZXMnXTtcblxuICAgIGlmIChyYXRlcykge1xuICAgICAgZm9yIChsZXQgaSA9IHJhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG1lbnUuYWRkQ2hpbGQoXG4gICAgICAgICAgbmV3IFBsYXliYWNrUmF0ZU1lbnVJdGVtKHRoaXMucGxheWVyKCksIHsgJ3JhdGUnOiByYXRlc1tpXSArICd4J30pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxuICB1cGRhdGVBUklBQXR0cmlidXRlcygpIHtcbiAgICAvLyBDdXJyZW50IHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSk7XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIC8vIHNlbGVjdCBuZXh0IHJhdGUgb3B0aW9uXG4gICAgbGV0IGN1cnJlbnRSYXRlID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKTtcbiAgICBsZXQgcmF0ZXMgPSB0aGlzLnBsYXllcigpLm9wdGlvbnMoKVsncGxheWJhY2tSYXRlcyddO1xuICAgIC8vIHRoaXMgd2lsbCBzZWxlY3QgZmlyc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICBsZXQgbmV3UmF0ZSA9IHJhdGVzWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDxyYXRlcy5sZW5ndGggOyBpKyspIHtcbiAgICAgIGlmIChyYXRlc1tpXSA+IGN1cnJlbnRSYXRlKSB7XG4gICAgICAgIG5ld1JhdGUgPSByYXRlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKG5ld1JhdGUpO1xuICB9XG5cbiAgcGxheWJhY2tSYXRlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcigpLnRlY2hcbiAgICAgICYmIHRoaXMucGxheWVyKCkudGVjaFsnZmVhdHVyZXNQbGF5YmFja1JhdGUnXVxuICAgICAgJiYgdGhpcy5wbGF5ZXIoKS5vcHRpb25zKClbJ3BsYXliYWNrUmF0ZXMnXVxuICAgICAgJiYgdGhpcy5wbGF5ZXIoKS5vcHRpb25zKClbJ3BsYXliYWNrUmF0ZXMnXS5sZW5ndGggPiAwXG4gICAgO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgcGxheWJhY2sgcmF0ZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm8gcGxheWJhY2sgcmF0ZSBvcHRpb25zIHRvIHNlbGVjdFxuICAgKi9cbiAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBidXR0b24gbGFiZWwgd2hlbiByYXRlIGNoYW5nZWRcbiAgICovXG4gIHVwZGF0ZUxhYmVsKCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLmxhYmVsRWxfLmlubmVySFRNTCA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgKyAneCc7XG4gICAgfVxuICB9XG5cbn1cblxuUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnV0dG9uVGV4dCA9ICdQbGF5YmFjayBSYXRlJztcblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtcGxheWJhY2stcmF0ZSc7XG5cbk1lbnVCdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG4iLCJpbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi4vLi4vbWVudS9tZW51LWl0ZW0uanMnO1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgcGxheWJhY2sgcmF0ZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5YmFja1JhdGVNZW51SXRlbSBleHRlbmRzIE1lbnVJdGVtIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIGxldCBsYWJlbCA9IG9wdGlvbnNbJ3JhdGUnXTtcbiAgICBsZXQgcmF0ZSA9IHBhcnNlRmxvYXQobGFiZWwsIDEwKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBsYWJlbDtcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gcmF0ZSA9PT0gMTtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucmF0ZSA9IHJhdGU7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIHN1cGVyLm9uQ2xpY2soKTtcbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSh0aGlzLnJhdGUpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSA9PSB0aGlzLnJhdGUpO1xuICB9XG5cbn1cblxuUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmNvbnRlbnRFbFR5cGUgPSAnYnV0dG9uJztcblxuTWVudUl0ZW0ucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVJdGVtJywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgUGxheWJhY2tSYXRlTWVudUl0ZW07IiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8qKlxuICogU2hvd3MgbG9hZCBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBMb2FkUHJvZ3Jlc3NCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3Byb2dyZXNzJywgdGhpcy51cGRhdGUpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZC1wcm9ncmVzcycsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4ke3RoaXMubG9jYWxpemUoJ0xvYWRlZCcpfTwvc3Bhbj46IDAlPC9zcGFuPmBcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICBsZXQgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICBsZXQgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmVsXy5jaGlsZHJlbjtcblxuICAgIC8vIGdldCB0aGUgcGVyY2VudCB3aWR0aCBvZiBhIHRpbWUgY29tcGFyZWQgdG8gdGhlIHRvdGFsIGVuZFxuICAgIGxldCBwZXJjZW50aWZ5ID0gZnVuY3Rpb24gKHRpbWUsIGVuZCl7XG4gICAgICBsZXQgcGVyY2VudCA9ICh0aW1lIC8gZW5kKSB8fCAwOyAvLyBubyBOYU5cbiAgICAgIHJldHVybiAocGVyY2VudCAqIDEwMCkgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgbGV0IGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIGxldCBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoTGliLmNyZWF0ZUVsKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHBlcmNlbnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIgKGJ1ZmZlcmVkRW5kKVxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgICAgcGFydC5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoZW5kIC0gc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW51c2VkIGJ1ZmZlcmVkIHJhbmdlIGVsZW1lbnRzXG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgaS0tKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltpLTFdKTtcbiAgICB9XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5leHBvcnQgZGVmYXVsdCBMb2FkUHJvZ3Jlc3NCYXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogU2hvd3MgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5UHJvZ3Jlc3NCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXktcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JHt0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpfTwvc3Bhbj46IDAlPC9zcGFuPmBcbiAgICB9KTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVByb2dyZXNzQmFyJywgUGxheVByb2dyZXNzQmFyKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXlQcm9ncmVzc0JhcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCBTZWVrQmFyIGZyb20gJy4vc2Vlay1iYXIuanMnO1xuXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQcm9ncmVzc0NvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuICB9XG59XG5cblByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ3NlZWtCYXInOiB7fVxuICB9XG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Byb2dyZXNzQ29udHJvbCcsIFByb2dyZXNzQ29udHJvbCk7XG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzc0NvbnRyb2w7XG4iLCJpbXBvcnQgU2xpZGVyIGZyb20gJy4uLy4uL3NsaWRlci9zbGlkZXIuanMnO1xuaW1wb3J0IExvYWRQcm9ncmVzc0JhciBmcm9tICcuL2xvYWQtcHJvZ3Jlc3MtYmFyLmpzJztcbmltcG9ydCBQbGF5UHJvZ3Jlc3NCYXIgZnJvbSAnLi9wbGF5LXByb2dyZXNzLWJhci5qcyc7XG5pbXBvcnQgU2Vla0hhbmRsZSBmcm9tICcuL3NlZWstaGFuZGxlLmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIFNlZWsgQmFyIGFuZCBob2xkZXIgZm9yIHRoZSBwcm9ncmVzcyBiYXJzXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFNlZWtCYXIgZXh0ZW5kcyBTbGlkZXIge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcbiAgICBwbGF5ZXIucmVhZHkoTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcykpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtaG9sZGVyJyxcbiAgICAgICdhcmlhLWxhYmVsJzogJ3ZpZGVvIHByb2dyZXNzIGJhcidcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgICAgbGV0IHRpbWUgPSAodGhpcy5wbGF5ZXJfLnNjcnViYmluZygpKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBMaWIucm91bmQodGhpcy5nZXRQZXJjZW50KCkqMTAwLCAyKSk7IC8vIG1hY2hpbmUgcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyIChwZXJjZW50YWdlIGNvbXBsZXRlKVxuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIExpYi5mb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSk7IC8vIGh1bWFuIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAodGltZSBjb21wbGV0ZSlcbiAgfVxuXG4gIGdldFBlcmNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gIH1cblxuICBvbk1vdXNlRG93bihldmVudCkge1xuICAgIHN1cGVyLm9uTW91c2VEb3duKGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcodHJ1ZSk7XG5cbiAgICB0aGlzLnZpZGVvV2FzUGxheWluZyA9ICF0aGlzLnBsYXllcl8ucGF1c2VkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIGxldCBuZXdUaW1lID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShldmVudCkgKiB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIERvbid0IGxldCB2aWRlbyBlbmQgd2hpbGUgc2NydWJiaW5nLlxuICAgIGlmIChuZXdUaW1lID09IHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7IG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xOyB9XG5cbiAgICAvLyBTZXQgbmV3IHRpbWUgKHRlbGwgcGxheWVyIHRvIHNlZWsgdG8gbmV3IHRpbWUpXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgc3VwZXIub25Nb3VzZVVwKGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICBzdGVwRm9yd2FyZCgpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgKyA1KTsgLy8gbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICB9XG5cbiAgc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC0gNSk7IC8vIG1vcmUgcXVpY2tseSByZXdpbmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcbiAgfVxuXG59XG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjoge1xuICAgICdsb2FkUHJvZ3Jlc3NCYXInOiB7fSxcbiAgICAncGxheVByb2dyZXNzQmFyJzoge30sXG4gICAgJ3NlZWtIYW5kbGUnOiB7fVxuICB9LFxuICAnYmFyTmFtZSc6ICdwbGF5UHJvZ3Jlc3NCYXInLFxuICAnaGFuZGxlTmFtZSc6ICdzZWVrSGFuZGxlJ1xufTtcblxuU2Vla0Jhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndGltZXVwZGF0ZSc7XG5cblNsaWRlci5yZWdpc3RlckNvbXBvbmVudCgnU2Vla0JhcicsIFNlZWtCYXIpO1xuZXhwb3J0IGRlZmF1bHQgU2Vla0JhcjtcbiIsImltcG9ydCBTbGlkZXJIYW5kbGUgZnJvbSAnLi4vLi4vc2xpZGVyL3NsaWRlci1oYW5kbGUuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8qKlxuICogVGhlIFNlZWsgSGFuZGxlIHNob3dzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBkdXJpbmcgcGxheWJhY2ssXG4gKiBhbmQgY2FuIGJlIGRyYWdnZWQgdG8gYWRqdXN0IHRoZSBwbGF5aGVhZC5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2Vla0hhbmRsZSBleHRlbmRzIFNsaWRlckhhbmRsZSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXNlZWstaGFuZGxlJyxcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQ29udGVudCgpIHtcbiAgICBsZXQgdGltZSA9ICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5lbF8uaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7TGliLmZvcm1hdFRpbWUodGltZSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpfTwvc3Bhbj5gO1xuICB9XG5cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGhhbmRsZSBjb250ZW50LCB3aGljaCBtYXkgYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TZWVrSGFuZGxlLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSAnMDA6MDAnO1xuXG5TbGlkZXJIYW5kbGUucmVnaXN0ZXJDb21wb25lbnQoJ1NlZWtIYW5kbGUnLCBTZWVrSGFuZGxlKTtcbmV4cG9ydCBkZWZhdWx0IFNlZWtIYW5kbGU7XG4iLCJpbXBvcnQgU3BhY2VyIGZyb20gJy4vc3BhY2VyLmpzJztcblxuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iZWN0PX0gb3B0aW9uc1xuICovXG5jbGFzcyBDdXN0b21Db250cm9sU3BhY2VyIGV4dGVuZHMgU3BhY2VyIHtcbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1jdXN0b20tY29udHJvbC1zcGFjZXIgJHtzdXBlci5idWlsZENTU0NsYXNzfWA7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoe1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9XG59XG5cblNwYWNlci5yZWdpc3RlckNvbXBvbmVudCgnQ3VzdG9tQ29udHJvbFNwYWNlcicsIEN1c3RvbUNvbnRyb2xTcGFjZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDdXN0b21Db250cm9sU3BhY2VyO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIEp1c3QgYW4gZW1wdHkgc3BhY2VyIGVsZW1lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcHBlbmQgcG9pbnQgZm9yIHBsdWdpbnMsIGV0Yy5cbiAqIEFsc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICovXG5jbGFzcyBTcGFjZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBgdmpzLXNwYWNlciAke3N1cGVyLmJ1aWxkQ1NTQ2xhc3MoKX1gO1xuICB9XG5cbiAgY3JlYXRlRWwocHJvcHMpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcbiAgfVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NwYWNlcicsIFNwYWNlcik7XG5cbmV4cG9ydCBkZWZhdWx0IFNwYWNlcjtcbiIsImltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcblxuY2xhc3MgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9uc1sndHJhY2snXSA9IHtcbiAgICAgICdraW5kJzogb3B0aW9uc1sna2luZCddLFxuICAgICAgJ3BsYXllcic6IHBsYXllcixcbiAgICAgICdsYWJlbCc6IG9wdGlvbnNbJ2tpbmQnXSArICcgc2V0dGluZ3MnLFxuICAgICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAgIG1vZGU6ICdkaXNhYmxlZCdcbiAgICB9O1xuXG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtdGV4dHRyYWNrLXNldHRpbmdzJyk7XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykuc2hvdygpO1xuICB9XG5cbn1cblxuVGV4dFRyYWNrTWVudUl0ZW0ucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW07IiwiaW1wb3J0IFRleHRUcmFja0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stYnV0dG9uLmpzJztcbmltcG9ydCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBmcm9tICcuL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzJztcblxuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYXB0aW9uc0J1dHRvbiBleHRlbmRzIFRleHRUcmFja0J1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywnQ2FwdGlvbnMgTWVudScpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGxldCB0aHJlc2hvbGQgPSAyO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgLy8gaWYgbmF0aXZlLCB0aGVuIHRocmVzaG9sZCBpcyAxIGJlY2F1c2Ugbm8gc2V0dGluZ3MgYnV0dG9uXG4gICAgaWYgKHRoaXMucGxheWVyKCkudGVjaCAmJiB0aGlzLnBsYXllcigpLnRlY2hbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlSXRlbXMoKSB7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2ggJiYgdGhpcy5wbGF5ZXIoKS50ZWNoWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyAna2luZCc6IHRoaXMua2luZF8gfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcyhpdGVtcyk7XG4gIH1cblxufVxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnQ2FwdGlvbnMnO1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtY2FwdGlvbnMtYnV0dG9uJztcblxuVGV4dFRyYWNrQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uc0J1dHRvbicsIENhcHRpb25zQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IENhcHRpb25zQnV0dG9uO1xuIiwiaW1wb3J0IFRleHRUcmFja0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stYnV0dG9uLmpzJztcbmltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcbmltcG9ydCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0gZnJvbSAnLi9jaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuLy8gQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuLy8gQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGFwdGVyc0J1dHRvbiBleHRlbmRzIFRleHRUcmFja0J1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywnQ2hhcHRlcnMgTWVudScpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgY3JlYXRlSXRlbXMoKSB7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBsZXQgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgIGlmICh0cmFja1sna2luZCddID09PSB0aGlzLmtpbmRfKSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IFRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IHRyYWNrXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpIHx8IFtdO1xuICAgIGxldCBjaGFwdGVyc1RyYWNrO1xuICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT0gdGhpcy5raW5kXykge1xuICAgICAgICBpZiAoIXRyYWNrLmN1ZXMpIHtcbiAgICAgICAgICB0cmFja1snbW9kZSddID0gJ2hpZGRlbic7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gZmlndXJlIG91dCBhIGJldHRlciB3YXkgb2YgZG9pbmcgdGhpcyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMTg2NFxuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNZW51KCk7XG4gICAgICAgICAgfSksIDEwMCk7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOmZhbHNlICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcHRlcnNUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1lbnUgPSB0aGlzLm1lbnU7XG4gICAgaWYgKG1lbnUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXyk7XG4gICAgICBtZW51LmNvbnRlbnRFbCgpLmFwcGVuZENoaWxkKExpYi5jcmVhdGVFbCgnbGknLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LXRpdGxlJyxcbiAgICAgICAgaW5uZXJIVE1MOiBMaWIuY2FwaXRhbGl6ZSh0aGlzLmtpbmRfKSxcbiAgICAgICAgdGFiaW5kZXg6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYXB0ZXJzVHJhY2spIHtcbiAgICAgIGxldCBjdWVzID0gY2hhcHRlcnNUcmFja1snY3VlcyddLCBjdWU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgICBsZXQgbWkgPSBuZXcgQ2hhcHRlcnNUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IGNoYXB0ZXJzVHJhY2ssXG4gICAgICAgICAgJ2N1ZSc6IGN1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtcy5wdXNoKG1pKTtcblxuICAgICAgICBtZW51LmFkZENoaWxkKG1pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxufVxuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnQ2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtY2hhcHRlcnMtYnV0dG9uJztcblxuVGV4dFRyYWNrQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc0J1dHRvbicsIENoYXB0ZXJzQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IENoYXB0ZXJzQnV0dG9uO1xuIiwiaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4uLy4uL21lbnUvbWVudS1pdGVtLmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGFwdGVyc1RyYWNrTWVudUl0ZW0gZXh0ZW5kcyBNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBsZXQgdHJhY2sgPSBvcHRpb25zWyd0cmFjayddO1xuICAgIGxldCBjdWUgPSBvcHRpb25zWydjdWUnXTtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBjdWUudGV4dDtcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gKGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWVbJ2VuZFRpbWUnXSk7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLmN1ZSA9IGN1ZTtcbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSkpO1xuICB9XG5cbiAgb25DbGljaygpIHtcbiAgICBzdXBlci5vbkNsaWNrKCk7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gICAgdGhpcy51cGRhdGUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgY3VlID0gdGhpcy5jdWU7XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyB2anMubG9nKGN1cnJlbnRUaW1lLCBjdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnNlbGVjdGVkKGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWVbJ2VuZFRpbWUnXSk7XG4gIH1cblxufVxuXG5NZW51SXRlbS5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbiIsImltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWwgbWVudSBpdGVtIGZvciB0dXJuaW5nIG9mIGEgc3BlY2lmaWMgdHlwZSBvZiB0ZXh0IHRyYWNrXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE9mZlRleHRUcmFja01lbnVJdGVtIGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgLy8gQ3JlYXRlIHBzZXVkbyB0cmFjayBpbmZvXG4gICAgLy8gUmVxdWlyZXMgb3B0aW9uc1sna2luZCddXG4gICAgb3B0aW9uc1sndHJhY2snXSA9IHtcbiAgICAgICdraW5kJzogb3B0aW9uc1sna2luZCddLFxuICAgICAgJ3BsYXllcic6IHBsYXllcixcbiAgICAgICdsYWJlbCc6IG9wdGlvbnNbJ2tpbmQnXSArICcgb2ZmJyxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICAnbW9kZSc6ICdkaXNhYmxlZCdcbiAgICB9O1xuXG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9XG5cbiAgaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KXtcbiAgICBsZXQgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgbGV0IHNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMudHJhY2tbJ2tpbmQnXSAmJiB0cmFja1snbW9kZSddID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH1cblxufVxuXG5UZXh0VHJhY2tNZW51SXRlbS5yZWdpc3RlckNvbXBvbmVudCgnT2ZmVGV4dFRyYWNrTWVudUl0ZW0nLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5leHBvcnQgZGVmYXVsdCBPZmZUZXh0VHJhY2tNZW51SXRlbTsiLCJpbXBvcnQgVGV4dFRyYWNrQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1idXR0b24uanMnO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIHN1YnRpdGxlc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdWJ0aXRsZXNCdXR0b24gZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucywgcmVhZHkpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsJ1N1YnRpdGxlcyBNZW51Jyk7XG4gIH1cblxufVxuXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ3N1YnRpdGxlcyc7XG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnU3VidGl0bGVzJztcblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uJztcblxuVGV4dFRyYWNrQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVzQnV0dG9uOyIsImltcG9ydCBNZW51QnV0dG9uIGZyb20gJy4uLy4uL21lbnUvbWVudS1idXR0b24uanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbmltcG9ydCBUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJztcbmltcG9ydCBPZmZUZXh0VHJhY2tNZW51SXRlbSBmcm9tICcuL29mZi10ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGJ1dHRvbnMgdGhhdCB0b2dnbGUgc3BlY2lmaWMgdGV4dCB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRleHRUcmFja0J1dHRvbiBleHRlbmRzIE1lbnVCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHVwZGF0ZUhhbmRsZXIgPSBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG5cbiAgICB0aGlzLnBsYXllcl8ub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICBjcmVhdGVJdGVtcyhpdGVtcz1bXSkge1xuICAgIC8vIEFkZCBhbiBPRkYgbWVudSBpdGVtIHRvIHR1cm4gYWxsIHRyYWNrcyBvZmZcbiAgICBpdGVtcy5wdXNoKG5ldyBPZmZUZXh0VHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgJ2tpbmQnOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCB0cmFja3MgdGhhdCBhcmUgb2YgdGhlIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgVGV4dFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgJ3RyYWNrJzogdHJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG59XG5cbk1lbnVCdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0J1dHRvbicsIFRleHRUcmFja0J1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tCdXR0b247IiwiaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4uLy4uL21lbnUvbWVudS1pdGVtLmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGV4dFRyYWNrTWVudUl0ZW0gZXh0ZW5kcyBNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBsZXQgdHJhY2sgPSBvcHRpb25zWyd0cmFjayddO1xuICAgIGxldCB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9uc1snbGFiZWwnXSA9IHRyYWNrWydsYWJlbCddIHx8IHRyYWNrWydsYW5ndWFnZSddIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gdHJhY2tbJ2RlZmF1bHQnXSB8fCB0cmFja1snbW9kZSddID09PSAnc2hvd2luZyc7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIGxldCBjaGFuZ2VIYW5kbGVyID0gTGliLmJpbmQodGhpcywgdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGlPUzcgZG9lc24ndCBkaXNwYXRjaCBjaGFuZ2UgZXZlbnRzIHRvIFRleHRUcmFja0xpc3RzIHdoZW4gYW5cbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXG4gICAgLy8gT2JqZWN0Lm9ic2VydmUoKSAoYWxzbyBub3QgcHJlc2VudCBvbiBpT1M3KSwgaXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgbW9kZSBhdHRyaWJ1dGUgYW5kIHBvbHlmaWxsXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXG4gICAgLy8gY2hhbmdlIGV2ZW50cyB3aGVuZXZlciB0aGUgY29udHJvbHMgbW9kaWZ5IHRoZSBtb2RlLlxuICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBldmVudDtcblxuICAgICAgdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2NoYW5nZScpO1xuICAgICAgICAgIH0gY2F0Y2goZXJyKXt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2tzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb25DbGljayhldmVudCkge1xuICAgIGxldCBraW5kID0gdGhpcy50cmFja1sna2luZCddO1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgc3VwZXIub25DbGljayhldmVudCk7XG5cbiAgICBpZiAoIXRyYWNrcykgcmV0dXJuO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrWydraW5kJ10gIT09IGtpbmQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFjayA9PT0gdGhpcy50cmFjaykge1xuICAgICAgICB0cmFja1snbW9kZSddID0gJ3Nob3dpbmcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2tbJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KXtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnKTtcbiAgfVxuXG59XG5cbk1lbnVJdGVtLnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFja01lbnVJdGVtOyIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDdXJyZW50VGltZURpc3BsYXkgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIHRoaXMudXBkYXRlQ29udGVudCk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWN1cnJlbnQtdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY3VycmVudC10aW1lLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+Q3VycmVudCBUaW1lIDwvc3Bhbj4nICsgJzA6MDAnLCAvLyBsYWJlbCB0aGUgY3VycmVudCB0aW1lIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzXG4gICAgICAnYXJpYS1saXZlJzogJ29mZicgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgdXBkYXRlQ29udGVudCgpIHtcbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAgbGV0IHRpbWUgPSAodGhpcy5wbGF5ZXJfLnNjcnViYmluZykgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgIGxldCBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSgnQ3VycmVudCBUaW1lJyk7XG4gICAgbGV0IGZvcm1hdHRlZFRpbWUgPSBMaWIuZm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke2xvY2FsaXplZFRleHR9PC9zcGFuPiAke2Zvcm1hdHRlZFRpbWV9YDtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ3VycmVudFRpbWVEaXNwbGF5JywgQ3VycmVudFRpbWVEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IEN1cnJlbnRUaW1lRGlzcGxheTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBkdXJhdGlvblxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIER1cmF0aW9uRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gdGhpcyBtaWdodCBuZWVkIHRvIGJlIGNoYW5nZWQgdG8gJ2R1cmF0aW9uY2hhbmdlJyBpbnN0ZWFkIG9mICd0aW1ldXBkYXRlJyBldmVudHVhbGx5LFxuICAgIC8vIGhvd2V2ZXIgdGhlIGR1cmF0aW9uY2hhbmdlIGV2ZW50IGZpcmVzIGJlZm9yZSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSBpcyBzZXQsXG4gICAgLy8gc28gdGhlIHZhbHVlIGNhbm5vdCBiZSB3cml0dGVuIG91dCB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAvLyBPbmNlIHRoZSBvcmRlciBvZiBkdXJhdGlvbmNoYW5nZSBhbmQgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgYmVpbmcgc2V0IGlzIGZpZ3VyZWQgb3V0LFxuICAgIC8vIHRoaXMgY2FuIGJlIHVwZGF0ZWQuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtZHVyYXRpb24gdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmxvY2FsaXplKCdEdXJhdGlvbiBUaW1lJyl9PC9zcGFuPiAwOjAwYCwgLy8gbGFiZWwgdGhlIGR1cmF0aW9uIHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB1cGRhdGVDb250ZW50KCkge1xuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgbGV0IGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKCdEdXJhdGlvbiBUaW1lJyk7XG4gICAgICBsZXQgZm9ybWF0dGVkVGltZSA9IExpYi5mb3JtYXRUaW1lKGR1cmF0aW9uKTtcbiAgICAgIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHtsb2NhbGl6ZWRUZXh0fTwvc3Bhbj4gJHtmb3JtYXR0ZWRUaW1lfWA7IC8vIGxhYmVsIHRoZSBkdXJhdGlvbiB0aW1lIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzXG4gICAgfVxuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEdXJhdGlvbkRpc3BsYXknLCBEdXJhdGlvbkRpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgRHVyYXRpb25EaXNwbGF5O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYic7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIHRpbWUgbGVmdCBpbiB0aGUgdmlkZW9cbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSZW1haW5pbmdUaW1lRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcmVtYWluaW5nLXRpbWUgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXJlbWFpbmluZy10aW1lLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmxvY2FsaXplKCdSZW1haW5pbmcgVGltZScpfTwvc3Bhbj4gLTA6MDBgLCAvLyBsYWJlbCB0aGUgcmVtYWluaW5nIHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB1cGRhdGVDb250ZW50KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgY29uc3QgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJyk7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRUaW1lID0gTGliLmZvcm1hdFRpbWUodGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWUoKSk7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7bG9jYWxpemVkVGV4dH08L3NwYW4+IC0ke2Zvcm1hdHRlZFRpbWV9YDtcbiAgICB9XG5cbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAgLy8gdmFyIHRpbWUgPSAodGhpcy5wbGF5ZXJfLnNjcnViYmluZykgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgIC8vIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSB2anMuZm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1JlbWFpbmluZ1RpbWVEaXNwbGF5JywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgUmVtYWluaW5nVGltZURpc3BsYXk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogVGhlIHNlcGFyYXRvciBiZXR3ZWVuIHRoZSBjdXJyZW50IHRpbWUgYW5kIGR1cmF0aW9uXG4gKlxuICogQ2FuIGJlIGhpZGRlbiBpZiBpdCdzIG5vdCBuZWVkZWQgaW4gdGhlIGRlc2lnbi5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGltZURpdmlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtY29udHJvbCB2anMtdGltZS1kaXZpZGVyJyxcbiAgICAgIGlubmVySFRNTDogJzxkaXY+PHNwYW4+Lzwvc3Bhbj48L2Rpdj4nXG4gICAgfSk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RpbWVEaXZpZGVyJywgVGltZURpdmlkZXIpO1xuZXhwb3J0IGRlZmF1bHQgVGltZURpdmlkZXI7XG4iLCJpbXBvcnQgU2xpZGVyIGZyb20gJy4uLy4uL3NsaWRlci9zbGlkZXIuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG5pbXBvcnQgVm9sdW1lSGFuZGxlIGZyb20gJy4vdm9sdW1lLWhhbmRsZS5qcyc7XG5pbXBvcnQgVm9sdW1lTGV2ZWwgZnJvbSAnLi92b2x1bWUtbGV2ZWwuanMnO1xuXG4vKipcbiAqIFRoZSBiYXIgdGhhdCBjb250YWlucyB0aGUgdm9sdW1lIGxldmVsIGFuZCBjYW4gYmUgY2xpY2tlZCBvbiB0byBhZGp1c3QgdGhlIGxldmVsXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFZvbHVtZUJhciBleHRlbmRzIFNsaWRlciB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcyk7XG4gICAgcGxheWVyLnJlYWR5KExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1iYXInLFxuICAgICAgJ2FyaWEtbGFiZWwnOiAndm9sdW1lIGxldmVsJ1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSk7XG4gIH1cblxuICBnZXRQZXJjZW50KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgKyAwLjEpO1xuICB9XG5cbiAgc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgLSAwLjEpO1xuICB9XG5cbiAgdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCB2YWx1ZSBvZiB2b2x1bWUgYmFyIGFzIGEgcGVyY2VudGFnZVxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIExpYi5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkqMTAwLCAyKSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIExpYi5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkqMTAwLCAyKSsnJScpO1xuICB9XG5cbn1cblxuVm9sdW1lQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IHtcbiAgICAndm9sdW1lTGV2ZWwnOiB7fSxcbiAgICAndm9sdW1lSGFuZGxlJzoge31cbiAgfSxcbiAgJ2Jhck5hbWUnOiAndm9sdW1lTGV2ZWwnLFxuICAnaGFuZGxlTmFtZSc6ICd2b2x1bWVIYW5kbGUnXG59O1xuXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XG5cblNsaWRlci5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQmFyJywgVm9sdW1lQmFyKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUJhcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuaW1wb3J0IFZvbHVtZUJhciBmcm9tICcuL3ZvbHVtZS1iYXIuanMnO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lQ29udHJvbCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gaGlkZSB2b2x1bWUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICAgIGlmIChwbGF5ZXIudGVjaCAmJiBwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24oKXtcbiAgICAgIGlmIChwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuICB9XG5cbn1cblxuVm9sdW1lQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ3ZvbHVtZUJhcic6IHt9XG4gIH1cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lQ29udHJvbDtcbiIsImltcG9ydCBTbGlkZXJIYW5kbGUgZnJvbSAnLi4vLi4vc2xpZGVyL3NsaWRlci1oYW5kbGUuanMnO1xuXG4vKipcbiAqIFRoZSB2b2x1bWUgaGFuZGxlIGNhbiBiZSBkcmFnZ2VkIHRvIGFkanVzdCB0aGUgdm9sdW1lIGxldmVsXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFZvbHVtZUhhbmRsZSBleHRlbmRzIFNsaWRlckhhbmRsZSB7XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1oYW5kbGUnXG4gICAgfSk7XG4gIH1cblxufVxuXG5Wb2x1bWVIYW5kbGUucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9ICcwMDowMCc7XG5cblNsaWRlckhhbmRsZS5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lSGFuZGxlJywgVm9sdW1lSGFuZGxlKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUhhbmRsZTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBTaG93cyB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lTGV2ZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1sZXZlbCcsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48L3NwYW4+J1xuICAgIH0pO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVMZXZlbCcsIFZvbHVtZUxldmVsKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUxldmVsO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCBNZW51QnV0dG9uIGZyb20gJy4uL21lbnUvbWVudS1idXR0b24uanMnO1xuaW1wb3J0IE11dGVUb2dnbGUgZnJvbSAnLi9tdXRlLXRvZ2dsZS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBWb2x1bWVCYXIgZnJvbSAnLi92b2x1bWUtY29udHJvbC92b2x1bWUtYmFyLmpzJztcblxuLyoqXG4gKiBNZW51IGJ1dHRvbiB3aXRoIGEgcG9wdXAgZm9yIHNob3dpbmcgdGhlIHZvbHVtZSBzbGlkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lTWVudUJ1dHRvbiBleHRlbmRzIE1lbnVCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIC8vIFNhbWUgbGlzdGVuZXJzIGFzIE11dGVUb2dnbGVcbiAgICB0aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIHRoaXMudm9sdW1lVXBkYXRlKTtcblxuICAgIC8vIGhpZGUgbXV0ZSB0b2dnbGUgaWYgdGhlIGN1cnJlbnQgdGVjaCBkb2Vzbid0IHN1cHBvcnQgdm9sdW1lIGNvbnRyb2xcbiAgICBpZiAocGxheWVyLnRlY2ggJiYgcGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAocGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLW1lbnUtYnV0dG9uJyk7XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7XG4gICAgICBjb250ZW50RWxUeXBlOiAnZGl2J1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHZvbHVtZUJhciBpcyB2ZXJ0aWNhbCBieSBkZWZhdWx0IGluIHRoZSBiYXNlIHRoZW1lIHdoZW4gdXNlZCB3aXRoIGEgVm9sdW1lTWVudUJ1dHRvblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zX1sndm9sdW1lQmFyJ10gfHwge307XG4gICAgb3B0aW9uc1sndmVydGljYWwnXSA9IG9wdGlvbnNbJ3ZlcnRpY2FsJ10gfHwgdHJ1ZTtcblxuICAgIGxldCB2YyA9IG5ldyBWb2x1bWVCYXIodGhpcy5wbGF5ZXJfLCBvcHRpb25zKTtcblxuICAgIHZjLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgbWVudS5sb2NrU2hvd2luZygpO1xuICAgIH0pO1xuICAgIHZjLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICBtZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICB9KTtcbiAgICBtZW51LmFkZENoaWxkKHZjKTtcbiAgICByZXR1cm4gbWVudTtcbiAgfVxuXG4gIG9uQ2xpY2soKSB7XG4gICAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUub25DbGljay5jYWxsKHRoaXMpO1xuICAgIHN1cGVyLm9uQ2xpY2soKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1tZW51LWJ1dHRvbiB2anMtbWVudS1idXR0b24gdmpzLWNvbnRyb2wnLFxuICAgICAgaW5uZXJIVE1MOiBgPGRpdj48c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ011dGUnKX08L3NwYW4+PC9kaXY+YFxuICAgIH0pO1xuICB9XG5cbn1cblxuVm9sdW1lTWVudUJ1dHRvbi5wcm90b3R5cGUudm9sdW1lVXBkYXRlID0gTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlO1xuXG5CdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZU1lbnVCdXR0b24nLCBWb2x1bWVNZW51QnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZU1lbnVCdXR0b247XG4iLCJpbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuXG4vKipcbiAqIENvcmUgT2JqZWN0L0NsYXNzIGZvciBvYmplY3RzIHRoYXQgdXNlIGluaGVyaXRhbmNlICsgY29uc3RydWN0b3JzXG4gKlxuICogVG8gY3JlYXRlIGEgY2xhc3MgdGhhdCBjYW4gYmUgc3ViY2xhc3NlZCBpdHNlbGYsIGV4dGVuZCB0aGUgQ29yZU9iamVjdCBjbGFzcy5cbiAqXG4gKiAgICAgdmFyIEFuaW1hbCA9IENvcmVPYmplY3QuZXh0ZW5kKCk7XG4gKiAgICAgdmFyIEhvcnNlID0gQW5pbWFsLmV4dGVuZCgpO1xuICpcbiAqIFRoZSBjb25zdHJ1Y3RvciBjYW4gYmUgZGVmaW5lZCB0aHJvdWdoIHRoZSBpbml0IHByb3BlcnR5IG9mIGFuIG9iamVjdCBhcmd1bWVudC5cbiAqXG4gKiAgICAgdmFyIEFuaW1hbCA9IENvcmVPYmplY3QuZXh0ZW5kKHtcbiAqICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5hbWUsIHNvdW5kKXtcbiAqICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBPdGhlciBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCB0aGUgc2FtZSB3YXksIG9yIGRpcmVjdGx5IHRvIHRoZVxuICogcHJvdG90eXBlLlxuICpcbiAqICAgIHZhciBBbmltYWwgPSBDb3JlT2JqZWN0LmV4dGVuZCh7XG4gKiAgICAgICBpbml0OiBmdW5jdGlvbihuYW1lKXtcbiAqICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAqICAgICAgIH0sXG4gKiAgICAgICBnZXROYW1lOiBmdW5jdGlvbigpe1xuICogICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICogICAgICAgfSxcbiAqICAgICAgIHNvdW5kOiAnLi4uJ1xuICogICAgfSk7XG4gKlxuICogICAgQW5pbWFsLnByb3RvdHlwZS5tYWtlU291bmQgPSBmdW5jdGlvbigpe1xuICogICAgICBhbGVydCh0aGlzLnNvdW5kKTtcbiAqICAgIH07XG4gKlxuICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgY2xhc3MsIHVzZSB0aGUgY3JlYXRlIG1ldGhvZC5cbiAqXG4gKiAgICB2YXIgZmx1ZmZ5ID0gQW5pbWFsLmNyZWF0ZSgnRmx1ZmZ5Jyk7XG4gKiAgICBmbHVmZnkuZ2V0TmFtZSgpOyAvLyAtPiBGbHVmZnlcbiAqXG4gKiBNZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMuXG4gKlxuICogICAgIHZhciBIb3JzZSA9IEFuaW1hbC5leHRlbmQoe1xuICogICAgICAgc291bmQ6ICdOZWlnaGhoaGghJ1xuICogICAgIH0pO1xuICpcbiAqICAgICB2YXIgaG9yc2V5ID0gSG9yc2UuY3JlYXRlKCdIb3JzZXknKTtcbiAqICAgICBob3JzZXkuZ2V0TmFtZSgpOyAvLyAtPiBIb3JzZXlcbiAqICAgICBob3JzZXkubWFrZVNvdW5kKCk7IC8vIC0+IEFsZXJ0OiBOZWlnaGhoaGghXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvcmVPYmplY3QgPSBmdW5jdGlvbigpe307XG4vLyBNYW51YWxseSBleHBvcnRpbmcgdmpzWydDb3JlT2JqZWN0J10gaGVyZSBmb3IgQ2xvc3VyZSBDb21waWxlclxuLy8gYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBleHRlbmQvY3JlYXRlIGNsYXNzIG1ldGhvZHNcbi8vIElmIHdlIGRpZG4ndCBkbyB0aGlzLCB0aG9zZSBmdW5jdGlvbnMgd291bGQgZ2V0IGZsYXR0ZW5lZCB0byBzb21ldGhpbmcgbGlrZVxuLy8gYGEgPSAuLi5gIGFuZCBgdGhpcy5wcm90b3R5cGVgIHdvdWxkIHJlZmVyIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGluc3RlYWQgb2Zcbi8vIENvcmVPYmplY3RcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIE9iamVjdFxuICpcbiAqICAgICB2YXIgQW5pbWFsID0gQ29yZU9iamVjdC5leHRlbmQoKTtcbiAqICAgICB2YXIgSG9yc2UgPSBBbmltYWwuZXh0ZW5kKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIG5ldyBvYmplY3QncyBwcm90b3R5cGVcbiAqIEByZXR1cm4ge0NvcmVPYmplY3R9IEFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gQ29yZU9iamVjdFxuICogQHRoaXMgeyp9XG4gKi9cbkNvcmVPYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcHM9e30pe1xuICAvLyBTZXQgdXAgdGhlIGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBzdXBwbGllZCBpbml0IG1ldGhvZFxuICAvLyBvciB1c2luZyB0aGUgaW5pdCBvZiB0aGUgcGFyZW50IG9iamVjdFxuICAvLyBNYWtlIHN1cmUgdG8gY2hlY2sgdGhlIHVub2JmdXNjYXRlZCB2ZXJzaW9uIGZvciBleHRlcm5hbCBsaWJzXG4gIGxldCBpbml0ID0gcHJvcHNbJ2luaXQnXSB8fCBwcm9wcy5pbml0IHx8IHRoaXMucHJvdG90eXBlWydpbml0J10gfHwgdGhpcy5wcm90b3R5cGUuaW5pdCB8fCBmdW5jdGlvbigpe307XG4gIC8vIEluIFJlc2lnJ3Mgc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlIChwcmV2aW91c2x5IHVzZWQpIHRoZSBjb25zdHJ1Y3RvclxuICAvLyAgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIGB0aGlzLmluaXQuYXBwbHkoYXJndW1lbnRzKWBcbiAgLy8gSG93ZXZlciB0aGF0IHdvdWxkIHByZXZlbnQgdXMgZnJvbSB1c2luZyBgUGFyZW50T2JqZWN0LmNhbGwodGhpcyk7YFxuICAvLyAgaW4gYSBDaGlsZCBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZSBgdGhpc2AgaW4gYHRoaXMuaW5pdGBcbiAgLy8gIHdvdWxkIHN0aWxsIHJlZmVyIHRvIHRoZSBDaGlsZCBhbmQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcC5cbiAgLy8gV2Ugd291bGQgaW5zdGVhZCBoYXZlIHRvIGRvXG4gIC8vICAgIGBQYXJlbnRPYmplY3QucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtgXG4gIC8vICBCbGVoLiBXZSdyZSBub3QgY3JlYXRpbmcgYSBfc3VwZXIoKSBmdW5jdGlvbiwgc28gaXQncyBnb29kIHRvIGtlZXBcbiAgLy8gIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgcmVmZXJlbmNlIHNpbXBsZS5cbiAgbGV0IHN1Yk9iaiA9IGZ1bmN0aW9uKCl7XG4gICAgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEluaGVyaXQgZnJvbSB0aGlzIG9iamVjdCdzIHByb3RvdHlwZVxuICBzdWJPYmoucHJvdG90eXBlID0gTGliLm9iai5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAvLyBSZXNldCB0aGUgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIHN1Yk9iaiBvdGhlcndpc2VcbiAgLy8gaW5zdGFuY2VzIG9mIHN1Yk9iaiB3b3VsZCBoYXZlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGFyZW50IE9iamVjdFxuICBzdWJPYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViT2JqO1xuXG4gIC8vIE1ha2UgdGhlIGNsYXNzIGV4dGVuZGFibGVcbiAgc3ViT2JqLmV4dGVuZCA9IENvcmVPYmplY3QuZXh0ZW5kO1xuICAvLyBNYWtlIGEgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGluc3RhbmNlc1xuICBzdWJPYmouY3JlYXRlID0gQ29yZU9iamVjdC5jcmVhdGU7XG5cbiAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gIGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1Yk9iai5wcm90b3R5cGVbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViT2JqO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBPYmplY3QgY2xhc3NcbiAqXG4gKiAgICAgdmFyIG15QW5pbWFsID0gQW5pbWFsLmNyZWF0ZSgpO1xuICpcbiAqIEByZXR1cm4ge0NvcmVPYmplY3R9IEFuIGluc3RhbmNlIG9mIGEgQ29yZU9iamVjdCBzdWJjbGFzc1xuICogQHRoaXMgeyp9XG4gKi9cbkNvcmVPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QncyBwcm90b3R5cGVcbiAgdmFyIGluc3QgPSBMaWIub2JqLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cbiAgLy8gQXBwbHkgdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB0aGUgbmV3IG9iamVjdFxuICB0aGlzLmFwcGx5KGluc3QsIGFyZ3VtZW50cyk7XG5cbiAgLy8gUmV0dXJuIHRoZSBuZXcgb2JqZWN0XG4gIHJldHVybiBpbnN0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29yZU9iamVjdDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYWluIGZ1bmN0aW9uIHNyYy5cbiAqL1xuXG5pbXBvcnQgUGxheWVyIGZyb20gJy4vcGxheWVyJztcbmltcG9ydCBQbHVnaW5zIGZyb20gJy4vcGx1Z2lucyc7XG5pbXBvcnQgT3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcbmltcG9ydCAqIGFzIFZqc1V0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBDb3JlT2JqZWN0IGZyb20gJy4vY29yZS1vYmplY3QnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogRG91YmxlcyBhcyB0aGUgbWFpbiBmdW5jdGlvbiBmb3IgdXNlcnMgdG8gY3JlYXRlIGEgcGxheWVyIGluc3RhbmNlIGFuZCBhbHNvXG4gKiB0aGUgbWFpbiBsaWJyYXJ5IG9iamVjdC5cbiAqXG4gKiAqKkFMSUFTRVMqKiB2aWRlb2pzLCBfVl8gKGRlcHJlY2F0ZWQpXG4gKlxuICogVGhlIGB2anNgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgb3IgcmV0cmlldmUgYSBwbGF5ZXIuXG4gKlxuICogICAgIHZhciBteVBsYXllciA9IHZqcygnbXlfdmlkZW9faWQnKTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8RWxlbWVudH0gaWQgICAgICBWaWRlbyBlbGVtZW50IG9yIHZpZGVvIGVsZW1lbnQgSURcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWcvc2V0dGluZ3NcbiAqIEBwYXJhbSAge0Z1bmN0aW9uPX0gcmVhZHkgICAgICAgIE9wdGlvbmFsIHJlYWR5IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB2aWRlb2pzID0gZnVuY3Rpb24oaWQsIG9wdGlvbnMsIHJlYWR5KXtcbiAgdmFyIHRhZzsgLy8gRWxlbWVudCBvZiBJRFxuXG4gIC8vIEFsbG93IGZvciBlbGVtZW50IG9yIElEIHRvIGJlIHBhc3NlZCBpblxuICAvLyBTdHJpbmcgSURcbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcblxuICAgIC8vIEFkanVzdCBmb3IgalF1ZXJ5IElEIHN5bnRheFxuICAgIGlmIChpZC5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICAgIGlkID0gaWQuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBwbGF5ZXIgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkIGZvciB0aGlzIElEIHJldHVybiBpdC5cbiAgICBpZiAoUGxheWVyLnBsYXllcnNbaWRdKSB7XG5cbiAgICAgIC8vIElmIG9wdGlvbnMgb3IgcmVhZHkgZnVudGlvbiBhcmUgcGFzc2VkLCB3YXJuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBMaWIubG9nLndhcm4oYFBsYXllciBcIiR7aWR9XCIgaXMgYWxyZWFkeSBpbml0aWFsaXNlZC4gT3B0aW9ucyB3aWxsIG5vdCBiZSBhcHBsaWVkLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVhZHkpIHtcbiAgICAgICAgUGxheWVyLnBsYXllcnNbaWRdLnJlYWR5KHJlYWR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBsYXllci5wbGF5ZXJzW2lkXTtcblxuICAgIC8vIE90aGVyd2lzZSBnZXQgZWxlbWVudCBmb3IgSURcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnID0gTGliLmVsKGlkKTtcbiAgICB9XG5cbiAgLy8gSUQgaXMgYSBtZWRpYSBlbGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdGFnID0gaWQ7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgYSB1c2VhYmxlIGVsZW1lbnRcbiAgaWYgKCF0YWcgfHwgIXRhZy5ub2RlTmFtZSkgeyAvLyByZTogbm9kZU5hbWUsIGNvdWxkIGJlIGEgYm94IGRpdiBhbHNvXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGVsZW1lbnQgb3IgSUQgc3VwcGxpZWQgaXMgbm90IHZhbGlkLiAodmlkZW9qcyknKTsgLy8gUmV0dXJuc1xuICB9XG5cbiAgLy8gRWxlbWVudCBtYXkgaGF2ZSBhIHBsYXllciBhdHRyIHJlZmVycmluZyB0byBhbiBhbHJlYWR5IGNyZWF0ZWQgcGxheWVyIGluc3RhbmNlLlxuICAvLyBJZiBub3QsIHNldCB1cCBhIG5ldyBwbGF5ZXIgYW5kIHJldHVybiB0aGUgaW5zdGFuY2UuXG4gIHJldHVybiB0YWdbJ3BsYXllciddIHx8IG5ldyBQbGF5ZXIodGFnLCBvcHRpb25zLCByZWFkeSk7XG59O1xuXG4vLyBFeHRlbmRlZCBuYW1lLCBhbHNvIGF2YWlsYWJsZSBleHRlcm5hbGx5LCB3aW5kb3cudmlkZW9qc1xuLy8gdmFyIHZpZGVvanMgPSB3aW5kb3dbJ3ZpZGVvanMnXSA9IHZqcztcblxuLy8gQ0ROIFZlcnNpb24uIFVzZWQgdG8gdGFyZ2V0IHJpZ2h0IGZsYXNoIHN3Zi5cbnZpZGVvanMuQ0ROX1ZFUlNJT04gPSAnX19WRVJTSU9OX05PX1BBVENIX18nO1xudmlkZW9qcy5BQ0NFU1NfUFJPVE9DT0wgPSAoJ2h0dHBzOicgPT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKTtcblxuLyoqXG4qIEZ1bGwgcGxheWVyIHZlcnNpb25cbiogQHR5cGUge3N0cmluZ31cbiovXG52aWRlb2pzWydWRVJTSU9OJ10gPSAnX19WRVJTSU9OX18nO1xuXG4vLyBTZXQgQ0ROIFZlcnNpb24gb2Ygc3dmXG4vLyBUaGUgYWRkZWQgKCspIGJsb2NrcyB0aGUgcmVwbGFjZSBmcm9tIGNoYW5naW5nIHRoaXMgX1ZFUlNJT05fTk9fUEFUQ0hfIHN0cmluZ1xuaWYgKHZpZGVvanMuQ0ROX1ZFUlNJT04gIT09ICdfX1ZFUlNJT05fJysnTk9fUEFUQ0hfXycpIHtcbiAgT3B0aW9uc1snZmxhc2gnXVsnc3dmJ10gPSBgJHt2aWRlb2pzLkFDQ0VTU19QUk9UT0NPTH12anMuemVuY2RuLm5ldC8ke3ZpZGVvanMuQ0ROX1ZFUlNJT059L3ZpZGVvLWpzLnN3ZmA7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxhbmd1YWdlcyB0byB0aGUgZGVmYXVsdCBvcHRpb25zLiBVc2VmdWwgZm9yXG4gKiBhbWVuZGluZyBtdWx0aXBsZSBsYW5ndWFnZSBzdXBwb3J0IGF0IHJ1bnRpbWUuXG4gKlxuICogRXhhbXBsZTogdmlkZW9qcy5hZGRMYW5ndWFnZSgnZXMnLCB7J0hlbGxvJzonSG9sYSd9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvZGUgVGhlIGxhbmd1YWdlIGNvZGUgb3IgZGljdGlvbmFyeSBwcm9wZXJ0eVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgZ2xvYmFsIGxhbmd1YWdlcyBkaWN0aW9uYXJ5IG9iamVjdFxuICovXG52aWRlb2pzLmFkZExhbmd1YWdlID0gZnVuY3Rpb24oY29kZSwgZGF0YSl7XG4gIGlmKE9wdGlvbnNbJ2xhbmd1YWdlcyddW2NvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBPcHRpb25zWydsYW5ndWFnZXMnXVtjb2RlXSA9IFZqc1V0aWwubWVyZ2VPcHRpb25zKE9wdGlvbnNbJ2xhbmd1YWdlcyddW2NvZGVdLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBPcHRpb25zWydsYW5ndWFnZXMnXVtjb2RlXSA9IGRhdGE7XG4gIH1cbiAgcmV0dXJuIE9wdGlvbnNbJ2xhbmd1YWdlcyddO1xufTtcblxuLyoqXG4gKiBDdXN0b20gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpXG4gKlxuICogVmlkZW8uanMgd2lsbCBuZXZlciBiZSBhIG5vbi1icm93c2VyIGxpYiBzbyB3ZSBjYW4gc2ltcGxpZnkgVU1EIGEgYnVuY2ggYW5kXG4gKiBzdGlsbCBzdXBwb3J0IHJlcXVpcmVqcyBhbmQgYnJvd3NlcmlmeS4gVGhpcyBhbHNvIG5lZWRzIHRvIGJlIGNsb3N1cmVcbiAqIGNvbXBpbGVyIGNvbXBhdGlibGUsIHNvIHN0cmluZyBrZXlzIGFyZSB1c2VkLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gIGRlZmluZSgndmlkZW9qcycsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gdmlkZW9qczsgfSk7XG5cbi8vIGNoZWNraW5nIHRoYXQgbW9kdWxlIGlzIGFuIG9iamVjdCB0b28gYmVjYXVzZSBvZiB1bWRqcy91bWQjMzVcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZVsnZXhwb3J0cyddID0gdmlkZW9qcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmlkZW9qcztcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcblxuLyoqXG4gKiBEaXNwbGF5IHRoYXQgYW4gZXJyb3IgaGFzIG9jY3VycmVkIG1ha2luZyB0aGUgdmlkZW8gdW5wbGF5YWJsZVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEVycm9yRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdlcnJvcicsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtZXJyb3ItZGlzcGxheSdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5lcnJvcigpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSh0aGlzLnBsYXllcigpLmVycm9yKCkubWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IEVycm9yRGlzcGxheTtcbiIsImltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHt9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFzIGJlZm9yZSBjYWxsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgbGV0IGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICBFdmVudHMub24odGhpcywgdHlwZSwgZm4pO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICBFdmVudHMub2ZmKHRoaXMsIHR5cGUsIGZuKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICBFdmVudHMub25lKHRoaXMsIHR5cGUsIGZuKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0ge1xuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbiAgZXZlbnQgPSBFdmVudHMuZml4RXZlbnQoZXZlbnQpO1xuXG4gIGlmICh0aGlzLmFsbG93ZWRFdmVudHNfW3R5cGVdICYmIHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xuICB9XG5cbiAgRXZlbnRzLnRyaWdnZXIodGhpcywgZXZlbnQpO1xufTtcbi8vIFRoZSBzdGFuZGFyZCBET00gRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudCgpIGlzIGFsaWFzZWQgdG8gdHJpZ2dlcigpXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXI7XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBFdmVudCBTeXN0ZW0gKEpvaG4gUmVzaWcgLSBTZWNyZXRzIG9mIGEgSlMgTmluamEgaHR0cDovL2pzbmluamEuY29tLylcbiAqIChPcmlnaW5hbCBib29rIHZlcnNpb24gd2Fzbid0IGNvbXBsZXRlbHkgdXNhYmxlLCBzbyBmaXhlZCBzb21lIHRoaW5ncyBhbmQgbWFkZSBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUpXG4gKiBUaGlzIHNob3VsZCB3b3JrIHZlcnkgc2ltaWxhcmx5IHRvIGpRdWVyeSdzIGV2ZW50cywgaG93ZXZlciBpdCdzIGJhc2VkIG9mZiB0aGUgYm9vayB2ZXJzaW9uIHdoaWNoIGlzbid0IGFzXG4gKiByb2J1c3QgYXMganF1ZXJ5J3MsIHNvIHRoZXJlJ3MgcHJvYmFibHkgc29tZSBkaWZmZXJlbmNlcy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKipcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xuICogQHBhcmFtICB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QgdG8gZml4XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZml4RXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBUZXN0IGlmIGZpeGluZyB1cCBpcyBuZWVkZWRcbiAgLy8gVXNlZCB0byBjaGVjayBpZiAhZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGluc3RlYWQgb2YgaXNQcm9wYWdhdGlvblN0b3BwZWRcbiAgLy8gQnV0IG5hdGl2ZSBldmVudHMgcmV0dXJuIHRydWUgZm9yIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGRvbid0IGhhdmVcbiAgLy8gb3RoZXIgZXhwZWN0ZWQgbWV0aG9kcyBsaWtlIGlzUHJvcGFnYXRpb25TdG9wcGVkLiBTZWVtcyB0byBiZSBhIHByb2JsZW1cbiAgLy8gd2l0aCB0aGUgSmF2YXNjcmlwdCBOaW5qYSBjb2RlLiBTbyB3ZSdyZSBqdXN0IG92ZXJyaWRpbmcgYWxsIGV2ZW50cyBub3cuXG4gIGlmICghZXZlbnQgfHwgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgdmFyIG9sZCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIGV2ZW50ID0ge307XG4gICAgLy8gQ2xvbmUgdGhlIG9sZCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZSB2YWx1ZXMgZXZlbnQgPSB7fTtcbiAgICAvLyBJRTggRG9lc24ndCBsaWtlIHdoZW4geW91IG1lc3Mgd2l0aCBuYXRpdmUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBmYWxzZSBmb3IgZXZlbnQuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSBhbmQgb3RoZXIgcHJvcHNcbiAgICAvLyAgd2hpY2ggbWFrZXMgY29weWluZyBtb3JlIGRpZmZpY3VsdC5cbiAgICAvLyBUT0RPOiBQcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBhIHdoaXRlbGlzdCBvZiBldmVudCBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgIC8vIFNhZmFyaSA2LjAuMyB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgbGF5ZXJYL1lcbiAgICAgIC8vIENocm9tZSB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQga2V5Ym9hcmRFdmVudC5rZXlMb2NhdGlvblxuICAgICAgaWYgKGtleSAhPT0gJ2xheWVyWCcgJiYga2V5ICE9PSAnbGF5ZXJZJyAmJiBrZXkgIT09ICdrZXlMb2NhdGlvbicpIHtcbiAgICAgICAgLy8gQ2hyb21lIDMyKyB3YXJucyBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCByZXR1cm5WYWx1ZSwgYnV0XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gaWYgcHJldmVudERlZmF1bHQgaXNuJ3Qgc3VwcG9ydGVkIChJRTgpLlxuICAgICAgICBpZiAoIShrZXkgPT09ICdyZXR1cm5WYWx1ZScgJiYgb2xkLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgIGV2ZW50W2tleV0gPSBvbGRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2hpY2ggb3RoZXIgZWxlbWVudCB0aGUgZXZlbnQgaXMgcmVsYXRlZCB0b1xuICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID9cbiAgICAgIGV2ZW50LnRvRWxlbWVudCA6XG4gICAgICBldmVudC5mcm9tRWxlbWVudDtcblxuICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgb2xkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIH07XG5cbiAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZyBhbmQgZXhlY3V0aW5nIG90aGVyIGhhbmRsZXJzXG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgcG9zaXRpb25cbiAgICBpZiAoZXZlbnQuY2xpZW50WCAhPSBudWxsKSB7XG4gICAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICtcbiAgICAgICAgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtXG4gICAgICAgIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgK1xuICAgICAgICAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtXG4gICAgICAgIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIEZpeCBidXR0b24gZm9yIG1vdXNlIGNsaWNrczpcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSBudWxsKSB7XG4gICAgICBldmVudC5idXR0b24gPSAoZXZlbnQuYnV0dG9uICYgMSA/IDAgOlxuICAgICAgICAoZXZlbnQuYnV0dG9uICYgNCA/IDEgOlxuICAgICAgICAgIChldmVudC5idXR0b24gJiAyID8gMiA6IDApKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBmaXhlZC11cCBpbnN0YW5jZVxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50XG4gKiBJdCBzdG9yZXMgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaW4gYSBzZXBhcmF0ZSBjYWNoZSBvYmplY3RcbiAqIGFuZCBhZGRzIGEgZ2VuZXJpYyBoYW5kbGVyIHRvIHRoZSBlbGVtZW50J3MgZXZlbnQsXG4gKiBhbG9uZyB3aXRoIGEgdW5pcXVlIGlkIChndWlkKSB0byB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIEV2ZW50IGxpc3RlbmVyLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG9uID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgZm4pe1xuICBpZiAoTGliLm9iai5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbiwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG5cbiAgbGV0IGRhdGEgPSBMaWIuZ2V0RGF0YShlbGVtKTtcblxuICAvLyBXZSBuZWVkIGEgcGxhY2UgdG8gc3RvcmUgYWxsIG91ciBoYW5kbGVyIGRhdGFcbiAgaWYgKCFkYXRhLmhhbmRsZXJzKSBkYXRhLmhhbmRsZXJzID0ge307XG5cbiAgaWYgKCFkYXRhLmhhbmRsZXJzW3R5cGVdKSBkYXRhLmhhbmRsZXJzW3R5cGVdID0gW107XG5cbiAgaWYgKCFmbi5ndWlkKSBmbi5ndWlkID0gTGliLmd1aWQrKztcblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50KXtcblxuICAgICAgaWYgKGRhdGEuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgaGFuZGxlcnMgPSBkYXRhLmhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuXG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgLy8gQ29weSBoYW5kbGVycyBzbyBpZiBoYW5kbGVycyBhcmUgYWRkZWQvcmVtb3ZlZCBkdXJpbmcgdGhlIHByb2Nlc3MgaXQgZG9lc24ndCB0aHJvdyBldmVyeXRoaW5nIG9mZi5cbiAgICAgICAgdmFyIGhhbmRsZXJzQ29weSA9IGhhbmRsZXJzLnNsaWNlKDApO1xuXG4gICAgICAgIGZvciAodmFyIG0gPSAwLCBuID0gaGFuZGxlcnNDb3B5Lmxlbmd0aDsgbSA8IG47IG0rKykge1xuICAgICAgICAgIGlmIChldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcnNDb3B5W21dLmNhbGwoZWxlbSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT0gMSkge1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBPYmplY3QgdG8gcmVtb3ZlIGxpc3RlbmVycyBmcm9tXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXk9fSAgIHR5cGUgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgU3BlY2lmaWMgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGFuIGV2ZW50IHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgb2ZmID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXREYXRhIGlmIG5vdCBuZWVkZWRcbiAgaWYgKCFMaWIuaGFzRGF0YShlbGVtKSkgcmV0dXJuO1xuXG4gIGxldCBkYXRhID0gTGliLmdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHsgcmV0dXJuOyB9XG5cbiAgaWYgKExpYi5vYmouaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24odCl7XG4gICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcbiAgICAgY2xlYW5VcEV2ZW50cyhlbGVtLHQpO1xuICB9O1xuXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEuaGFuZGxlcnMpIHJlbW92ZVR5cGUodCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuO1xuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUodHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKTtcbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIGNhY2hlIGFuZCBkaXNwYXRjaGVyc1xuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9IGVsZW0gRWxlbWVudCB0byBjbGVhbiB1cFxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gY2xlYW4gdXBcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjbGVhblVwRXZlbnRzID0gZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuICB2YXIgZGF0YSA9IExpYi5nZXREYXRhKGVsZW0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9mIGEgcGFydGljdWxhciB0eXBlIGlmIHRoZXJlIGFyZSBub25lIGxlZnRcbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnNbdHlwZV07XG4gICAgLy8gZGF0YS5oYW5kbGVyc1t0eXBlXSA9IG51bGw7XG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdhcyBjYXVzaW5nIGFuIGVycm9yIHdpdGggZGF0YS5oYW5kbGVyc1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBtZXRhLWhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyB0eXBlcyBsZWZ0XG4gIGlmIChMaWIuaXNFbXB0eShkYXRhLmhhbmRsZXJzKSkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzO1xuICAgIGRlbGV0ZSBkYXRhLmRpc3BhdGNoZXI7XG4gICAgZGVsZXRlIGRhdGEuZGlzYWJsZWQ7XG5cbiAgICAvLyBkYXRhLmhhbmRsZXJzID0gbnVsbDtcbiAgICAvLyBkYXRhLmRpc3BhdGNoZXIgPSBudWxsO1xuICAgIC8vIGRhdGEuZGlzYWJsZWQgPSBudWxsO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0XG4gIGlmIChMaWIuaXNFbXB0eShkYXRhKSkge1xuICAgIExpYi5yZW1vdmVEYXRhKGVsZW0pO1xuICB9XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgICAgIGVsZW0gIEVsZW1lbnQgdG8gdHJpZ2dlciBhbiBldmVudCBvblxuICogQHBhcmFtICB7RXZlbnR8T2JqZWN0fFN0cmluZ30gZXZlbnQgQSBzdHJpbmcgKHRoZSB0eXBlKSBvciBhbiBldmVudCBvYmplY3Qgd2l0aCBhIHR5cGUgYXR0cmlidXRlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdHJpZ2dlciA9IGZ1bmN0aW9uKGVsZW0sIGV2ZW50KSB7XG4gIC8vIEZldGNoZXMgZWxlbWVudCBkYXRhIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IChmb3IgYnViYmxpbmcpLlxuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGRhdGEgb2JqZWN0IHRvIGNhY2hlIGZvciBldmVyeSBwYXJlbnQsXG4gIC8vIHNvIGNoZWNraW5nIGhhc0RhdGEgZmlyc3QuXG4gIHZhciBlbGVtRGF0YSA9IChMaWIuaGFzRGF0YShlbGVtKSkgPyBMaWIuZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgIC8vIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50LFxuICAgICAgLy8gaGFuZGxlcjtcblxuICAvLyBJZiBhbiBldmVudCBuYW1lIHdhcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGNyZWF0ZXMgYW4gZXZlbnQgb3V0IG9mIGl0XG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6ZXZlbnQsIHRhcmdldDplbGVtIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplcyB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgLy8gSWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBhIGRpc3BhdGNoZXIsIGV4ZWN1dGVzIHRoZSBlc3RhYmxpc2hlZCBoYW5kbGVycy5cbiAgaWYgKGVsZW1EYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQpO1xuICB9XG5cbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcbiAgICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgICBpZiAocGFyZW50ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGV2ZW50LmJ1YmJsZXMgIT09IGZhbHNlKSB7XG4gICAgdHJpZ2dlcihwYXJlbnQsIGV2ZW50KTtcblxuICAvLyBJZiBhdCB0aGUgdG9wIG9mIHRoZSBET00sIHRyaWdnZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiB1bmxlc3MgZGlzYWJsZWQuXG4gIH0gZWxzZSBpZiAoIXBhcmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHZhciB0YXJnZXREYXRhID0gTGliLmdldERhdGEoZXZlbnQudGFyZ2V0KTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGhhcyBhIGRlZmF1bHQgYWN0aW9uIGZvciB0aGlzIGV2ZW50LlxuICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVzIGV2ZW50IGRpc3BhdGNoaW5nIG9uIHRoZSB0YXJnZXQgYXMgd2UgaGF2ZSBhbHJlYWR5IGV4ZWN1dGVkIHRoZSBoYW5kbGVyLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICBpZiAodHlwZW9mIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC50YXJnZXRbZXZlbnQudHlwZV0oKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlLWVuYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5mb3JtIHRoZSB0cmlnZ2VyZXIgaWYgdGhlIGRlZmF1bHQgd2FzIHByZXZlbnRlZCBieSByZXR1cm5pbmcgZmFsc2VcbiAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0b1xuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHR5cGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xudmFyIG9uZSA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChMaWIub2JqLmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uZSwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG4gIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiAgICBvZmYoZWxlbSwgdHlwZSwgZnVuYyk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgLy8gY29weSB0aGUgZ3VpZCB0byB0aGUgbmV3IGZ1bmN0aW9uIHNvIGl0IGNhbiByZW1vdmVkIHVzaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbidzIElEXG4gIGZ1bmMuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IExpYi5ndWlkKys7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufTtcblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgdHlwZSBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBFdmVudCBsaXN0ZW5lci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgTGliLmFyci5mb3JFYWNoKHR5cGUsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBmbihlbGVtLCB0eXBlLCBjYWxsYmFjayk7IC8vQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcbiAgfSk7XG59XG5cbmV4cG9ydCB7IG9uLCBvZmYsIGNsZWFuVXBFdmVudHMsIGZpeEV2ZW50LCBvbmUsIHRyaWdnZXIgfTtcbiIsImltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBub2RlIGluaGVyaXRzIGFuZCBiYWJlbCdzIGluaGVyaXRzIChhZnRlciB0cmFuc3BpbGUpLlxuICogQm90aCB3b3JrIHRoZSBzYW1lIGJ1dCBub2RlIGFkZHMgYHN1cGVyX2AgdG8gdGhlIHN1YkNsYXNzXG4gKiBhbmQgQmFibGUgYWRkcyB0aGUgc3VwZXJDbGFzcyBhcyBfX3Byb3RvX18uIEJvdGggc2VlbSB1c2VmdWwuXG4gKi9cbmNvbnN0IF9pbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIGBgYFxuICogdmFyIEJ1dHRvbiA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdCdXR0b24nKTtcbiAqXG4gKiB2YXIgTXlCdXR0b24gPSB2aWRlb2pzLmV4dGVuZHMoQnV0dG9uLCB7XG4gKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAqICAgICBCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICogICB9LFxuICpcbiAqICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gZG9Tb21ldGhpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgZXh0ZW5kc0ZuID0gZnVuY3Rpb24oc3VwZXJDbGFzcywgc3ViQ2xhc3NNZXRob2RzPXt9KSB7XG4gIGxldCBzdWJDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgbGV0IG1ldGhvZHMgPSB7fTtcblxuICBpZiAoc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgbWV0aG9kcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViQ2xhc3NNZXRob2RzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH1cblxuICBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuXG4gIC8vIEV4dGVuZCBzdWJPYmoncyBwcm90b3R5cGUgd2l0aCBmdW5jdGlvbnMgYW5kIG90aGVyIHByb3BlcnRpZXMgZnJvbSBwcm9wc1xuICBmb3IgKHZhciBuYW1lIGluIG1ldGhvZHMpIHtcbiAgICBpZiAobWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3ViQ2xhc3MucHJvdG90eXBlW25hbWVdID0gbWV0aG9kc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViQ2xhc3M7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbmRzRm47XG4iLCJpbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyoqXG4gKiBTdG9yZSB0aGUgYnJvd3Nlci1zcGVjaWZpYyBtZXRob2RzIGZvciB0aGUgZnVsbHNjcmVlbiBBUElcbiAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xubGV0IEZ1bGxzY3JlZW5BcGkgPSB7fTtcblxuLy8gYnJvd3NlciBBUEkgbWV0aG9kc1xuLy8gbWFwIGFwcHJvYWNoIGZyb20gU2NyZWVuZnVsLmpzIC0gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zY3JlZW5mdWxsLmpzXG5jb25zdCBhcGlNYXAgPSBbXG4gIC8vIFNwZWM6IGh0dHBzOi8vZHZjcy53My5vcmcvaGcvZnVsbHNjcmVlbi9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbFxuICBbXG4gICAgJ3JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAnZXhpdEZ1bGxzY3JlZW4nLFxuICAgICdmdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgJ2Z1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAnZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgJ2Z1bGxzY3JlZW5lcnJvcidcbiAgXSxcbiAgLy8gV2ViS2l0XG4gIFtcbiAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG4gICAgJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuICBdLFxuICAvLyBPbGQgV2ViS2l0IChTYWZhcmkgNS4xKVxuICBbXG4gICAgJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgJ3dlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCcsXG4gICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuICBdLFxuICAvLyBNb3ppbGxhXG4gIFtcbiAgICAnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLFxuICAgICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsXG4gICAgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICdtb3pmdWxsc2NyZWVuZXJyb3InXG4gIF0sXG4gIC8vIE1pY3Jvc29mdFxuICBbXG4gICAgJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICdtc0V4aXRGdWxsc2NyZWVuJyxcbiAgICAnbXNGdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLFxuICAgICdNU0Z1bGxzY3JlZW5FcnJvcidcbiAgXVxuXTtcblxubGV0IHNwZWNBcGkgPSBhcGlNYXBbMF07XG5sZXQgYnJvd3NlckFwaTtcblxuLy8gZGV0ZXJtaW5lIHRoZSBzdXBwb3J0ZWQgc2V0IG9mIGZ1bmN0aW9uc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBhcGlNYXAubGVuZ3RoOyBpKyspIHtcbiAgLy8gY2hlY2sgZm9yIGV4aXRGdWxsc2NyZWVuIGZ1bmN0aW9uXG4gIGlmIChhcGlNYXBbaV1bMV0gaW4gZG9jdW1lbnQpIHtcbiAgICBicm93c2VyQXBpID0gYXBpTWFwW2ldO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIG1hcCB0aGUgYnJvd3NlciBBUEkgbmFtZXMgdG8gdGhlIHNwZWMgQVBJIG5hbWVzXG5pZiAoYnJvd3NlckFwaSkge1xuICBmb3IgKGxldCBpPTA7IGk8YnJvd3NlckFwaS5sZW5ndGg7IGkrKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtpXV0gPSBicm93c2VyQXBpW2ldO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZ1bGxzY3JlZW5BcGk7XG4iLCJpbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5sZXQgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxubGV0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICogQHBhcmFtICB7U3RyaW5nPX0gdGFnTmFtZSAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICogQHBhcmFtICB7T2JqZWN0PX0gcHJvcGVydGllcyBFbGVtZW50IHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRWwgPSBmdW5jdGlvbih0YWdOYW1lPSdkaXYnLCBwcm9wZXJ0aWVzPXt9KXtcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBvYmouZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wTmFtZSwgdmFsKXtcbiAgICAvLyBOb3QgcmVtZW1iZXJpbmcgd2h5IHdlIHdlcmUgY2hlY2tpbmcgZm9yIGRhc2hcbiAgICAvLyBidXQgdXNpbmcgc2V0QXR0cmlidXRlIG1lYW5zIHlvdSBoYXZlIHRvIHVzZSBnZXRBdHRyaWJ1dGVcblxuICAgIC8vIFRoZSBjaGVjayBmb3IgZGFzaCBjaGVja3MgZm9yIHRoZSBhcmlhLSogYXR0cmlidXRlcywgbGlrZSBhcmlhLWxhYmVsLCBhcmlhLXZhbHVlbWluLlxuICAgIC8vIFRoZSBhZGRpdGlvbmFsIGNoZWNrIGZvciBcInJvbGVcIiBpcyBiZWNhdXNlIHRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgYWRkaW5nIGF0dHJpYnV0ZXMgZG9lcyBub3RcbiAgICAvLyBhZGQgdGhlIGF0dHJpYnV0ZSBcInJvbGVcIi4gTXkgZ3Vlc3MgaXMgYmVjYXVzZSBpdCdzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBpbiBzb21lIG5hbWVzcGFjZXMsIGFsdGhvdWdoXG4gICAgLy8gYnJvd3NlcnMgaGFuZGxlIHRoZSBhdHRyaWJ1dGUganVzdCBmaW5lLiBUaGUgVzNDIGFsbG93cyBmb3IgYXJpYS0qIGF0dHJpYnV0ZXMgdG8gYmUgdXNlZCBpbiBwcmUtSFRNTDUgZG9jcy5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmltZXIvI2FyaWFodG1sLiBVc2luZyBzZXRBdHRyaWJ1dGUgZ2V0cyBhcm91bmQgdGhpcyBwcm9ibGVtLlxuICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PSAncm9sZScpIHtcbiAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgIGVsW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBiZSB1cHBlcmNhc2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cmluZyl7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIE9iamVjdCBmdW5jdGlvbnMgY29udGFpbmVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG9iaiA9IHt9O1xuXG4vKipcbiAqIE9iamVjdC5jcmVhdGUgc2hpbSBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZVxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9iaiBPYmplY3QgdG8gdXNlIGFzIHByb3RvdHlwZVxuICogQHByaXZhdGVcbiAqL1xub2JqLmNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ob2JqKXtcbiAgLy9DcmVhdGUgYSBuZXcgZnVuY3Rpb24gY2FsbGVkICdGJyB3aGljaCBpcyBqdXN0IGFuIGVtcHR5IG9iamVjdC5cbiAgZnVuY3Rpb24gRigpIHt9XG5cbiAgLy90aGUgcHJvdG90eXBlIG9mIHRoZSAnRicgZnVuY3Rpb24gc2hvdWxkIHBvaW50IHRvIHRoZVxuICAvL3BhcmFtZXRlciBvZiB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uLlxuICBGLnByb3RvdHlwZSA9IG9iajtcblxuICAvL2NyZWF0ZSBhIG5ldyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBiYXNlZCBvZmYgb2YgdGhlICdGJyBmdW5jdGlvbi5cbiAgcmV0dXJuIG5ldyBGKCk7XG59O1xuXG4vKipcbiAqIExvb3AgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGluIGFuIG9iamVjdCBhbmQgY2FsbCBhIGZ1bmN0aW9uXG4gKiB3aG9zZSBhcmd1bWVudHMgYXJlIChrZXksdmFsdWUpXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgb2JqIE9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHByb3BlcnR5LlxuICogQHRoaXMgeyp9XG4gKiBAcHJpdmF0ZVxuICovXG5vYmouZWFjaCA9IGZ1bmN0aW9uKG9iaiwgZm4sIGNvbnRleHQpe1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3AuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGZuLmNhbGwoY29udGV4dCB8fCB0aGlzLCBrZXksIG9ialtrZXldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMgdG9nZXRoZXIgYW5kIHJldHVybiB0aGUgb3JpZ2luYWwuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqMlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xub2JqLm1lcmdlID0gZnVuY3Rpb24ob2JqMSwgb2JqMil7XG4gIGlmICghb2JqMikgeyByZXR1cm4gb2JqMTsgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqMil7XG4gICAgaWYgKGhhc093blByb3AuY2FsbChvYmoyLCBrZXkpKSB7XG4gICAgICBvYmoxW2tleV0gPSBvYmoyW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmoxO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYW5kIG1lcmdlIGFueSBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9iamVjdHNcbiAqIGluc3RlYWQgb2YganVzdCBvdmVyd3JpdGluZyBvbmUuIFVzZXMgdG8gbWVyZ2Ugb3B0aW9ucyBoYXNoZXNcbiAqIHdoZXJlIGRlZXBlciBkZWZhdWx0IHNldHRpbmdzIGFyZSBpbXBvcnRhbnQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajIgT3ZlcnJpZGluZyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICBOZXcgb2JqZWN0LiBPYmoxIGFuZCBPYmoyIHdpbGwgYmUgdW50b3VjaGVkLlxuICogQHByaXZhdGVcbiAqL1xub2JqLmRlZXBNZXJnZSA9IGZ1bmN0aW9uKG9iajEsIG9iajIpe1xuICB2YXIga2V5LCB2YWwxLCB2YWwyO1xuXG4gIC8vIG1ha2UgYSBjb3B5IG9mIG9iajEgc28gd2UncmUgbm90IG92ZXJ3cml0aW5nIG9yaWdpbmFsIHZhbHVlcy5cbiAgLy8gbGlrZSBwcm90b3R5cGUub3B0aW9uc18gYW5kIGFsbCBzdWIgb3B0aW9ucyBvYmplY3RzXG4gIG9iajEgPSBvYmouY29weShvYmoxKTtcblxuICBmb3IgKGtleSBpbiBvYmoyKXtcbiAgICBpZiAoaGFzT3duUHJvcC5jYWxsKG9iajIsIGtleSkpIHtcbiAgICAgIHZhbDEgPSBvYmoxW2tleV07XG4gICAgICB2YWwyID0gb2JqMltrZXldO1xuXG4gICAgICAvLyBDaGVjayBpZiBib3RoIHByb3BlcnRpZXMgYXJlIHB1cmUgb2JqZWN0cyBhbmQgZG8gYSBkZWVwIG1lcmdlIGlmIHNvXG4gICAgICBpZiAob2JqLmlzUGxhaW4odmFsMSkgJiYgb2JqLmlzUGxhaW4odmFsMikpIHtcbiAgICAgICAgb2JqMVtrZXldID0gb2JqLmRlZXBNZXJnZSh2YWwxLCB2YWwyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iajFba2V5XSA9IG9iajJba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajE7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBjb3B5IG9mIHRoZSBzdXBwbGllZCBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBjb3B5XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBDb3B5IG9mIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xub2JqLmNvcHkgPSBmdW5jdGlvbihvYmpUb0NvcHkpe1xuICByZXR1cm4gb2JqLm1lcmdlKHt9LCBvYmpUb0NvcHkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgcGxhaW4sIGFuZCBub3QgYSBkb20gbm9kZSBvciBhbnkgb2JqZWN0IHN1Yi1pbnN0YW5jZVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiBwbGFpbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAcHJpdmF0ZVxuICovXG5vYmouaXNQbGFpbiA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAhIW9ialxuICAgICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gICAgJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBBcnJheVxuKiAgU2luY2UgaW5zdGFuY2VvZiBBcnJheSB3aWxsIG5vdCB3b3JrIG9uIGFycmF5cyBjcmVhdGVkIGluIGFub3RoZXIgZnJhbWUgd2UgbmVlZCB0byB1c2UgQXJyYXkuaXNBcnJheSwgYnV0IHNpbmNlIElFOCBkb2VzIG5vdCBzdXBwb3J0IEFycmF5LmlzQXJyYXkgd2UgbmVlZCB0aGlzIHNoaW1cbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgcGxhaW4sIGZhbHNlIG90aGVyd2lzZVxuICogQHByaXZhdGVcbiAqL1xub2JqLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEJpbmQgKGEuay5hIHByb3h5IG9yIENvbnRleHQpLiBBIHNpbXBsZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBjb250ZXh0IG9mIGEgZnVuY3Rpb25cbiAgIEl0IGFsc28gc3RvcmVzIGEgdW5pcXVlIGlkIG9uIHRoZSBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgZWFzaWx5IHJlbW92ZWQgZnJvbSBldmVudHNcbiAqIEBwYXJhbSAgeyp9ICAgY29udGV4dCBUaGUgb2JqZWN0IHRvIGJpbmQgYXMgc2NvcGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBib3VuZCB0byBhIHNjb3BlXG4gKiBAcGFyYW0gIHtOdW1iZXI9fSAgIHVpZCAgICAgQW4gb3B0aW9uYWwgdW5pcXVlIElEIGZvciB0aGUgZnVuY3Rpb24gdG8gYmUgc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBiaW5kID0gZnVuY3Rpb24oY29udGV4dCwgZm4sIHVpZCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxuICBpZiAoIWZuLmd1aWQpIHsgZm4uZ3VpZCA9IGd1aWQrKzsgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IGZ1bmN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgY29udGV4dFxuICBsZXQgcmV0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQWxsb3cgZm9yIHRoZSBhYmlsaXR5IHRvIGluZGl2aWR1YWxpemUgdGhpcyBmdW5jdGlvblxuICAvLyBOZWVkZWQgaW4gdGhlIGNhc2Ugd2hlcmUgbXVsdGlwbGUgb2JqZWN0cyBtaWdodCBzaGFyZSB0aGUgc2FtZSBwcm90b3R5cGVcbiAgLy8gSUYgYm90aCBpdGVtcyBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbiwgdGhlbiB5b3UgdHJ5IHRvIHJlbW92ZSBqdXN0IG9uZVxuICAvLyBpdCB3aWxsIHJlbW92ZSBib3RoIGJlY2F1c2UgdGhleSBib3RoIGhhdmUgdGhlIHNhbWUgZ3VpZC5cbiAgLy8gd2hlbiB1c2luZyB0aGlzLCB5b3UgbmVlZCB0byB1c2UgdGhlIGJpbmQgbWV0aG9kIHdoZW4geW91IHJlbW92ZSB0aGUgbGlzdGVuZXIgYXMgd2VsbC5cbiAgLy8gY3VycmVudGx5IHVzZWQgaW4gdGV4dCB0cmFja3NcbiAgcmV0Lmd1aWQgPSAodWlkKSA/IHVpZCArICdfJyArIGZuLmd1aWQgOiBmbi5ndWlkO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEVsZW1lbnQgRGF0YSBTdG9yZS4gQWxsb3dzIGZvciBiaW5kaW5nIGRhdGEgdG8gYW4gZWxlbWVudCB3aXRob3V0IHB1dHRpbmcgaXQgZGlyZWN0bHkgb24gdGhlIGVsZW1lbnQuXG4gKiBFeC4gRXZlbnQgbGlzdGVuZXJzIGFyZSBzdG9yZWQgaGVyZS5cbiAqIChhbHNvIGZyb20ganNuaW5qYS5jb20sIHNsaWdodGx5IG1vZGlmaWVkIGFuZCB1cGRhdGVkIGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBndWlkID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgYXR0cmlidXRlIG5hbWUgdG8gc3RvcmUgYW4gZWxlbWVudCdzIGd1aWQgaW5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleHBhbmRvID0gJ3ZkYXRhJyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IHdoZXJlIGRhdGEgZm9yIGFuIGVsZW1lbnQgaXMgc3RvcmVkXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIHN0b3JlIGRhdGEgZm9yLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldERhdGEgPSBmdW5jdGlvbihlbCl7XG4gIHZhciBpZCA9IGVsW2V4cGFuZG9dO1xuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBlbFtleHBhbmRvXSA9IGd1aWQrKztcbiAgfVxuICBpZiAoIWNhY2hlW2lkXSkge1xuICAgIGNhY2hlW2lkXSA9IHt9O1xuICB9XG4gIHJldHVybiBjYWNoZVtpZF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCB3aGVyZSBkYXRhIGZvciBhbiBlbGVtZW50IGlzIHN0b3JlZFxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBzdG9yZSBkYXRhIGZvci5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBoYXNEYXRhID0gZnVuY3Rpb24oZWwpe1xuICB2YXIgaWQgPSBlbFtleHBhbmRvXTtcbiAgcmV0dXJuICEoIWlkIHx8IGlzRW1wdHkoY2FjaGVbaWRdKSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBkYXRhIGZvciB0aGUgZWxlbWVudCBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIGd1aWQgYXR0ciBmcm9tIGdldEVsZW1lbnRCeUlkXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCBSZW1vdmUgZGF0YSBmb3IgYW4gZWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlbW92ZURhdGEgPSBmdW5jdGlvbihlbCl7XG4gIHZhciBpZCA9IGVsW2V4cGFuZG9dO1xuICBpZiAoIWlkKSB7IHJldHVybjsgfVxuICAvLyBSZW1vdmUgYWxsIHN0b3JlZCBkYXRhXG4gIC8vIENoYW5nZWQgdG8gPSBudWxsXG4gIC8vIGh0dHA6Ly9jb2Rpbmcuc21hc2hpbmdtYWdhemluZS5jb20vMjAxMi8xMS8wNS93cml0aW5nLWZhc3QtbWVtb3J5LWVmZmljaWVudC1qYXZhc2NyaXB0L1xuICAvLyBjYWNoZVtpZF0gPSBudWxsO1xuICBkZWxldGUgY2FjaGVbaWRdO1xuXG4gIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBwcm9wZXJ0eSBmcm9tIHRoZSBET00gbm9kZVxuICB0cnkge1xuICAgIGRlbGV0ZSBlbFtleHBhbmRvXTtcbiAgfSBjYXRjaChlKSB7XG4gICAgaWYgKGVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGV4cGFuZG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IGFwcGVhciB0byBzdXBwb3J0IHJlbW92ZUF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICAgICAgZWxbZXhwYW5kb10gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIC8vIElubHVkZSBudWxsIHByb3BlcnRpZXMgYXMgZW1wdHkuXG4gICAgaWYgKG9ialtwcm9wXSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICogQHByaXZhdGVcbiAqL1xudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NUb0NoZWNrKXtcbiAgcmV0dXJuICgoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NUb0NoZWNrICsgJyAnKSAhPT0gLTEpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NUb0FkZCl7XG4gIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lID09PSAnJyA/IGNsYXNzVG9BZGQgOiBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzVG9BZGQ7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byByZW1vdmUgZnJvbSBjbGFzcyBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0FkZCBDbGFzc25hbWUgdG8gcmVtb3ZlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKXtcbiAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKSkge3JldHVybjt9XG5cbiAgbGV0IGNsYXNzTmFtZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gIC8vIG5vIGFyci5pbmRleE9mIGluIGllOCwgYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGEgYmlnIHNoaW1cbiAgZm9yIChsZXQgaSA9IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoY2xhc3NOYW1lc1tpXSA9PT0gY2xhc3NUb1JlbW92ZSkge1xuICAgICAgY2xhc3NOYW1lcy5zcGxpY2UoaSwxKTtcbiAgICB9XG4gIH1cblxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgdmlkZW8gY2FwYWJpbGl0aWVzXG4gKiBAdHlwZSB7RWxlbWVudH1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIFRFU1RfVklEID0gY3JlYXRlRWwoJ3ZpZGVvJyk7XG5sZXQgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xudHJhY2sua2luZCA9ICdjYXB0aW9ucyc7XG50cmFjay5zcmNsYW5nID0gJ2VuJztcbnRyYWNrLmxhYmVsID0gJ0VuZ2xpc2gnO1xuVEVTVF9WSUQuYXBwZW5kQ2hpbGQodHJhY2spO1xuXG4vKipcbiAqIFVzZXJhZ2VudCBmb3IgYnJvd3NlciB0ZXN0aW5nLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIFVTRVJfQUdFTlQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4vKipcbiAqIERldmljZSBpcyBhbiBpUGhvbmVcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSVNfSVBIT05FID0gKC9pUGhvbmUvaSkudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JUEFEID0gKC9pUGFkL2kpLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSVBPRCA9ICgvaVBvZC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0lPUyA9IElTX0lQSE9ORSB8fCBJU19JUEFEIHx8IElTX0lQT0Q7XG5cbnZhciBJT1NfVkVSU0lPTiA9IChmdW5jdGlvbigpe1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9PUyAoXFxkKylfL2kpO1xuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHsgcmV0dXJuIG1hdGNoWzFdOyB9XG59KSgpO1xuXG52YXIgSVNfQU5EUk9JRCA9ICgvQW5kcm9pZC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIEFORFJPSURfVkVSU0lPTiA9IChmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyBtYXRjaGVzIEFuZHJvaWQgTWFqb3IuTWlub3IuUGF0Y2ggdmVyc2lvbnNcbiAgLy8gQU5EUk9JRF9WRVJTSU9OIGlzIE1ham9yLk1pbm9yIGFzIGEgTnVtYmVyLCBpZiBNaW5vciBpc24ndCBhdmFpbGFibGUsIHRoZW4gb25seSBNYWpvciBpcyByZXR1cm5lZFxuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9BbmRyb2lkIChcXGQrKSg/OlxcLihcXGQrKSk/KD86XFwuKFxcZCspKSovaSksXG4gICAgbWFqb3IsXG4gICAgbWlub3I7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbWFqb3IgPSBtYXRjaFsxXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgbWlub3IgPSBtYXRjaFsyXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcblxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSArICcuJyArIG1hdGNoWzJdKTtcbiAgfSBlbHNlIGlmIChtYWpvcikge1xuICAgIHJldHVybiBtYWpvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSkoKTtcbi8vIE9sZCBBbmRyb2lkIGlzIGRlZmluZWQgYXMgVmVyc2lvbiBvbGRlciB0aGFuIDIuMywgYW5kIHJlcXVpcmluZyBhIHdlYmtpdCB2ZXJzaW9uIG9mIHRoZSBhbmRyb2lkIGJyb3dzZXJcbnZhciBJU19PTERfQU5EUk9JRCA9IElTX0FORFJPSUQgJiYgKC93ZWJraXQvaSkudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XG5cbnZhciBJU19GSVJFRk9YID0gKC9GaXJlZm94L2kpLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfQ0hST01FID0gKC9DaHJvbWUvaSkudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QoVVNFUl9BR0VOVCk7XG5cbnZhciBUT1VDSF9FTkFCTEVEID0gISEoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG52YXIgQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRCA9ICdiYWNrZ3JvdW5kU2l6ZScgaW4gVEVTVF9WSUQuc3R5bGU7XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCAgICAgICAgIFRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtICB7T2JqZWN0PX0gYXR0cmlidXRlcyBFbGVtZW50IGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzZXRFbGVtZW50QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsLCBhdHRyaWJ1dGVzKXtcbiAgb2JqLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCAoYXR0clZhbHVlID09PSB0cnVlID8gJycgOiBhdHRyVmFsdWUpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IHRhZyBFbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IHRhZyBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ2V0RWxlbWVudEF0dHJpYnV0ZXMgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgb2JqLCBrbm93bkJvb2xlYW5zLCBhdHRycywgYXR0ck5hbWUsIGF0dHJWYWw7XG5cbiAgb2JqID0ge307XG5cbiAgLy8ga25vd24gYm9vbGVhbiBhdHRyaWJ1dGVzXG4gIC8vIHdlIGNhbiBjaGVjayBmb3IgbWF0Y2hpbmcgYm9vbGVhbiBwcm9wZXJ0aWVzLCBidXQgb2xkZXIgYnJvd3NlcnNcbiAgLy8gd29uJ3Qga25vdyBhYm91dCBIVE1MNSBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCB3ZSBzdGlsbCByZWFkIGZyb21cbiAga25vd25Cb29sZWFucyA9ICcsJysnYXV0b3BsYXksY29udHJvbHMsbG9vcCxtdXRlZCxkZWZhdWx0JysnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cnMgPSB0YWcuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGkgPSBhdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJythdHRyTmFtZSsnLCcpICE9PSAtMSkge1xuICAgICAgICAvLyB0aGUgdmFsdWUgb2YgYW4gaW5jbHVkZWQgYm9vbGVhbiBhdHRyaWJ1dGUgaXMgdHlwaWNhbGx5IGFuIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZyAoJycpIHdoaWNoIHdvdWxkIGVxdWFsIGZhbHNlIGlmIHdlIGp1c3QgY2hlY2sgZm9yIGEgZmFsc2UgdmFsdWUuXG4gICAgICAgIC8vIHdlIGFsc28gZG9uJ3Qgd2FudCBzdXBwb3J0IGJhZCBjb2RlIGxpa2UgYXV0b3BsYXk9J2ZhbHNlJ1xuICAgICAgICBhdHRyVmFsID0gKGF0dHJWYWwgIT09IG51bGwpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYmpbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbXB1dGVkIHN0eWxlIHZhbHVlIGZvciBhbiBlbGVtZW50XG4gKiBGcm9tIGh0dHA6Ly9yb2JlcnRueW1hbi5jb20vMjAwNi8wNC8yNC9nZXQtdGhlLXJlbmRlcmVkLXN0eWxlLW9mLWFuLWVsZW1lbnQvXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCAgICAgICAgRWxlbWVudCB0byBnZXQgc3R5bGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0ckNzc1J1bGUgU3R5bGUgbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgIFN0eWxlIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ2V0Q29tcHV0ZWREaW1lbnNpb24gPSBmdW5jdGlvbihlbCwgc3RyQ3NzUnVsZSl7XG4gIHZhciBzdHJWYWx1ZSA9ICcnO1xuICBpZihkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKXtcbiAgICBzdHJWYWx1ZSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKHN0ckNzc1J1bGUpO1xuXG4gIH0gZWxzZSBpZihlbC5jdXJyZW50U3R5bGUpe1xuICAgIC8vIElFOCBXaWR0aC9IZWlnaHQgc3VwcG9ydFxuICAgIGxldCB1cHBlckNhc2VkUnVsZSA9IHN0ckNzc1J1bGUuc3Vic3RyKDAsMSkudG9VcHBlckNhc2UoKSArIHN0ckNzc1J1bGUuc3Vic3RyKDEpO1xuICAgIHN0clZhbHVlID0gZWxbYGNsaWVudCR7dXBwZXJDYXNlZFJ1bGV9YF0gKyAncHgnO1xuICB9XG4gIHJldHVybiBzdHJWYWx1ZTtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYXMgdGhlIGZpcnN0IGNoaWxkIG5vZGUgb2YgYW5vdGhlclxuICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICBFbGVtZW50IHRvIGluc2VydFxuICogQHBhcmFtICB7W3R5cGVdfSBwYXJlbnQgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xuICogQHByaXZhdGVcbiAqL1xudmFyIGluc2VydEZpcnN0ID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCl7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59O1xuXG4vKipcbiAqIE9iamVjdCB0byBob2xkIGJyb3dzZXIgc3VwcG9ydCBpbmZvcm1hdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBicm93c2VyID0ge307XG5cbi8qKlxuICogU2hvcnRoYW5kIGZvciBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgpXG4gKiBBbHNvIGFsbG93cyBmb3IgQ1NTIChqUXVlcnkpIElEIHN5bnRheC4gQnV0IG5vdGhpbmcgb3RoZXIgdGhhbiBJRHMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICBFbGVtZW50IElEXG4gKiBAcmV0dXJuIHtFbGVtZW50fSAgICBFbGVtZW50IHdpdGggc3VwcGxpZWQgSURcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbCA9IGZ1bmN0aW9uKGlkKXtcbiAgaWYgKGlkLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgIGlkID0gaWQuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNlY29uZHMgTnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgdHVybmVkIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSAge051bWJlcn0gZ3VpZGUgICBOdW1iZXIgKGluIHNlY29uZHMpIHRvIG1vZGVsIHRoZSBzdHJpbmcgYWZ0ZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaW1lIGZvcm1hdHRlZCBhcyBIOk1NOlNTIG9yIE06U1NcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBmb3JtYXRUaW1lID0gZnVuY3Rpb24oc2Vjb25kcywgZ3VpZGU9c2Vjb25kcykge1xuICBsZXQgcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAlIDYwKTtcbiAgbGV0IG0gPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCAlIDYwKTtcbiAgbGV0IGggPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgY29uc3QgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XG4gIGNvbnN0IGdoID0gTWF0aC5mbG9vcihndWlkZSAvIDM2MDApO1xuXG4gIC8vIGhhbmRsZSBpbnZhbGlkIHRpbWVzXG4gIGlmIChpc05hTihzZWNvbmRzKSB8fCBzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgIC8vICctJyBpcyBmYWxzZSBmb3IgYWxsIHJlbGF0aW9uYWwgb3BlcmF0b3JzIChlLmcuIDwsID49KSBzbyB0aGlzIHNldHRpbmdcbiAgICAvLyB3aWxsIGFkZCB0aGUgbWluaW11bSBudW1iZXIgb2YgZmllbGRzIHNwZWNpZmllZCBieSB0aGUgZ3VpZGVcbiAgICBoID0gbSA9IHMgPSAnLSc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHNob3cgaG91cnNcbiAgaCA9IChoID4gMCB8fCBnaCA+IDApID8gaCArICc6JyA6ICcnO1xuXG4gIC8vIElmIGhvdXJzIGFyZSBzaG93aW5nLCB3ZSBtYXkgbmVlZCB0byBhZGQgYSBsZWFkaW5nIHplcm8uXG4gIC8vIEFsd2F5cyBzaG93IGF0IGxlYXN0IG9uZSBkaWdpdCBvZiBtaW51dGVzLlxuICBtID0gKCgoaCB8fCBnbSA+PSAxMCkgJiYgbSA8IDEwKSA/ICcwJyArIG0gOiBtKSArICc6JztcblxuICAvLyBDaGVjayBpZiBsZWFkaW5nIHplcm8gaXMgbmVlZCBmb3Igc2Vjb25kc1xuICBzID0gKHMgPCAxMCkgPyAnMCcgKyBzIDogcztcblxuICByZXR1cm4gaCArIG0gKyBzO1xufTtcblxuLy8gQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xudmFyIGJsb2NrVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xufTtcbi8vIFR1cm4gb2ZmIHRleHQgc2VsZWN0aW9uIGJsb2NraW5nXG52YXIgdW5ibG9ja1RleHRTZWxlY3Rpb24gPSBmdW5jdGlvbigpeyBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcblxuLyoqXG4gKiBUcmltIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kcyBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBUcmltbWVkIHN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xudmFyIHRyaW0gPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gKHN0cisnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcm91bmQgb2ZmIGEgbnVtYmVyIHRvIGEgZGVjaW1hbCBwbGFjZVxuICogQHBhcmFtICB7TnVtYmVyfSBudW0gTnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlYyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm4ge051bWJlcn0gICAgIFJvdW5kZWQgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcm91bmQgPSBmdW5jdGlvbihudW0sIGRlYz0wKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSpNYXRoLnBvdygxMCxkZWMpKS9NYXRoLnBvdygxMCxkZWMpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIGEgZmFrZSBUaW1lUmFuZ2Ugb2JqZWN0XG4gKiBNaW1pY3MgYW4gSFRNTDUgdGltZSByYW5nZSBpbnN0YW5jZSwgd2hpY2ggaGFzIGZ1bmN0aW9ucyB0aGF0XG4gKiByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGEgcmFuZ2VcbiAqIFRpbWVSYW5nZXMgYXJlIHJldHVybmVkIGJ5IHRoZSBidWZmZXJlZCgpIG1ldGhvZFxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCBTdGFydCB0aW1lIGluIHNlY29uZHNcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kICAgRW5kIHRpbWUgaW4gc2Vjb25kc1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICBGYWtlIFRpbWVSYW5nZSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVUaW1lUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKXtcbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IDEsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhcnQ7IH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIGVuZDsgfVxuICB9O1xufTtcblxuLyoqXG4gKiBBZGQgdG8gbG9jYWwgc3RvcmFnZSAobWF5YmUgcmVtb3ZhYmxlKVxuICogQHByaXZhdGVcbiAqL1xudmFyIHNldExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICB0cnkge1xuICAgIC8vIElFIHdhcyB0aHJvd2luZyBlcnJvcnMgcmVmZXJlbmNpbmcgdGhlIHZhciBhbnl3aGVyZSB3aXRob3V0IHRoaXNcbiAgICBsZXQgbG9jYWxTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZSB8fCBmYWxzZTtcbiAgICBpZiAoIWxvY2FsU3RvcmFnZSkgeyByZXR1cm47IH1cbiAgICBsb2NhbFN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICBpZiAoZS5jb2RlID09IDIyIHx8IGUuY29kZSA9PSAxMDE0KSB7IC8vIFdlYmtpdCA9PSAyMiAvIEZpcmVmb3ggPT0gMTAxNFxuICAgICAgbG9nKCdMb2NhbFN0b3JhZ2UgRnVsbCAoVmlkZW9KUyknLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGUuY29kZSA9PSAxOCkge1xuICAgICAgICBsb2coJ0xvY2FsU3RvcmFnZSBub3QgYWxsb3dlZCAoVmlkZW9KUyknLCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZygnTG9jYWxTdG9yYWdlIEVycm9yIChWaWRlb0pTKScsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYWJzb2x1dGUgdmVyc2lvbiBvZiByZWxhdGl2ZSBVUkwuIFVzZWQgdG8gdGVsbCBmbGFzaCBjb3JyZWN0IFVSTC5cbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDcwODMyL2dldHRpbmctYW4tYWJzb2x1dGUtdXJsLWZyb20tYS1yZWxhdGl2ZS1vbmUtaWU2LWlzc3VlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBVUkwgdG8gbWFrZSBhYnNvbHV0ZVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgQWJzb2x1dGUgVVJMXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ2V0QWJzb2x1dGVVUkwgPSBmdW5jdGlvbih1cmwpe1xuICAvLyBDaGVjayBpZiBhYnNvbHV0ZSBVUkxcbiAgaWYgKCF1cmwubWF0Y2goL15odHRwcz86XFwvXFwvLykpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGFic29sdXRlIFVSTC4gRmxhc2ggaG9zdGVkIG9mZi1zaXRlIG5lZWRzIGFuIGFic29sdXRlIFVSTC5cbiAgICB1cmwgPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgaW5uZXJIVE1MOiBgPGEgaHJlZj1cIiR7dXJsfVwiPng8L2E+YFxuICAgIH0pLmZpcnN0Q2hpbGQuaHJlZjtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTFxuICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byBwYXJzZVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXG4gKi9cbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICBjb25zdCBwcm9wcyA9IFsncHJvdG9jb2wnLCAnaG9zdG5hbWUnLCAncG9ydCcsICdwYXRobmFtZScsICdzZWFyY2gnLCAnaGFzaCcsICdob3N0J107XG5cbiAgLy8gYWRkIHRoZSB1cmwgdG8gYW4gYW5jaG9yIGFuZCBsZXQgdGhlIGJyb3dzZXIgcGFyc2UgdGhlIFVSTFxuICBsZXQgYSA9IGNyZWF0ZUVsKCdhJywgeyBocmVmOiB1cmwgfSk7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIGxldCBhZGRUb0JvZHkgPSAoYS5ob3N0ID09PSAnJyAmJiBhLnByb3RvY29sICE9PSAnZmlsZTonKTtcbiAgbGV0IGRpdjtcbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGNyZWF0ZUVsKCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gYDxhIGhyZWY9XCIke3VybH1cIj48L2E+YDtcbiAgICBhID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgLy8gcHJldmVudCB0aGUgZGl2IGZyb20gYWZmZWN0aW5nIGxheW91dFxuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsgcG9zaXRpb246YWJzb2x1dGU7Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICB9XG5cbiAgLy8gQ29weSB0aGUgc3BlY2lmaWMgVVJMIHByb3BlcnRpZXMgdG8gYSBuZXcgb2JqZWN0XG4gIC8vIFRoaXMgaXMgYWxzbyBuZWVkZWQgZm9yIElFOCBiZWNhdXNlIHRoZSBhbmNob3IgbG9zZXMgaXRzXG4gIC8vIHByb3BlcnRpZXMgd2hlbiBpdCdzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gIGxldCBkZXRhaWxzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xuICB9XG5cbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXG4gIC8vIGEgcG9ydCBpZGVudGlmaWVyIGlzIGFkZGVkIGZvciBzdGFuZGFyZCBwb3J0cywgc3RyaXAgaXQuXG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XG4gIH1cbiAgaWYgKGRldGFpbHMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo0NDMkLywgJycpO1xuICB9XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHJldHVybiBkZXRhaWxzO1xufTtcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUgYW5kIGhpc3RvcnkgYmFzZWQgb24gdGhlIHR5cGUgb2YgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBtZXNzYWdlLCBvciBgbnVsbGAgZm9yIGBsb2dgXG4gKiBAcGFyYW0gIHtbdHlwZV19IGFyZ3MgVGhlIGFyZ3MgdG8gYmUgcGFzc2VkIHRvIHRoZSBsb2dcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9sb2dUeXBlKHR5cGUsIGFyZ3Mpe1xuICAvLyBjb252ZXJ0IGFyZ3MgdG8gYW4gYXJyYXkgdG8gZ2V0IGFycmF5IGZ1bmN0aW9uc1xuICBsZXQgYXJnc0FycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gIC8vIGlmIHRoZXJlJ3Mgbm8gY29uc29sZSB0aGVuIGRvbid0IHRyeSB0byBvdXRwdXQgbWVzc2FnZXNcbiAgLy8gdGhleSB3aWxsIHN0aWxsIGJlIHN0b3JlZCBpbiBMaWIubG9nLmhpc3RvcnlcbiAgLy8gV2FzIHNldHRpbmcgdGhlc2Ugb25jZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24sIGJ1dCBjb250YWluaW5nIHRoZW1cbiAgLy8gaW4gdGhlIGZ1bmN0aW9uIG1ha2VzIGl0IGVhc2llciB0byB0ZXN0IGNhc2VzIHdoZXJlIGNvbnNvbGUgZG9lc24ndCBleGlzdFxuICBsZXQgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBsZXQgY29uc29sZSA9IHdpbmRvd1snY29uc29sZSddIHx8IHtcbiAgICAnbG9nJzogbm9vcCxcbiAgICAnd2Fybic6IG5vb3AsXG4gICAgJ2Vycm9yJzogbm9vcFxuICB9O1xuXG4gIGlmICh0eXBlKSB7XG4gICAgLy8gYWRkIHRoZSB0eXBlIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZVxuICAgIGFyZ3NBcnJheS51bnNoaWZ0KHR5cGUudG9VcHBlckNhc2UoKSsnOicpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgdG8gbG9nIHdpdGggbm8gcHJlZml4XG4gICAgdHlwZSA9ICdsb2cnO1xuICB9XG5cbiAgLy8gYWRkIHRvIGhpc3RvcnlcbiAgbG9nLmhpc3RvcnkucHVzaChhcmdzQXJyYXkpO1xuXG4gIC8vIGFkZCBjb25zb2xlIHByZWZpeCBhZnRlciBhZGRpbmcgdG8gaGlzdG9yeVxuICBhcmdzQXJyYXkudW5zaGlmdCgnVklERU9KUzonKTtcblxuICAvLyBjYWxsIGFwcHJvcHJpYXRlIGxvZyBmdW5jdGlvblxuICBpZiAoY29uc29sZVt0eXBlXS5hcHBseSkge1xuICAgIGNvbnNvbGVbdHlwZV0uYXBwbHkoY29uc29sZSwgYXJnc0FycmF5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZTggZG9lc24ndCBhbGxvdyBlcnJvci5hcHBseSwgYnV0IGl0IHdpbGwganVzdCBqb2luKCkgdGhlIGFycmF5IGFueXdheVxuICAgIGNvbnNvbGVbdHlwZV0oYXJnc0FycmF5LmpvaW4oJyAnKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2cgcGxhaW4gZGVidWcgbWVzc2FnZXNcbiAqL1xudmFyIGxvZyA9IGZ1bmN0aW9uKCl7XG4gIF9sb2dUeXBlKG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEtlZXAgYSBoaXN0b3J5IG9mIGxvZyBtZXNzYWdlc1xuICogQHR5cGUge0FycmF5fVxuICovXG5sb2cuaGlzdG9yeSA9IFtdO1xuXG4vKipcbiAqIExvZyBlcnJvciBtZXNzYWdlc1xuICovXG5sb2cuZXJyb3IgPSBmdW5jdGlvbigpe1xuICBfbG9nVHlwZSgnZXJyb3InLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBMb2cgd2FybmluZyBtZXNzYWdlc1xuICovXG5sb2cud2FybiA9IGZ1bmN0aW9uKCl7XG4gIF9sb2dUeXBlKCd3YXJuJywgYXJndW1lbnRzKTtcbn07XG5cbi8vIE9mZnNldCBMZWZ0XG4vLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb20gSm9obiBSZXNpZyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvZ2V0Ym91bmRpbmdjbGllbnRyZWN0LWlzLWF3ZXNvbWUvXG52YXIgZmluZFBvc2l0aW9uID0gZnVuY3Rpb24oZWwpIHtcbiAgbGV0IGJveDtcblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGlmICghYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gIGNvbnN0IGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcbiAgY29uc3QgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgY29uc3QgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgY29uc3QgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcblxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHJvdW5kKGxlZnQpLFxuICAgIHRvcDogcm91bmQodG9wKVxuICB9O1xufTtcblxuLyoqXG4gKiBBcnJheSBmdW5jdGlvbnMgY29udGFpbmVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGFyciA9IHt9O1xuXG4vKlxuICogTG9vcHMgdGhyb3VnaCBhbiBhcnJheSBhbmQgcnVucyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW5zaWRlIGl0LlxuICogQHBhcmFtICB7QXJyYXl9ICAgIGFycmF5ICAgICAgIFRoZSBhcnJheVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAgIFRoZSBmdW5jdGlvbiB0byBiZSBydW4gZm9yIGVhY2ggaXRlbVxuICogQHBhcmFtICB7Kn0gICAgICAgIHRoaXNBcmcgICAgIFRoZSBgdGhpc2AgYmluZGluZyBvZiBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSAgICAgICAgICAgICAgIFRoZSBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuYXJyLmZvckVhY2ggPSBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgdGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcblxuICBpZiAob2JqLmlzQXJyYXkoYXJyYXkpICYmIGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGFzc2VkIGZpbGUgbmFtZS4gSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGlmIHlvdSBwYXNzIGFuIGludmFsaWQgcGF0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgICBwYXRoICAgIFRoZSBmaWxlTmFtZSBwYXRoIGxpa2UgJy9wYXRoL3RvL2ZpbGUubXA0J1xuICogQHJldHVybnMge1N0cmluZ30gICAgICAgICAgVGhlIGV4dGVuc2lvbiBpbiBsb3dlciBjYXNlIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBubyBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXG4gKi9cbnZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZih0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpe1xuICAgIGxldCBzcGxpdFBhdGhSZSA9IC9eKFxcLz8pKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/KShcXC4oW15cXC5cXC9cXD9dKykpKSg/OltcXC9dKnxbXFw/XS4qKSQvaTtcbiAgICBsZXQgcGF0aFBhcnRzID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKTtcblxuICAgIGlmIChwYXRoUGFydHMpIHtcbiAgICAgIHJldHVybiBwYXRoUGFydHMucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnQge1xuICBjcmVhdGVFbCxcbiAgY2FwaXRhbGl6ZSxcbiAgb2JqLFxuICBpc05hTixcbiAgYmluZCxcbiAgY2FjaGUsXG4gIGd1aWQsXG4gIGV4cGFuZG8sXG4gIGdldERhdGEsXG4gIGhhc0RhdGEsXG4gIHJlbW92ZURhdGEsXG4gIGlzRW1wdHksXG4gIGhhc0NsYXNzLFxuICBhZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3MsXG4gIFRFU1RfVklELFxuICBVU0VSX0FHRU5ULFxuICBJU19JUEhPTkUsXG4gIElTX0lQQUQsXG4gIElTX0lQT0QsXG4gIElTX0lPUyxcbiAgSU9TX1ZFUlNJT04sXG4gIElTX0FORFJPSUQsXG4gIEFORFJPSURfVkVSU0lPTixcbiAgSVNfT0xEX0FORFJPSUQsXG4gIElTX0ZJUkVGT1gsXG4gIElTX0lFOCxcbiAgSVNfQ0hST01FLFxuICBUT1VDSF9FTkFCTEVELFxuICBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVELFxuICBzZXRFbGVtZW50QXR0cmlidXRlcyxcbiAgZ2V0RWxlbWVudEF0dHJpYnV0ZXMsXG4gIGdldENvbXB1dGVkRGltZW5zaW9uLFxuICBpbnNlcnRGaXJzdCxcbiAgYnJvd3NlcixcbiAgZWwsXG4gIGZvcm1hdFRpbWUsXG4gIGJsb2NrVGV4dFNlbGVjdGlvbixcbiAgdW5ibG9ja1RleHRTZWxlY3Rpb24sXG4gIHRyaW0sXG4gIHJvdW5kLFxuICBjcmVhdGVUaW1lUmFuZ2UsXG4gIHNldExvY2FsU3RvcmFnZSxcbiAgZ2V0QWJzb2x1dGVVUkwsXG4gIHBhcnNlVXJsLFxuICBsb2csXG4gIGZpbmRQb3NpdGlvbixcbiAgYXJyLFxuICBnZXRGaWxlRXh0ZW5zaW9uXG59O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5cbi8qIExvYWRpbmcgU3Bpbm5lclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogTG9hZGluZyBzcGlubmVyIGZvciB3YWl0aW5nIGV2ZW50c1xuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTG9hZGluZ1NwaW5uZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1sb2FkaW5nLXNwaW5uZXInXG4gICAgfSk7XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkaW5nU3Bpbm5lcicsIExvYWRpbmdTcGlubmVyKTtcbmV4cG9ydCBkZWZhdWx0IExvYWRpbmdTcGlubmVyO1xuIiwiaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcblxuLyoqXG4gKiBDdXN0b20gTWVkaWFFcnJvciB0byBtaW1pYyB0aGUgSFRNTDUgTWVkaWFFcnJvclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIG1lZGlhIGVycm9yIGNvZGVcbiAqL1xubGV0IE1lZGlhRXJyb3IgPSBmdW5jdGlvbihjb2RlKXtcbiAgaWYgKHR5cGVvZiBjb2RlID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSBjb2RlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlID09PSAnb2JqZWN0JykgeyAvLyBvYmplY3RcbiAgICBMaWIub2JqLm1lcmdlKHRoaXMsIGNvZGUpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBNZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlc1t0aGlzLmNvZGVdIHx8ICcnO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWRcbiAqIE1lZGlhRXJyb3IgdHlwZXNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLmNvZGUgPSAwO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYmUgc2hvd24gd2l0aCB0aGUgZXJyb3IuXG4gKiBNZXNzYWdlIGlzIG5vdCBwYXJ0IG9mIHRoZSBIVE1MNSB2aWRlbyBzcGVjXG4gKiBidXQgYWxsb3dzIGZvciBtb3JlIGluZm9ybWF0aXZlIGN1c3RvbSBlcnJvcnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnNcbiAqIHRvIGFsbG93IGV2ZW4gbW9yZSBkZXRhaWwgYWJvdXQgdGhlIGVycm9yLlxuICogRm9yIGV4YW1wbGUgdGhlIEhMUyBwbHVnaW4gbWlnaHQgcHJvdmlkZSB0aGUgc3BlY2lmaWNcbiAqIEhUVFAgc3RhdHVzIGNvZGUgdGhhdCB3YXMgcmV0dXJuZWQgd2hlbiB0aGUgZXJyb3JcbiAqIG9jY3VycmVkLCB0aGVuIGFsbG93aW5nIGEgY3VzdG9tIGVycm9yIG92ZXJsYXlcbiAqIHRvIGRpc3BsYXkgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEB0eXBlIHtbdHlwZV19XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbk1lZGlhRXJyb3IuZXJyb3JUeXBlcyA9IFtcbiAgJ01FRElBX0VSUl9DVVNUT00nLCAgICAgICAgICAgIC8vID0gMFxuICAnTUVESUFfRVJSX0FCT1JURUQnLCAgICAgICAgICAgLy8gPSAxXG4gICdNRURJQV9FUlJfTkVUV09SSycsICAgICAgICAgICAvLyA9IDJcbiAgJ01FRElBX0VSUl9ERUNPREUnLCAgICAgICAgICAgIC8vID0gM1xuICAnTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEJywgLy8gPSA0XG4gICdNRURJQV9FUlJfRU5DUllQVEVEJyAgICAgICAgICAvLyA9IDVcbl07XG5cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIHZpZGVvIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIHZpZGVvIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSB2aWRlbyBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgdmlkZW8gdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgdmlkZW8gY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIHZpZGVvIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVkaWFFcnJvcjtcbiIsImltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uLmpzJztcbmltcG9ydCBNZW51IGZyb20gJy4vbWVudS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcblxuLyoqXG4gKiBBIGJ1dHRvbiBjbGFzcyB3aXRoIGEgcG9wdXAgbWVudVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1lbnVCdXR0b24gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB0aGlzLm9uKCdrZXlkb3duJywgdGhpcy5vbktleVByZXNzKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgbGV0IG1lbnUgPSB0aGlzLmNyZWF0ZU1lbnUoKTtcblxuICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXyk7XG5cbiAgICAvLyBBZGQgYSB0aXRsZSBsaXN0IGl0ZW0gdG8gdGhlIHRvcFxuICAgIGlmICh0aGlzLm9wdGlvbnMoKS50aXRsZSkge1xuICAgICAgbWVudS5jb250ZW50RWwoKS5hcHBlbmRDaGlsZChMaWIuY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogTGliLmNhcGl0YWxpemUodGhpcy5vcHRpb25zKCkudGl0bGUpLFxuICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZW1zID0gdGhpc1snY3JlYXRlSXRlbXMnXSgpO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIC8vIEFkZCBtZW51IGl0ZW1zIHRvIHRoZSBtZW51XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVudS5hZGRJdGVtKHRoaXMuaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW51O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKi9cbiAgY3JlYXRlSXRlbXMoKXt9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY2xhc3NOYW1lfSB2anMtbWVudS1idXR0b24gJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIC8vIEZvY3VzIC0gQWRkIGtleWJvYXJkIGZ1bmN0aW9uYWxpdHkgdG8gZWxlbWVudFxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBuZWVkZWQgYW55bW9yZS4gSW5zdGVhZCwgdGhlIGtleWJvYXJkIGZ1bmN0aW9uYWxpdHkgaXMgaGFuZGxlZCBieVxuICAvLyB0cmVhdGluZyB0aGUgYnV0dG9uIGFzIHRyaWdnZXJpbmcgYSBzdWJtZW51LiBXaGVuIHRoZSBidXR0b24gaXMgcHJlc3NlZCwgdGhlIHN1Ym1lbnVcbiAgLy8gYXBwZWFycy4gUHJlc3NpbmcgdGhlIGJ1dHRvbiBhZ2FpbiBtYWtlcyB0aGUgc3VibWVudSBkaXNhcHBlYXIuXG4gIG9uRm9jdXMoKSB7fVxuXG4gIC8vIENhbid0IHR1cm4gb2ZmIGxpc3QgZGlzcGxheSB0aGF0IHdlIHR1cm5lZCBvbiB3aXRoIGZvY3VzLCBiZWNhdXNlIGxpc3Qgd291bGQgZ28gYXdheS5cbiAgb25CbHVyKCkge31cblxuICBvbkNsaWNrKCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51IGluZGVmaW5pdGVseS5cbiAgICAvLyBTbyB3ZSdsbCByZW1vdmUgZm9jdXMgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBidXR0b24uXG4gICAgLy8gRm9jdXMgaXMgbmVlZGVkIGZvciB0YWIgbmF2aWdhdGlvbi5cbiAgICB0aGlzLm9uZSgnbW91c2VvdXQnLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMuZWxfLmJsdXIoKTtcbiAgICB9KSk7XG4gICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pe1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH1cblxuICBvbktleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmFyICgzMikgb3IgZW50ZXIgKDEzKSBrZXlzXG4gICAgaWYgKGV2ZW50LndoaWNoID09IDMyIHx8IGV2ZW50LndoaWNoID09IDEzKSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXyl7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyBDaGVjayBmb3IgZXNjYXBlICgyNykga2V5XG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PSAyNyl7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXyl7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcmVzc0J1dHRvbigpIHtcbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gdHJ1ZTtcbiAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRydWUpO1xuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pdGVtc1swXS5lbCgpLmZvY3VzKCk7IC8vIHNldCB0aGUgZm9jdXMgdG8gdGhlIHRpdGxlIG9mIHRoZSBzdWJtZW51XG4gICAgfVxuICB9XG5cbiAgdW5wcmVzc0J1dHRvbigpIHtcbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIGZhbHNlKTtcbiAgfVxufVxuXG5CdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVCdXR0b24nLCBNZW51QnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IE1lbnVCdXR0b247XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTWVudUl0ZW0gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5zZWxlY3RlZChvcHRpb25zWydzZWxlY3RlZCddKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnbGknLCBMaWIub2JqLm1lcmdlKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWl0ZW0nLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc19bJ2xhYmVsJ10pXG4gICAgfSwgcHJvcHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVudSBpdGVtLCBhbmQgc2V0IGl0IHRvIHNlbGVjdGVkXG4gICAqL1xuICBvbkNsaWNrKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoaXMgbWVudSBpdGVtIGFzIHNlbGVjdGVkIG9yIG5vdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzZWxlY3RlZFxuICAgKi9cbiAgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyx0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLGZhbHNlKTtcbiAgICB9XG4gIH1cblxufVxuXG5CdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgTWVudUl0ZW07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKiBNZW51XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3AgdXAgbWVudXMsIGluY2x1ZGluZyBzdWJ0aXRsZSBhbmRcbiAqIGNhcHRpb25zIHNlbGVjdGlvbiBtZW51cy5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogQWRkIGEgbWVudSBpdGVtIHRvIHRoZSBtZW51XG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29tcG9uZW50IENvbXBvbmVudCBvciBjb21wb25lbnQgdHlwZSB0byBhZGRcbiAgICovXG4gIGFkZEl0ZW0oY29tcG9uZW50KSB7XG4gICAgdGhpcy5hZGRDaGlsZChjb21wb25lbnQpO1xuICAgIGNvbXBvbmVudC5vbignY2xpY2snLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgdGhpcy51bmxvY2tTaG93aW5nKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGNvbnRlbnRFbFR5cGUgPSB0aGlzLm9wdGlvbnMoKS5jb250ZW50RWxUeXBlIHx8ICd1bCc7XG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKGNvbnRlbnRFbFR5cGUsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWNvbnRlbnQnXG4gICAgfSk7XG4gICAgdmFyIGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGFwcGVuZDogdGhpcy5jb250ZW50RWxfLFxuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUnXG4gICAgfSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgTWVudSBCdXR0b25zLFxuICAgIC8vIHdoZXJlIGEgY2xpY2sgb24gdGhlIHBhcmVudCBpcyBzaWduaWZpY2FudFxuICAgIEV2ZW50cy5vbihlbCwgJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xuZXhwb3J0IGRlZmF1bHQgTWVudTtcbiIsImltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmxldCBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuXG4vKipcbiAqIEdsb2JhbCBQbGF5ZXIgaW5zdGFuY2Ugb3B0aW9ucywgc3VyZmFjZWQgZnJvbSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogQWxsIG9wdGlvbnMgc2hvdWxkIHVzZSBzdHJpbmcga2V5cyBzbyB0aGV5IGF2b2lkXG4gKiByZW5hbWluZyBieSBjbG9zdXJlIGNvbXBpbGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIERlZmF1bHQgb3JkZXIgb2YgZmFsbGJhY2sgdGVjaG5vbG9neVxuICAndGVjaE9yZGVyJzogWydodG1sNScsJ2ZsYXNoJ10sXG4gIC8vIHRlY2hPcmRlcjogWydmbGFzaCcsJ2h0bWw1J10sXG5cbiAgJ2h0bWw1Jzoge30sXG4gICdmbGFzaCc6IHt9LFxuXG4gIC8vIERlZmF1bHQgb2Ygd2ViIGJyb3dzZXIgaXMgMzAweDE1MC4gU2hvdWxkIHJlbHkgb24gc291cmNlIHdpZHRoL2hlaWdodC5cbiAgJ3dpZHRoJzogMzAwLFxuICAnaGVpZ2h0JzogMTUwLFxuICAvLyBkZWZhdWx0Vm9sdW1lOiAwLjg1LFxuICAnZGVmYXVsdFZvbHVtZSc6IDAuMDAsIC8vIFRoZSBmcmVha2luIHNlYWd1bHMgYXJlIGRyaXZpbmcgbWUgY3JhenkhXG5cbiAgLy8gZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXRcbiAgJ2luYWN0aXZpdHlUaW1lb3V0JzogMjAwMCxcblxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXG4gICdwbGF5YmFja1JhdGVzJzogW10sXG4gIC8vIEFkZCBwbGF5YmFjayByYXRlIHNlbGVjdGlvbiBieSBhZGRpbmcgcmF0ZXNcbiAgLy8gJ3BsYXliYWNrUmF0ZXMnOiBbMC41LCAxLCAxLjUsIDJdLFxuXG4gIC8vIEluY2x1ZGVkIGNvbnRyb2wgc2V0c1xuICAnY2hpbGRyZW4nOiB7XG4gICAgJ21lZGlhTG9hZGVyJzoge30sXG4gICAgJ3Bvc3RlckltYWdlJzoge30sXG4gICAgJ3RleHRUcmFja0Rpc3BsYXknOiB7fSxcbiAgICAnbG9hZGluZ1NwaW5uZXInOiB7fSxcbiAgICAnYmlnUGxheUJ1dHRvbic6IHt9LFxuICAgICdjb250cm9sQmFyJzoge30sXG4gICAgJ2Vycm9yRGlzcGxheSc6IHt9LFxuICAgICd0ZXh0VHJhY2tTZXR0aW5ncyc6IHt9XG4gIH0sXG5cbiAgJ2xhbmd1YWdlJzogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXS5nZXRBdHRyaWJ1dGUoJ2xhbmcnKSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgJ2VuJyxcblxuICAvLyBsb2NhbGVzIGFuZCB0aGVpciBsYW5ndWFnZSB0cmFuc2xhdGlvbnNcbiAgJ2xhbmd1YWdlcyc6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICAnbm90U3VwcG9ydGVkTWVzc2FnZSc6ICdObyBjb21wYXRpYmxlIHNvdXJjZSB3YXMgZm91bmQgZm9yIHRoaXMgdmlkZW8uJ1xufTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliLmpzJztcbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRnVsbHNjcmVlbkFwaSBmcm9tICcuL2Z1bGxzY3JlZW4tYXBpLmpzJztcbmltcG9ydCBNZWRpYUVycm9yIGZyb20gJy4vbWVkaWEtZXJyb3IuanMnO1xuaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9vcHRpb25zLmpzJztcbmltcG9ydCBzYWZlUGFyc2VUdXBsZSBmcm9tICdzYWZlLWpzb24tcGFyc2UvdHVwbGUnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vLyBJbmNsdWRlIHJlcXVpcmVkIGNoaWxkIGNvbXBvbmVudHNcbmltcG9ydCBNZWRpYUxvYWRlciBmcm9tICcuL3RlY2gvbG9hZGVyLmpzJztcbmltcG9ydCBQb3N0ZXIgZnJvbSAnLi9wb3N0ZXItaW1hZ2UuanMnO1xuaW1wb3J0IFRleHRUcmFja0Rpc3BsYXkgZnJvbSAnLi90cmFja3MvdGV4dC10cmFjay1kaXNwbGF5LmpzJztcbmltcG9ydCBMb2FkaW5nU3Bpbm5lciBmcm9tICcuL2xvYWRpbmctc3Bpbm5lci5qcyc7XG5pbXBvcnQgQmlnUGxheUJ1dHRvbiBmcm9tICcuL2JpZy1wbGF5LWJ1dHRvbi5qcyc7XG5pbXBvcnQgY29udHJvbEJhciBmcm9tICcuL2NvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzJztcbmltcG9ydCBFcnJvckRpc3BsYXkgZnJvbSAnLi9lcnJvci1kaXNwbGF5LmpzJztcbmltcG9ydCBUZXh0VHJhY2tTZXR0aW5ncyBmcm9tICcuL3RyYWNrcy90ZXh0LXRyYWNrLXNldHRpbmdzLmpzJztcbi8vIFJlcXVpcmUgaHRtbDUgZm9yIGRpc3Bvc2luZyB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnXG5pbXBvcnQgSHRtbDUgZnJvbSAnLi90ZWNoL2h0bWw1LmpzJztcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgYFBsYXllcmAgY2xhc3MgaXMgY3JlYXRlZCB3aGVuIGFueSBvZiB0aGUgVmlkZW8uanMgc2V0dXAgbWV0aG9kcyBhcmUgdXNlZCB0byBpbml0aWFsaXplIGEgdmlkZW8uXG4gKlxuICogYGBganNcbiAqIHZhciBteVBsYXllciA9IHZpZGVvanMoJ2V4YW1wbGVfdmlkZW9fMScpO1xuICogYGBgXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGUgYGRhdGEtc2V0dXBgIGF0dHJpYnV0ZSB0ZWxscyB0aGUgVmlkZW8uanMgbGlicmFyeSB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2Ugd2hlbiB0aGUgbGlicmFyeSBpcyByZWFkeS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8dmlkZW8gaWQ9XCJleGFtcGxlX3ZpZGVvXzFcIiBkYXRhLXNldHVwPSd7fScgY29udHJvbHM+XG4gKiAgIDxzb3VyY2Ugc3JjPVwibXktc291cmNlLm1wNFwiIHR5cGU9XCJ2aWRlby9tcDRcIj5cbiAqIDwvdmlkZW8+XG4gKiBgYGBcbiAqXG4gKiBBZnRlciBhbiBpbnN0YW5jZSBoYXMgYmVlbiBjcmVhdGVkIGl0IGNhbiBiZSBhY2Nlc3NlZCBnbG9iYWxseSB1c2luZyBgVmlkZW8oJ2V4YW1wbGVfdmlkZW9fMScpYC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5jbGFzcyBQbGF5ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBwbGF5ZXIncyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAbWV0aG9kIGluaXRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWcgICAgICAgIFRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgICAgUGxheWVyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5ICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWcsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICAvLyBNYWtlIHN1cmUgdGFnIElEIGV4aXN0c1xuICAgIHRhZy5pZCA9IHRhZy5pZCB8fCBgdmpzX3ZpZGVvXyR7TGliLmd1aWQrK31gO1xuXG4gICAgLy8gU2V0IE9wdGlvbnNcbiAgICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBvdmVycmlkZXMgb3B0aW9ucyBzZXQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgIC8vIHdoaWNoIG92ZXJyaWRlcyBnbG9iYWxseSBzZXQgb3B0aW9ucy5cbiAgICAvLyBUaGlzIGxhdHRlciBwYXJ0IGNvaW5jaWRlcyB3aXRoIHRoZSBsb2FkIG9yZGVyXG4gICAgLy8gKHRhZyBtdXN0IGV4aXN0IGJlZm9yZSBQbGF5ZXIpXG4gICAgb3B0aW9ucyA9IExpYi5vYmoubWVyZ2UoUGxheWVyLmdldFRhZ1NldHRpbmdzKHRhZyksIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVsYXkgdGhlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkcmVuIGJlY2F1c2Ugd2UgbmVlZCB0byBzZXQgdXBcbiAgICAvLyBwbGF5ZXIgcHJvcGVydGllcyBmaXJzdCwgYW5kIGNhbid0IHVzZSBgdGhpc2AgYmVmb3JlIGBzdXBlcigpYFxuICAgIG9wdGlvbnMuaW5pdENoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAvLyBTYW1lIHdpdGggY3JlYXRpbmcgdGhlIGVsZW1lbnRcbiAgICBvcHRpb25zLmNyZWF0ZUVsID0gZmFsc2U7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwbGF5ZXIgdG8gcmVwb3J0IHRvdWNoIGFjdGl2aXR5IG9uIGl0c2VsZlxuICAgIC8vIHNlZSBlbmFibGVUb3VjaEFjdGl2aXR5IGluIENvbXBvbmVudFxuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8gUnVuIGJhc2UgY29tcG9uZW50IGluaXRpYWxpemluZyB3aXRoIG5ldyBvcHRpb25zXG4gICAgc3VwZXIobnVsbCwgb3B0aW9ucywgcmVhZHkpO1xuXG4gICAgdGhpcy50YWcgPSB0YWc7IC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB0YWcgdXNlZCB0byBzZXQgb3B0aW9uc1xuXG4gICAgLy8gU3RvcmUgdGhlIHRhZyBhdHRyaWJ1dGVzIHVzZWQgdG8gcmVzdG9yZSBodG1sNSBlbGVtZW50XG4gICAgdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIExpYi5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgLy8gVXBkYXRlIEN1cnJlbnQgTGFuZ3VhZ2VcbiAgICB0aGlzLmxhbmd1YWdlXyA9IG9wdGlvbnNbJ2xhbmd1YWdlJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2UnXTtcblxuICAgIC8vIFVwZGF0ZSBTdXBwb3J0ZWQgTGFuZ3VhZ2VzXG4gICAgdGhpcy5sYW5ndWFnZXNfID0gb3B0aW9uc1snbGFuZ3VhZ2VzJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2VzJ107XG5cbiAgICAvLyBDYWNoZSBmb3IgdmlkZW8gcHJvcGVydHkgdmFsdWVzLlxuICAgIHRoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgdGhpcy5wb3N0ZXJfID0gb3B0aW9uc1sncG9zdGVyJ10gfHwgJyc7XG5cbiAgICAvLyBTZXQgY29udHJvbHNcbiAgICB0aGlzLmNvbnRyb2xzXyA9ICEhb3B0aW9uc1snY29udHJvbHMnXTtcbiAgICAvLyBPcmlnaW5hbCB0YWcgc2V0dGluZ3Mgc3RvcmVkIGluIG9wdGlvbnNcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cbiAgICAvLyBNYXkgYmUgdHVybmVkIGJhY2sgb24gYnkgSFRNTDUgdGVjaCBpZiBuYXRpdmVDb250cm9sc0ZvclRvdWNoIGlzIHRydWVcbiAgICB0YWcuY29udHJvbHMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICogQHByaXZhdGVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHVzZXIgaXMgc2NydWJiaW5nXG4gICAgKi9cbiAgICB0aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG5cbiAgICAvLyBTZXQgaXNBdWRpbyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbiBhdWRpbyB0YWcgd2FzIHVzZWRcbiAgICB0aGlzLmlzQXVkaW8odGFnLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpbycpO1xuXG4gICAgLy8gVXBkYXRlIGNvbnRyb2xzIGNsYXNzTmFtZS4gQ2FuJ3QgZG8gdGhpcyB3aGVuIHRoZSBjb250cm9scyBhcmUgaW5pdGlhbGx5XG4gICAgLy8gc2V0IGJlY2F1c2UgdGhlIGVsZW1lbnQgZG9lc24ndCBleGlzdCB5ZXQuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNBdWRpbygpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtYXVkaW8nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mbGV4Tm90U3VwcG9ydGVkXygpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtbm8tZmxleCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyLiBUb2dnbGUgdXNlciBzdGF0ZSBiZXR3ZWVuIHRvdWNoaW5nL21vdXNpbmdcbiAgICAvLyB1c2luZyBldmVudHMsIHNpbmNlIGRldmljZXMgY2FuIGhhdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLlxuICAgIC8vIGlmIChMaWIuVE9VQ0hfRU5BQkxFRCkge1xuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBNYWtlIHBsYXllciBlYXNpbHkgZmluZGFibGUgYnkgSURcbiAgICBQbGF5ZXIucGxheWVyc1t0aGlzLmlkX10gPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnNbJ3BsdWdpbnMnXSkge1xuICAgICAgTGliLm9iai5lYWNoKG9wdGlvbnNbJ3BsdWdpbnMnXSwgZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgICAgICB0aGlzW2tleV0odmFsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gdGhlIHBsYXllciBpcyBmaXJzdCBpbml0aWFsaXplZCwgdHJpZ2dlciBhY3Rpdml0eSBzbyBjb21wb25lbnRzXG4gICAgLy8gbGlrZSB0aGUgY29udHJvbCBiYXIgc2hvdyB0aGVtc2VsdmVzIGlmIG5lZWRlZFxuICAgIHRoaXMudXNlckFjdGl2ZV8gPSB0cnVlO1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgdGhpcy5saXN0ZW5Gb3JVc2VyQWN0aXZpdHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cFxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuZGlzcG9zZSgpO1xuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXG4gICAqIHRvL2Zyb20gdGhlIERPTS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkaXNwb3NlJyk7XG4gICAgLy8gcHJldmVudCBkaXNwb3NlIGZyb20gYmVpbmcgY2FsbGVkIHR3aWNlXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnKTtcblxuICAgIC8vIEtpbGwgcmVmZXJlbmNlIHRvIHRoaXMgcGxheWVyXG4gICAgUGxheWVyLnBsYXllcnNbdGhpcy5pZF9dID0gbnVsbDtcbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWdbJ3BsYXllciddKSB7IHRoaXMudGFnWydwbGF5ZXInXSA9IG51bGw7IH1cbiAgICBpZiAodGhpcy5lbF8gJiYgdGhpcy5lbF9bJ3BsYXllciddKSB7IHRoaXMuZWxfWydwbGF5ZXInXSA9IG51bGw7IH1cblxuICAgIGlmICh0aGlzLnRlY2gpIHsgdGhpcy50ZWNoLmRpc3Bvc2UoKTsgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gdGhpcy5lbF8gPSBzdXBlci5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgbGV0IHRhZyA9IHRoaXMudGFnO1xuXG4gICAgLy8gUmVtb3ZlIHdpZHRoL2hlaWdodCBhdHRycyBmcm9tIHRhZyBzbyBDU1MgY2FuIG1ha2UgaXQgMTAwJSB3aWR0aC9oZWlnaHRcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXG4gICAgLy8gQ29weSBvdmVyIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSB0YWcsIGluY2x1ZGluZyBJRCBhbmQgY2xhc3NcbiAgICAvLyBJRCB3aWxsIG5vdyByZWZlcmVuY2UgcGxheWVyIGJveCwgbm90IHRoZSB2aWRlbyB0YWdcbiAgICBjb25zdCBhdHRycyA9IExpYi5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuICAgIExpYi5vYmouZWFjaChhdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgLy8gd29ya2Fyb3VuZCBzbyB3ZSBkb24ndCB0b3RhbGx5IGJyZWFrIElFN1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjUzNDQ0L2Nzcy1zdHlsZXMtbm90LWFwcGxpZWQtb24tZHluYW1pYy1lbGVtZW50cy1pbi1pbnRlcm5ldC1leHBsb3Jlci03XG4gICAgICBpZiAoYXR0ciA9PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5pZCArPSAnX2h0bWw1X2FwaSc7XG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XG5cbiAgICAvLyBNYWtlIHBsYXllciBmaW5kYWJsZSBvbiBlbGVtZW50c1xuICAgIHRhZ1sncGxheWVyJ10gPSBlbFsncGxheWVyJ10gPSB0aGlzO1xuICAgIC8vIERlZmF1bHQgc3RhdGUgb2YgdmlkZW8gaXMgcGF1c2VkXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuXG4gICAgLy8gTWFrZSBib3ggdXNlIHdpZHRoL2hlaWdodCBvZiB0YWcsIG9yIHJlbHkgb24gZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIC8vIEVuZm9yY2Ugd2l0aCBDU1Mgc2luY2Ugd2lkdGgvaGVpZ2h0IGF0dHJzIGRvbid0IHdvcmsgb24gZGl2c1xuICAgIHRoaXMud2lkdGgodGhpcy5vcHRpb25zX1snd2lkdGgnXSwgdHJ1ZSk7IC8vICh0cnVlKSBTa2lwIHJlc2l6ZSBsaXN0ZW5lciBvbiBsb2FkXG4gICAgdGhpcy5oZWlnaHQodGhpcy5vcHRpb25zX1snaGVpZ2h0J10sIHRydWUpO1xuXG4gICAgLy8gTGliLmluc2VydEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlKSB7XG4gICAgICB0YWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhZyk7XG4gICAgfVxuICAgIExpYi5pbnNlcnRGaXJzdCh0YWcsIGVsKTsgLy8gQnJlYWtzIGlQaG9uZSwgZml4ZWQgaW4gSFRNTDUgc2V0dXAuXG5cbiAgICAvLyBUaGUgZXZlbnQgbGlzdGVuZXJzIG5lZWQgdG8gYmUgYWRkZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgYWRkZWRcbiAgICAvLyBpbiB0aGUgY29tcG9uZW50IGluaXQgYmVjYXVzZSB0aGUgdGVjaCAobG9hZGVkIHdpdGggbWVkaWFMb2FkZXIpIG1heVxuICAgIC8vIGZpcmUgZXZlbnRzLCBsaWtlIGxvYWRzdGFydCwgdGhhdCB0aGVzZSBldmVudHMgbmVlZCB0byBjYXB0dXJlLlxuICAgIC8vIExvbmcgdGVybSBpdCBtaWdodCBiZSBiZXR0ZXIgdG8gZXhwb3NlIGEgd2F5IHRvIGRvIHRoaXMgaW4gY29tcG9uZW50LmluaXRcbiAgICAvLyBsaWtlIGNvbXBvbmVudC5pbml0RXZlbnRMaXN0ZW5lcnMoKSB0aGF0IHJ1bnMgYmV0d2VlbiBlbCBjcmVhdGlvbiBhbmRcbiAgICAvLyBhZGRpbmcgY2hpbGRyZW5cbiAgICB0aGlzLmVsXyA9IGVsO1xuICAgIHRoaXMub24oJ2xvYWRzdGFydCcsIHRoaXMub25Mb2FkU3RhcnQpO1xuICAgIHRoaXMub24oJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5vbihbJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheWluZycsICdlbmRlZCddLCB0aGlzLm9uV2FpdEVuZCk7XG4gICAgdGhpcy5vbignc2Vla2luZycsIHRoaXMub25TZWVraW5nKTtcbiAgICB0aGlzLm9uKCdzZWVrZWQnLCB0aGlzLm9uU2Vla2VkKTtcbiAgICB0aGlzLm9uKCdlbmRlZCcsIHRoaXMub25FbmRlZCk7XG4gICAgdGhpcy5vbigncGxheScsIHRoaXMub25QbGF5KTtcbiAgICB0aGlzLm9uKCdmaXJzdHBsYXknLCB0aGlzLm9uRmlyc3RQbGF5KTtcbiAgICB0aGlzLm9uKCdwYXVzZScsIHRoaXMub25QYXVzZSk7XG4gICAgdGhpcy5vbigncHJvZ3Jlc3MnLCB0aGlzLm9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMub24oJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKTtcbiAgICB0aGlzLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5vbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIE1lZGlhIFBsYXliYWNrIFRlY2hub2xvZ3kgKHRlY2gpXG4gICAqIExvYWQvQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHBsYXliYWNrIHRlY2hub2xvZ3kgaW5jbHVkaW5nIGVsZW1lbnQgYW5kIEFQSSBtZXRob2RzXG4gICAqIEFuZCBhcHBlbmQgcGxheWJhY2sgZWxlbWVudCBpbiBwbGF5ZXIgZGl2LlxuICAgKi9cbiAgbG9hZFRlY2godGVjaE5hbWUsIHNvdXJjZSkge1xuXG4gICAgLy8gUGF1c2UgYW5kIHJlbW92ZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICBpZiAodGhpcy50ZWNoKSB7XG4gICAgICB0aGlzLnVubG9hZFRlY2goKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBIVE1MNSB2aWRlbyB0YWcgYXMgc29vbiBhcyB3ZSBhcmUgdXNpbmcgYW5vdGhlciB0ZWNoXG4gICAgaWYgKHRlY2hOYW1lICE9PSAnSHRtbDUnICYmIHRoaXMudGFnKSB7XG4gICAgICBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdIdG1sNScpLmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy50YWcpO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWUgPSB0ZWNoTmFtZTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdmFyIHRlY2hSZWFkeSA9IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnBsYXllcl8udHJpZ2dlclJlYWR5KCk7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGVjaC1zcGVjaWZpYyBvcHRpb25zIGZyb20gcGxheWVyIG9wdGlvbnMgYW5kIGFkZCBzb3VyY2UgYW5kIHBhcmVudCBlbGVtZW50IHRvIHVzZS5cbiAgICB2YXIgdGVjaE9wdGlvbnMgPSBMaWIub2JqLm1lcmdlKHsgJ3NvdXJjZSc6IHNvdXJjZSwgJ3BhcmVudEVsJzogdGhpcy5lbF8gfSwgdGhpcy5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUeXBlXyA9IHNvdXJjZS50eXBlO1xuICAgICAgaWYgKHNvdXJjZS5zcmMgPT0gdGhpcy5jYWNoZV8uc3JjICYmIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgICB0ZWNoT3B0aW9uc1snc3RhcnRUaW1lJ10gPSB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZV8uc3JjID0gc291cmNlLnNyYztcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRlY2ggaW5zdGFuY2VcbiAgICBsZXQgdGVjaENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgIHRoaXMudGVjaCA9IG5ldyB0ZWNoQ29tcG9uZW50KHRoaXMsIHRlY2hPcHRpb25zKTtcblxuICAgIHRoaXMudGVjaC5yZWFkeSh0ZWNoUmVhZHkpO1xuICB9XG5cbiAgdW5sb2FkVGVjaCgpIHtcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2guZGlzcG9zZSgpO1xuXG4gICAgdGhpcy50ZWNoID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxuICAgKiBAZXZlbnQgbG9hZHN0YXJ0XG4gICAqL1xuICBvbkxvYWRTdGFydCgpIHtcbiAgICAvLyBUT0RPOiBVcGRhdGUgdG8gdXNlIGBlbXB0aWVkYCBldmVudCBpbnN0ZWFkLiBTZWUgIzEyNzcuXG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcblxuICAgIC8vIHJlc2V0IHRoZSBlcnJvciBzdGF0ZVxuICAgIHRoaXMuZXJyb3IobnVsbCk7XG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgcGxheWluZyB3ZSB3YW50IHRvIHRyaWdnZXIgYSBmaXJzdHBsYXkgZXZlbnQgbm93LlxuICAgIC8vIFRoZSBmaXJzdHBsYXkgZXZlbnQgcmVsaWVzIG9uIGJvdGggdGhlIHBsYXkgYW5kIGxvYWRzdGFydCBldmVudHNcbiAgICAvLyB3aGljaCBjYW4gaGFwcGVuIGluIGFueSBvcmRlciBmb3IgYSBuZXcgc291cmNlXG4gICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgaGFzU3RhcnRlZCBzdGF0ZVxuICAgICAgdGhpcy5oYXNTdGFydGVkKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBoYXNTdGFydGVkKGhhc1N0YXJ0ZWQpIHtcbiAgICBpZiAoaGFzU3RhcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBpZiB0aGlzIGlzIGEgbmV3IHZhbHVlXG4gICAgICBpZiAodGhpcy5oYXNTdGFydGVkXyAhPT0gaGFzU3RhcnRlZCkge1xuICAgICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gaGFzU3RhcnRlZDtcbiAgICAgICAgaWYgKGhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdHBsYXkgZXZlbnQgaWYgdGhpcyBuZXdseSBoYXMgcGxheWVkXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaGFzU3RhcnRlZF87XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGJlZ2lucyBvciByZXN1bWVzIHBsYXliYWNrXG4gICAqIEBldmVudCBwbGF5XG4gICAqL1xuICBvblBsYXkoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGJlZ2lucyB3YWl0aW5nXG4gICAqIEBldmVudCB3YWl0aW5nXG4gICAqL1xuICBvbldhaXRpbmcoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhhbmRsZXIgZm9yIGV2ZW50cyB0aGF0IHNpZ25hbCB0aGF0IHdhaXRpbmcgaGFzIGVuZGVkXG4gICAqIHdoaWNoIGlzIG5vdCBjb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnMuIFNlZSAjMTM1MVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25XYWl0RW5kKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXllciBpcyBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICogQGV2ZW50IHNlZWtpbmdcbiAgICovXG4gIG9uU2Vla2luZygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2Vla2luZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZmluaXNoZWQganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAqIEBldmVudCBzZWVrZWRcbiAgICovXG4gIG9uU2Vla2VkKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWRcbiAgICpcbiAgICogTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgd2UncmUgbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdFxuICAgKiBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGEgcmVhc29uIHRvXG4gICAqIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXZlbnQgZmlyc3RwbGF5XG4gICAqL1xuICBvbkZpcnN0UGxheSgpIHtcbiAgICAvL0lmIHRoZSBmaXJzdCBzdGFydHRpbWUgYXR0cmlidXRlIGlzIHNwZWNpZmllZFxuICAgIC8vdGhlbiB3ZSB3aWxsIHN0YXJ0IGF0IHRoZSBnaXZlbiBvZmZzZXQgaW4gc2Vjb25kc1xuICAgIGlmKHRoaXMub3B0aW9uc19bJ3N0YXJ0dGltZSddKXtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUodGhpcy5vcHRpb25zX1snc3RhcnR0aW1lJ10pO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcbiAgICogQGV2ZW50IHBhdXNlXG4gICAqL1xuICBvblBhdXNlKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoaWxlIHRoZSB1c2VyIGFnZW50IGlzIGRvd25sb2FkaW5nIG1lZGlhIGRhdGFcbiAgICogQGV2ZW50IHByb2dyZXNzXG4gICAqL1xuICBvblByb2dyZXNzKCkge1xuICAgIC8vIEFkZCBjdXN0b20gZXZlbnQgZm9yIHdoZW4gc291cmNlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLlxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpID09IDEpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkYWxsZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgKiBAZXZlbnQgZW5kZWRcbiAgICovXG4gIG9uRW5kZWQoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc19bJ2xvb3AnXSkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIGZpcnN0IGtub3duIG9yIGNoYW5nZWRcbiAgICogQGV2ZW50IGR1cmF0aW9uY2hhbmdlXG4gICAqL1xuICBvbkR1cmF0aW9uQ2hhbmdlKCkge1xuICAgIC8vIEFsbG93cyBmb3IgY2FjaGluZyB2YWx1ZSBpbnN0ZWFkIG9mIGFza2luZyBwbGF5ZXIgZWFjaCB0aW1lLlxuICAgIC8vIFdlIG5lZWQgdG8gZ2V0IHRoZSB0ZWNoR2V0IHJlc3BvbnNlIGFuZCBjaGVjayBmb3IgYSB2YWx1ZSBzbyB3ZSBkb24ndFxuICAgIC8vIGFjY2lkZW50YWxseSBjYXVzZSB0aGUgc3RhY2sgdG8gYmxvdyB1cC5cbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnRlY2hHZXQoJ2R1cmF0aW9uJyk7XG4gICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24gPCAwKSB7XG4gICAgICAgIGR1cmF0aW9uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICB0aGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgc3RyZWFtIGlzIGxpdmUgYW5kIHByb3BhZ2F0ZSBzdHlsZXMgZG93biB0byBVSS5cbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1saXZlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBzd2l0Y2hlcyBpbiBvciBvdXQgb2YgZnVsbHNjcmVlbiBtb2RlXG4gICAqIEBldmVudCBmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuICBvbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBmb3IgY2FjaGVkIHZhbHVlcy5cbiAgICovXG4gIGdldENhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXztcbiAgfVxuXG4gIC8vIFBhc3MgdmFsdWVzIHRvIHRoZSBwbGF5YmFjayB0ZWNoXG4gIHRlY2hDYWxsKG1ldGhvZCwgYXJnKSB7XG4gICAgLy8gSWYgaXQncyBub3QgcmVhZHkgeWV0LCBjYWxsIG1ldGhvZCB3aGVuIGl0IGlzXG4gICAgaWYgKHRoaXMudGVjaCAmJiAhdGhpcy50ZWNoLmlzUmVhZHlfKSB7XG4gICAgICB0aGlzLnRlY2gucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpc1ttZXRob2RdKGFyZyk7XG4gICAgICB9KTtcblxuICAgIC8vIE90aGVyd2lzZSBjYWxsIG1ldGhvZCBub3dcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50ZWNoW21ldGhvZF0oYXJnKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBMaWIubG9nKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxuICB0ZWNoR2V0KG1ldGhvZCkge1xuICAgIGlmICh0aGlzLnRlY2ggJiYgdGhpcy50ZWNoLmlzUmVhZHlfKSB7XG5cbiAgICAgIC8vIEZsYXNoIGxpa2VzIHRvIGRpZSBhbmQgcmVsb2FkIHdoZW4geW91IGhpZGUgb3IgcmVwb3NpdGlvbiBpdC5cbiAgICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgICAgLy8gV2hlbiB0aGF0IGhhcHBlbnMgd2UnbGwgY2F0Y2ggdGhlIGVycm9ycyBhbmQgaW5mb3JtIHRlY2ggdGhhdCBpdCdzIG5vdCByZWFkeSBhbnkgbW9yZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlY2hbbWV0aG9kXSgpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLnRlY2hbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgTGliLmxvZyhgVmlkZW8uanM6ICR7bWV0aG9kfSBtZXRob2Qgbm90IGRlZmluZWQgZm9yICR7dGhpcy50ZWNoTmFtZX0gcGxheWJhY2sgdGVjaG5vbG9neS5gLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIGEgbWV0aG9kIGlzbid0IGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0IGl0IHRocm93cyBhIFR5cGVFcnJvclxuICAgICAgICAgIGlmIChlLm5hbWUgPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgIExpYi5sb2coYFZpZGVvLmpzOiAke21ldGhvZH0gdW5hdmFpbGFibGUgb24gJHt0aGlzLnRlY2hOYW1lfSBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuYCwgZSk7XG4gICAgICAgICAgICB0aGlzLnRlY2guaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTGliLmxvZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogc3RhcnQgbWVkaWEgcGxheWJhY2tcbiAgICpcbiAgICogICAgIG15UGxheWVyLnBsYXkoKTtcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqL1xuICBwbGF5KCkge1xuICAgIHRoaXMudGVjaENhbGwoJ3BsYXknKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgdmlkZW8gcGxheWJhY2tcbiAgICpcbiAgICogICAgIG15UGxheWVyLnBhdXNlKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbCgncGF1c2UnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZFxuICAgKlxuICAgKiAgICAgdmFyIGlzUGF1c2VkID0gbXlQbGF5ZXIucGF1c2VkKCk7XG4gICAqICAgICB2YXIgaXNQbGF5aW5nID0gIW15UGxheWVyLnBhdXNlZCgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcsIG9yIHRydWUgb3RoZXJ3aXNlXG4gICAqL1xuICBwYXVzZWQoKSB7XG4gICAgLy8gVGhlIGluaXRpYWwgc3RhdGUgb2YgcGF1c2VkIHNob3VsZCBiZSB0cnVlIChpbiBTYWZhcmkgaXQncyBhY3R1YWxseSBmYWxzZSlcbiAgICByZXR1cm4gKHRoaXMudGVjaEdldCgncGF1c2VkJykgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzIHdoZW4gdGhlIHVzZXJcbiAgKiBoYXMgY2xpY2tlZCB0aGUgcHJvZ3Jlc3MgYmFyIGhhbmRsZSBhbmQgaXMgZHJhZ2dpbmcgaXQgYWxvbmcgdGhlIHByb2dyZXNzIGJhci5cbiAgKiBAcGFyYW0gIHtCb29sZWFufSBpc1NjcnViYmluZyAgIFRydWUvZmFsc2UgdGhlIHVzZXIgaXMgc2NydWJiaW5nXG4gICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICBUaGUgc2NydWJiaW5nIHN0YXR1cyB3aGVuIGdldHRpbmdcbiAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICovXG4gIHNjcnViYmluZyhpc1NjcnViYmluZykge1xuICAgIGlmIChpc1NjcnViYmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xuXG4gICAgICBpZiAoaXNTY3J1YmJpbmcpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zY3J1YmJpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdGltZSAoaW4gc2Vjb25kcylcbiAgICpcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIHdoZXJlWW91QXQgPSBteVBsYXllci5jdXJyZW50VGltZSgpO1xuICAgKlxuICAgKiAgICAgLy8gc2V0XG4gICAqICAgICBteVBsYXllci5jdXJyZW50VGltZSgxMjApOyAvLyAyIG1pbnV0ZXMgaW50byB0aGUgdmlkZW9cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZz19IHNlY29uZHMgVGhlIHRpbWUgdG8gc2VlayB0b1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBUaGUgdGltZSBpbiBzZWNvbmRzLCB3aGVuIG5vdCBzZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gICAgc2VsZiwgd2hlbiB0aGUgY3VycmVudCB0aW1lIGlzIHNldFxuICAgKi9cbiAgY3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0Q3VycmVudFRpbWUnLCBzZWNvbmRzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgbGFzdCBjdXJyZW50VGltZSBhbmQgcmV0dXJuLiBkZWZhdWx0IHRvIDAgc2Vjb25kc1xuICAgIC8vXG4gICAgLy8gQ2FjaGluZyB0aGUgY3VycmVudFRpbWUgaXMgbWVhbnQgdG8gcHJldmVudCBhIG1hc3NpdmUgYW1vdW50IG9mIHJlYWRzIG9uIHRoZSB0ZWNoJ3NcbiAgICAvLyBjdXJyZW50VGltZSB3aGVuIHNjcnViYmluZywgYnV0IG1heSBub3QgcHJvdmlkZSBtdWNoIHBlcmZvcm1hbmNlIGJlbmVmaXQgYWZ0ZXJhbGwuXG4gICAgLy8gU2hvdWxkIGJlIHRlc3RlZC4gQWxzbyBzb21ldGhpbmcgaGFzIHRvIHJlYWQgdGhlIGFjdHVhbCBjdXJyZW50IHRpbWUgb3IgdGhlIGNhY2hlIHdpbGxcbiAgICAvLyBuZXZlciBnZXQgdXBkYXRlZC5cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPSAodGhpcy50ZWNoR2V0KCdjdXJyZW50VGltZScpIHx8IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVuZ3RoIGluIHRpbWUgb2YgdGhlIHZpZGVvIGluIHNlY29uZHNcbiAgICpcbiAgICogICAgIHZhciBsZW5ndGhPZlZpZGVvID0gbXlQbGF5ZXIuZHVyYXRpb24oKTtcbiAgICpcbiAgICogKipOT1RFKio6IFRoZSB2aWRlbyBtdXN0IGhhdmUgc3RhcnRlZCBsb2FkaW5nIGJlZm9yZSB0aGUgZHVyYXRpb24gY2FuIGJlXG4gICAqIGtub3duLCBhbmQgaW4gdGhlIGNhc2Ugb2YgRmxhc2gsIG1heSBub3QgYmUga25vd24gdW50aWwgdGhlIHZpZGVvIHN0YXJ0c1xuICAgKiBwbGF5aW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kc1xuICAgKi9cbiAgZHVyYXRpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gY2FjaGUgdGhlIGxhc3Qgc2V0IHZhbHVlIGZvciBvcHRpbWl6ZWQgc2NydWJiaW5nIChlc3AuIEZsYXNoKVxuICAgICAgdGhpcy5jYWNoZV8uZHVyYXRpb24gPSBwYXJzZUZsb2F0KHNlY29uZHMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYWNoZV8uZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBob3cgbXVjaCB0aW1lIGlzIGxlZnQuXG4gICAqXG4gICAqICAgICB2YXIgdGltZUxlZnQgPSBteVBsYXllci5yZW1haW5pbmdUaW1lKCk7XG4gICAqXG4gICAqIE5vdCBhIG5hdGl2ZSB2aWRlbyBlbGVtZW50IGZ1bmN0aW9uLCBidXQgdXNlZnVsXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICovXG4gIHJlbWFpbmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24oKSAtIHRoaXMuY3VycmVudFRpbWUoKTtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvdmlkZW8uaHRtbCNkb20tbWVkaWEtYnVmZmVyZWRcbiAgLy8gQnVmZmVyZWQgcmV0dXJucyBhIHRpbWVyYW5nZSBvYmplY3QuXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZFxuICAgKlxuICAgKiBJZiB5b3UganVzdCB3YW50IHRoZSBwZXJjZW50IG9mIHRoZSB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkLFxuICAgKiB1c2UgYnVmZmVyZWRQZXJjZW50LlxuICAgKlxuICAgKiAgICAgLy8gTnVtYmVyIG9mIGRpZmZlcmVudCByYW5nZXMgb2YgdGltZSBoYXZlIGJlZW4gYnVmZmVyZWQuIFVzdWFsbHkgMS5cbiAgICogICAgIG51bWJlck9mUmFuZ2VzID0gYnVmZmVyZWRUaW1lUmFuZ2UubGVuZ3RoLFxuICAgKlxuICAgKiAgICAgLy8gVGltZSBpbiBzZWNvbmRzIHdoZW4gdGhlIGZpcnN0IHJhbmdlIHN0YXJ0cy4gVXN1YWxseSAwLlxuICAgKiAgICAgZmlyc3RSYW5nZVN0YXJ0ID0gYnVmZmVyZWRUaW1lUmFuZ2Uuc3RhcnQoMCksXG4gICAqXG4gICAqICAgICAvLyBUaW1lIGluIHNlY29uZHMgd2hlbiB0aGUgZmlyc3QgcmFuZ2UgZW5kc1xuICAgKiAgICAgZmlyc3RSYW5nZUVuZCA9IGJ1ZmZlcmVkVGltZVJhbmdlLmVuZCgwKSxcbiAgICpcbiAgICogICAgIC8vIExlbmd0aCBpbiBzZWNvbmRzIG9mIHRoZSBmaXJzdCB0aW1lIHJhbmdlXG4gICAqICAgICBmaXJzdFJhbmdlTGVuZ3RoID0gZmlyc3RSYW5nZUVuZCAtIGZpcnN0UmFuZ2VTdGFydDtcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBBIG1vY2sgVGltZVJhbmdlIG9iamVjdCAoZm9sbG93aW5nIEhUTUwgc3BlYylcbiAgICovXG4gIGJ1ZmZlcmVkKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaEdldCgnYnVmZmVyZWQnKTtcblxuICAgIGlmICghYnVmZmVyZWQgfHwgIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgYnVmZmVyZWQgPSBMaWIuY3JlYXRlVGltZVJhbmdlKDAsMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudCAoYXMgYSBkZWNpbWFsKSBvZiB0aGUgdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZFxuICAgKlxuICAgKiAgICAgdmFyIGhvd011Y2hJc0Rvd25sb2FkZWQgPSBteVBsYXllci5idWZmZXJlZFBlcmNlbnQoKTtcbiAgICpcbiAgICogMCBtZWFucyBub25lLCAxIG1lYW5zIGFsbC5cbiAgICogKFRoaXMgbWV0aG9kIGlzbid0IGluIHRoZSBIVE1MNSBzcGVjLCBidXQgaXQncyB2ZXJ5IGNvbnZlbmllbnQpXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gQSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHBlcmNlbnRcbiAgICovXG4gIGJ1ZmZlcmVkUGVyY2VudCgpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCksXG4gICAgICAgIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpLFxuICAgICAgICBidWZmZXJlZER1cmF0aW9uID0gMCxcbiAgICAgICAgc3RhcnQsIGVuZDtcblxuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGk9MDsgaTxidWZmZXJlZC5sZW5ndGg7IGkrKyl7XG4gICAgICBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgZW5kICAgPSBidWZmZXJlZC5lbmQoaSk7XG5cbiAgICAgIC8vIGJ1ZmZlcmVkIGVuZCBjYW4gYmUgYmlnZ2VyIHRoYW4gZHVyYXRpb24gYnkgYSB2ZXJ5IHNtYWxsIGZyYWN0aW9uXG4gICAgICBpZiAoZW5kID4gZHVyYXRpb24pIHtcbiAgICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlcmVkRHVyYXRpb24gKz0gZW5kIC0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkRHVyYXRpb24gLyBkdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyB0aW1lIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBwcm9ncmVzcyBiYXIgdG8gZW5jYXBzdWxhdGUgYWxsIHRpbWUgcmFuZ2VzLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlbmQgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKi9cbiAgYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpLFxuICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSxcbiAgICAgICAgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aC0xKTtcblxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIGhvd0xvdWRJc0l0ID0gbXlQbGF5ZXIudm9sdW1lKCk7XG4gICAqXG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLnZvbHVtZSgwLjUpOyAvLyBTZXQgdm9sdW1lIHRvIGhhbGZcbiAgICpcbiAgICogMCBpcyBvZmYgKG11dGVkKSwgMS4wIGlzIGFsbCB0aGUgd2F5IHVwLCAwLjUgaXMgaGFsZiB3YXkuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gcGVyY2VudEFzRGVjaW1hbCBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgVGhlIGN1cnJlbnQgdm9sdW1lLCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgICAgICAgICAgc2VsZiwgd2hlbiBzZXR0aW5nXG4gICAqL1xuICB2b2x1bWUocGVyY2VudEFzRGVjaW1hbCkge1xuICAgIGxldCB2b2w7XG5cbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7IC8vIEZvcmNlIHZhbHVlIHRvIGJldHdlZW4gMCBhbmQgMVxuICAgICAgdGhpcy5jYWNoZV8udm9sdW1lID0gdm9sO1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0Vm9sdW1lJywgdm9sKTtcbiAgICAgIExpYi5zZXRMb2NhbFN0b3JhZ2UoJ3ZvbHVtZScsIHZvbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIDEgd2hlbiByZXR1cm5pbmcgY3VycmVudCB2b2x1bWUuXG4gICAgdm9sID0gcGFyc2VGbG9hdCh0aGlzLnRlY2hHZXQoJ3ZvbHVtZScpKTtcbiAgICByZXR1cm4gKGlzTmFOKHZvbCkpID8gMSA6IHZvbDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBtdXRlZCBzdGF0ZSwgb3IgdHVybiBtdXRlIG9uIG9yIG9mZlxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgaXNWb2x1bWVNdXRlZCA9IG15UGxheWVyLm11dGVkKCk7XG4gICAqXG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLm11dGVkKHRydWUpOyAvLyBtdXRlIHRoZSB2b2x1bWVcbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IG11dGVkIFRydWUgdG8gbXV0ZSwgZmFsc2UgdG8gdW5tdXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgbXV0ZSBpcyBvbiwgZmFsc2UgaWYgbm90LCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmLCB3aGVuIHNldHRpbmcgbXV0ZVxuICAgKi9cbiAgbXV0ZWQobXV0ZWQpIHtcbiAgICBpZiAobXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0TXV0ZWQnLCBtdXRlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnbXV0ZWQnKSB8fCBmYWxzZTsgLy8gRGVmYXVsdCB0byBmYWxzZVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gIC8vIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnc3VwcG9ydHNGdWxsU2NyZWVuJykgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIGZ1bGxzY3JlZW5Pck5vdCA9IG15UGxheWVyLmlzRnVsbHNjcmVlbigpO1xuICAgKlxuICAgKiAgICAgLy8gc2V0XG4gICAqICAgICBteVBsYXllci5pc0Z1bGxzY3JlZW4odHJ1ZSk7IC8vIHRlbGwgdGhlIHBsYXllciBpdCdzIGluIGZ1bGxzY3JlZW5cbiAgICpcbiAgICogTk9URTogQXMgb2YgdGhlIGxhdGVzdCBIVE1MNSBzcGVjLCBpc0Z1bGxzY3JlZW4gaXMgbm8gbG9uZ2VyIGFuIG9mZmljaWFsXG4gICAqIHByb3BlcnR5IGFuZCBpbnN0ZWFkIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IGlzIHVzZWQuIEJ1dCBpc0Z1bGxzY3JlZW4gaXNcbiAgICogc3RpbGwgYSB2YWx1YWJsZSBwcm9wZXJ0eSBmb3IgaW50ZXJuYWwgcGxheWVyIHdvcmtpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFuPX0gaXNGUyBVcGRhdGUgdGhlIHBsYXllcidzIGZ1bGxzY3JlZW4gc3RhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBmdWxsc2NyZWVuLCBmYWxzZSBpZiBub3RcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmLCB3aGVuIHNldHRpbmdcbiAgICovXG4gIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaXNGdWxsc2NyZWVuXztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbGQgbmFtaW5nIGZvciBpc0Z1bGxzY3JlZW4oKVxuICAgKiBAZGVwcmVjYXRlZCBmb3IgbG93ZXJjYXNlICdzJyB2ZXJzaW9uXG4gICAqL1xuICBpc0Z1bGxTY3JlZW4oaXNGUykge1xuICAgIExpYi5sb2cud2FybigncGxheWVyLmlzRnVsbFNjcmVlbigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBwbGF5ZXIuaXNGdWxsc2NyZWVuKCkgd2l0aCBhIGxvd2VyY2FzZSBcInNcIiknKTtcbiAgICByZXR1cm4gdGhpcy5pc0Z1bGxzY3JlZW4oaXNGUyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIHZpZGVvIHRvIGZ1bGwgc2NyZWVuXG4gICAqXG4gICAqICAgICBteVBsYXllci5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgKlxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGZcbiAgICovXG4gIHJlcXVlc3RGdWxsc2NyZWVuKCkge1xuICAgIHZhciBmc0FwaSA9IEZ1bGxzY3JlZW5BcGk7XG5cbiAgICB0aGlzLmlzRnVsbHNjcmVlbih0cnVlKTtcblxuICAgIGlmIChmc0FwaSkge1xuICAgICAgLy8gdGhlIGJyb3dzZXIgc3VwcG9ydHMgZ29pbmcgZnVsbHNjcmVlbiBhdCB0aGUgZWxlbWVudCBsZXZlbCBzbyB3ZSBjYW5cbiAgICAgIC8vIHRha2UgdGhlIGNvbnRyb2xzIGZ1bGxzY3JlZW4gYXMgd2VsbCBhcyB0aGUgdmlkZW9cblxuICAgICAgLy8gVHJpZ2dlciBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50IGFmdGVyIGNoYW5nZVxuICAgICAgLy8gV2UgaGF2ZSB0byBzcGVjaWZpY2FsbHkgYWRkIHRoaXMgZWFjaCB0aW1lLCBhbmQgcmVtb3ZlXG4gICAgICAvLyB3aGVuIGNhbmNlbGluZyBmdWxsc2NyZWVuLiBPdGhlcndpc2UgaWYgdGhlcmUncyBtdWx0aXBsZVxuICAgICAgLy8gcGxheWVycyBvbiBhIHBhZ2UsIHRoZXkgd291bGQgYWxsIGJlIHJlYWN0aW5nIHRvIHRoZSBzYW1lIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGV2ZW50c1xuICAgICAgRXZlbnRzLm9uKGRvY3VtZW50LCBmc0FwaVsnZnVsbHNjcmVlbmNoYW5nZSddLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSl7XG4gICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuKGRvY3VtZW50W2ZzQXBpLmZ1bGxzY3JlZW5FbGVtZW50XSk7XG5cbiAgICAgICAgLy8gSWYgY2FuY2VsbGluZyBmdWxsc2NyZWVuLCByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSBmYWxzZSkge1xuICAgICAgICAgIEV2ZW50cy5vZmYoZG9jdW1lbnQsIGZzQXBpWydmdWxsc2NyZWVuY2hhbmdlJ10sIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaC5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICAgLy8gd2UgY2FuJ3QgdGFrZSB0aGUgdmlkZW8uanMgY29udHJvbHMgZnVsbHNjcmVlbiBidXQgd2UgY2FuIGdvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIHdpdGggbmF0aXZlIGNvbnRyb2xzXG4gICAgICB0aGlzLnRlY2hDYWxsKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9sZCBuYW1pbmcgZm9yIHJlcXVlc3RGdWxsc2NyZWVuXG4gICAqIEBkZXByZWNhdGVkIGZvciBsb3dlciBjYXNlICdzJyB2ZXJzaW9uXG4gICAqL1xuICByZXF1ZXN0RnVsbFNjcmVlbigpIHtcbiAgICBMaWIubG9nLndhcm4oJ3BsYXllci5yZXF1ZXN0RnVsbFNjcmVlbigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBwbGF5ZXIucmVxdWVzdEZ1bGxzY3JlZW4oKSB3aXRoIGEgbG93ZXJjYXNlIFwic1wiKScpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqL1xuICBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaC5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICB0aGlzLnRlY2hDYWxsKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgIHRoaXMuZXhpdEZ1bGxXaW5kb3coKTtcbiAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogT2xkIG5hbWluZyBmb3IgZXhpdEZ1bGxzY3JlZW5cbiAgICogQGRlcHJlY2F0ZWQgZm9yIGV4aXRGdWxsc2NyZWVuXG4gICAqL1xuICBjYW5jZWxGdWxsU2NyZWVuKCkge1xuICAgIExpYi5sb2cud2FybigncGxheWVyLmNhbmNlbEZ1bGxTY3JlZW4oKSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcGxheWVyLmV4aXRGdWxsc2NyZWVuKCknKTtcbiAgICByZXR1cm4gdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICB9XG5cbiAgLy8gV2hlbiBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCB3ZSBjYW4gc3RyZXRjaCB0aGUgdmlkZW8gY29udGFpbmVyIHRvIGFzIHdpZGUgYXMgdGhlIGJyb3dzZXIgd2lsbCBsZXQgdXMuXG4gIGVudGVyRnVsbFdpbmRvdygpIHtcbiAgICB0aGlzLmlzRnVsbFdpbmRvdyA9IHRydWU7XG5cbiAgICAvLyBTdG9yaW5nIG9yaWdpbmFsIGRvYyBvdmVyZmxvdyB2YWx1ZSB0byByZXR1cm4gdG8gd2hlbiBmdWxsc2NyZWVuIGlzIG9mZlxuICAgIHRoaXMuZG9jT3JpZ092ZXJmbG93ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuXG4gICAgLy8gQWRkIGxpc3RlbmVyIGZvciBlc2Mga2V5IHRvIGV4aXQgZnVsbHNjcmVlblxuICAgIEV2ZW50cy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCBMaWIuYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgTGliLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIHRoaXMudHJpZ2dlcignZW50ZXJGdWxsV2luZG93Jyk7XG4gIH1cblxuICBmdWxsV2luZG93T25Fc2NLZXkoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhpdEZ1bGxXaW5kb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleGl0RnVsbFdpbmRvdygpIHtcbiAgICB0aGlzLmlzRnVsbFdpbmRvdyA9IGZhbHNlO1xuICAgIEV2ZW50cy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpO1xuXG4gICAgLy8gVW5oaWRlIHNjcm9sbCBiYXJzLlxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IHRoaXMuZG9jT3JpZ092ZXJmbG93O1xuXG4gICAgLy8gUmVtb3ZlIGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgTGliLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIHRoaXMudHJpZ2dlcignZXhpdEZ1bGxXaW5kb3cnKTtcbiAgfVxuXG4gIHNlbGVjdFNvdXJjZShzb3VyY2VzKSB7XG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcGxheWJhY2sgdGVjaG5vbG9neSBpbiB0aGUgb3B0aW9ucyBvcmRlclxuICAgIGZvciAodmFyIGk9MCxqPXRoaXMub3B0aW9uc19bJ3RlY2hPcmRlciddO2k8ai5sZW5ndGg7aSsrKSB7XG4gICAgICBsZXQgdGVjaE5hbWUgPSBMaWIuY2FwaXRhbGl6ZShqW2ldKTtcbiAgICAgIGxldCB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgaWYgKCF0ZWNoKSB7XG4gICAgICAgIExpYi5sb2cuZXJyb3IoYFRoZSBcIiR7dGVjaE5hbWV9XCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggc291cmNlIG9iamVjdFxuICAgICAgICBmb3IgKHZhciBhPTAsYj1zb3VyY2VzO2E8Yi5sZW5ndGg7YSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGJbYV07XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBzb3VyY2UgY2FuIGJlIHBsYXllZCB3aXRoIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICAgIGlmICh0ZWNoWydjYW5QbGF5U291cmNlJ10oc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZnVuY3Rpb24gdXBkYXRlcyB0aGUgdmlkZW8gc291cmNlXG4gICAqXG4gICAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiB2YXJpYWJsZXMgeW91IGNhbiBwYXNzIGFzIHRoZSBhcmd1bWVudC5cbiAgICpcbiAgICogKipVUkwgU3RyaW5nKio6IEEgVVJMIHRvIHRoZSB0aGUgdmlkZW8gZmlsZS4gVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBhcmUgc3VyZVxuICAgKiB0aGUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5IChIVE1MNS9GbGFzaCkgY2FuIHN1cHBvcnQgdGhlIHNvdXJjZSB5b3VcbiAgICogcHJvdmlkZS4gQ3VycmVudGx5IG9ubHkgTVA0IGZpbGVzIGNhbiBiZSB1c2VkIGluIGJvdGggSFRNTDUgYW5kIEZsYXNoLlxuICAgKlxuICAgKiAgICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogKipTb3VyY2UgT2JqZWN0IChvciBlbGVtZW50KToqKiBBIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cbiAgICogYWJvdXQgdGhlIHNvdXJjZSBmaWxlLiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdGhlIHBsYXllciB0byBkZXRlcm1pbmUgaWZcbiAgICogaXQgY2FuIHN1cHBvcnQgdGhlIGZpbGUgdXNpbmcgdGhlIHR5cGUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICAgICBteVBsYXllci5zcmMoeyB0eXBlOiBcInZpZGVvL21wNFwiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiIH0pO1xuICAgKlxuICAgKiAqKkFycmF5IG9mIFNvdXJjZSBPYmplY3RzOioqIFRvIHByb3ZpZGUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIHNvdXJjZSBzb1xuICAgKiB0aGF0IGl0IGNhbiBiZSBwbGF5ZWQgdXNpbmcgSFRNTDUgYWNyb3NzIGJyb3dzZXJzIHlvdSBjYW4gdXNlIGFuIGFycmF5IG9mXG4gICAqIHNvdXJjZSBvYmplY3RzLiBWaWRlby5qcyB3aWxsIGRldGVjdCB3aGljaCB2ZXJzaW9uIGlzIHN1cHBvcnRlZCBhbmQgbG9hZCB0aGF0XG4gICAqIGZpbGUuXG4gICAqXG4gICAqICAgICBteVBsYXllci5zcmMoW1xuICAgKiAgICAgICB7IHR5cGU6IFwidmlkZW8vbXA0XCIsIHNyYzogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL3dlYm1cIiwgc3JjOiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vcGF0aC90by92aWRlby53ZWJtXCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL29nZ1wiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm9ndlwiIH1cbiAgICogICAgIF0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fEFycmF5PX0gc291cmNlIFRoZSBzb3VyY2UgVVJMLCBvYmplY3QsIG9yIGFycmF5IG9mIHNvdXJjZXNcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY3VycmVudCB2aWRlbyBzb3VyY2Ugd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG4gIHNyYyhzb3VyY2U9dGhpcy50ZWNoR2V0KCdzcmMnKSkge1xuICAgIGxldCBjdXJyZW50VGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGhpcy50ZWNoTmFtZSk7XG5cbiAgICAvLyBjYXNlOiBBcnJheSBvZiBzb3VyY2Ugb2JqZWN0cyB0byBjaG9vc2UgZnJvbSBhbmQgcGljayB0aGUgYmVzdCB0byBwbGF5XG4gICAgaWYgKExpYi5vYmouaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnNvdXJjZUxpc3RfKHNvdXJjZSk7XG5cbiAgICAvLyBjYXNlOiBVUkwgU3RyaW5nIChodHRwOi8vbXl2aWRlby4uLilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBjcmVhdGUgYSBzb3VyY2Ugb2JqZWN0IGZyb20gdGhlIHN0cmluZ1xuICAgICAgdGhpcy5zcmMoeyBzcmM6IHNvdXJjZSB9KTtcblxuICAgIC8vIGNhc2U6IFNvdXJjZSBvYmplY3QgeyBzcmM6ICcnLCB0eXBlOiAnJyAuLi4gfVxuICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgc291cmNlIGhhcyBhIHR5cGUgYW5kIHRoZSBsb2FkZWQgdGVjaCBjYW5ub3QgcGxheSB0aGUgc291cmNlXG4gICAgICAvLyBpZiB0aGVyZSdzIG5vIHR5cGUgd2UnbGwganVzdCB0cnkgdGhlIGN1cnJlbnQgdGVjaFxuICAgICAgaWYgKHNvdXJjZS50eXBlICYmICFjdXJyZW50VGVjaFsnY2FuUGxheVNvdXJjZSddKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgc291cmNlIGxpc3Qgd2l0aCB0aGUgY3VycmVudCBzb3VyY2UgYW5kIHNlbmQgdGhyb3VnaFxuICAgICAgICAvLyB0aGUgdGVjaCBsb29wIHRvIGNoZWNrIGZvciBhIGNvbXBhdGlibGUgdGVjaG5vbG9neVxuICAgICAgICB0aGlzLnNvdXJjZUxpc3RfKFtzb3VyY2VdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVfLnNyYyA9IHNvdXJjZS5zcmM7XG4gICAgICAgIHRoaXMuY3VycmVudFR5cGVfID0gc291cmNlLnR5cGUgfHwgJyc7XG5cbiAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgdGVjaCBpcyByZWFkeSB0byBzZXQgdGhlIHNvdXJjZVxuICAgICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAvLyBUaGUgc2V0U291cmNlIHRlY2ggbWV0aG9kIHdhcyBhZGRlZCB3aXRoIHNvdXJjZSBoYW5kbGVyc1xuICAgICAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIHRoZSBkaXJlY3QgcHJvdG90eXBlIGZvciB0aGUgY2FzZSB3aGVyZSBzdWJjbGFzc2VzXG4gICAgICAgICAgLy8gb2YgdGhlIHRlY2ggZG8gbm90IHN1cHBvcnQgc291cmNlIGhhbmRsZXJzXG4gICAgICAgICAgaWYgKGN1cnJlbnRUZWNoLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc2V0U291cmNlJykpIHtcbiAgICAgICAgICAgIHRoaXMudGVjaENhbGwoJ3NldFNvdXJjZScsIHNvdXJjZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGVjaENhbGwoJ3NyYycsIHNvdXJjZS5zcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfWydwcmVsb2FkJ10gPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zX1snYXV0b3BsYXknXSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICogQHBhcmFtICB7W3R5cGVdfSBzb3VyY2VzIEFycmF5IG9mIHNvdXJjZSBvYmplY3RzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzb3VyY2VMaXN0Xyhzb3VyY2VzKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShzb3VyY2VzKTtcblxuICAgIGlmIChzb3VyY2VUZWNoKSB7XG4gICAgICBpZiAoc291cmNlVGVjaC50ZWNoID09PSB0aGlzLnRlY2hOYW1lKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgdGVjaG5vbG9neSBpcyBhbHJlYWR5IGxvYWRlZCwgc2V0IHRoZSBzb3VyY2VcbiAgICAgICAgdGhpcy5zcmMoc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxuICAgICAgICB0aGlzLmxvYWRUZWNoKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHRoaXMuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9ucygpWydub3RTdXBwb3J0ZWRNZXNzYWdlJ10pIH0pO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgLy8gdGhpcyBuZWVkcyBhIGJldHRlciBjb21tZW50IGFib3V0IHdoeSB0aGlzIGlzIG5lZWRlZFxuICAgICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gbG9hZGluZyB0aGUgc3JjIGRhdGEuXG4gICAqIEByZXR1cm4ge1BsYXllcn0gUmV0dXJucyB0aGUgcGxheWVyXG4gICAqL1xuICBsb2FkKCkge1xuICAgIHRoaXMudGVjaENhbGwoJ2xvYWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIG9mIHRoZSBjdXJyZW50IHNvdXJjZSB2YWx1ZSBlLmcuIGh0dHA6Ly9teXNpdGUuY29tL3ZpZGVvLm1wNFxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggYGN1cnJlbnRUeXBlYCB0byBhc3Npc3QgaW4gcmVidWlsZGluZyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cbiAgY3VycmVudFNyYygpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdjdXJyZW50U3JjJykgfHwgdGhpcy5jYWNoZV8uc3JjIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxuICAgKiBUaGlzIGNhbiBhbGxvdyB5b3UgcmVidWlsZCB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHNvIHRoYXQgeW91IGNvdWxkIGxvYWQgdGhlIHNhbWVcbiAgICogc291cmNlIGFuZCB0ZWNoIGxhdGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHNvdXJjZSBNSU1FIHR5cGVcbiAgICovXG4gIGN1cnJlbnRUeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFR5cGVfIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHByZWxvYWQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZSB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBwcmVsb2FkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGwoJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfWydwcmVsb2FkJ10gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdwcmVsb2FkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgYXV0b3BsYXkgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gUmV0dXJucyB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgYXV0b3BsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0QXV0b3BsYXknLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfWydhdXRvcGxheSddID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnYXV0b3BsYXknLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9vcCBhdHRyaWJ1dGUgb24gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxvb3AgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG4gIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc19bJ2xvb3AnXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXQoJ2xvb3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiAjIyMjIyBFWEFNUExFOlxuICAgKlxuICAgKiAgICAgLy8gZ2V0dGluZ1xuICAgKiAgICAgdmFyIGN1cnJlbnRQb3N0ZXIgPSBteVBsYXllci5wb3N0ZXIoKTtcbiAgICpcbiAgICogICAgIC8vIHNldHRpbmdcbiAgICogICAgIG15UGxheWVyLnBvc3RlcignaHR0cDovL2V4YW1wbGUuY29tL215SW1hZ2UuanBnJyk7XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZz19IFtzcmNdIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqIEByZXR1cm4ge1N0cmluZ30gcG9zdGVyIFVSTCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgcG9zdGVyKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zdGVyXztcbiAgICB9XG5cbiAgICAvLyBUaGUgY29ycmVjdCB3YXkgdG8gcmVtb3ZlIGEgcG9zdGVyIGlzIHRvIHNldCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHNyYyA9ICcnO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9zdGVyIHZhcmlhYmxlXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoJ3MgcG9zdGVyXG4gICAgdGhpcy50ZWNoQ2FsbCgnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY29udHJvbHMgU2V0IGNvbnRyb2xzIHRvIHNob3dpbmcgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIENvbnRyb2xzIGFyZSBzaG93aW5nXG4gICAqL1xuICBjb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDsgLy8gZm9yY2UgYm9vbGVhblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMuY29udHJvbHNfICE9PSBib29sKSB7XG4gICAgICAgIHRoaXMuY29udHJvbHNfID0gYm9vbDtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuY29udHJvbHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBuYXRpdmUgY29udHJvbHMgb24vb2ZmLiBOYXRpdmUgY29udHJvbHMgYXJlIHRoZSBjb250cm9scyBidWlsdCBpbnRvXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcbiAgICogKGUuZy4gVmltZW8gQ29udHJvbHMpXG4gICAqXG4gICAqICoqVGhpcyBzaG91bGQgb25seSBiZSBzZXQgYnkgdGhlIGN1cnJlbnQgdGVjaCwgYmVjYXVzZSBvbmx5IHRoZSB0ZWNoIGtub3dzXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGJvb2wgICAgVHJ1ZSBzaWduYWxzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIGFyZSBvblxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgUmV0dXJucyB0aGUgcGxheWVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1c2luZ05hdGl2ZUNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sOyAvLyBmb3JjZSBib29sZWFuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyAhPT0gYm9vbCkge1xuICAgICAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfID0gYm9vbDtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIG5hdGl2ZSBkZXZpY2UgY29udHJvbHNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBldmVudCB1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAgICAgICAgICogQG1lbWJlcm9mIFBsYXllclxuICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IHVzaW5nY3VzdG9tY29udHJvbHNcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgUGxheWVyXG4gICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzaW5nY3VzdG9tY29udHJvbHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIGdldCB0aGUgY3VycmVudCBNZWRpYUVycm9yXG4gICAqIEBwYXJhbSAgeyp9IGVyciBBIE1lZGlhRXJyb3Igb3IgYSBTdHJpbmcvTnVtYmVyIHRvIGJlIHR1cm5lZCBpbnRvIGEgTWVkaWFFcnJvclxuICAgKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9ICAgICB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgICAgICAgICAgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yXyB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmluZyB0byBkZWZhdWx0XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZXJyb3InKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVycm9yIGluc3RhbmNlXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIE1lZGlhRXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG4gICAgfVxuXG4gICAgLy8gZmlyZSBhbiBlcnJvciBldmVudCBvbiB0aGUgcGxheWVyXG4gICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuXG4gICAgLy8gYWRkIHRoZSB2anMtZXJyb3IgY2xhc3NuYW1lIHRvIHRoZSBwbGF5ZXJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZXJyb3InKTtcblxuICAgIC8vIGxvZyB0aGUgbmFtZSBvZiB0aGUgZXJyb3IgdHlwZSBhbmQgYW55IG1lc3NhZ2VcbiAgICAvLyBpZTgganVzdCBsb2dzIFwiW29iamVjdCBvYmplY3RdXCIgaWYgeW91IGp1c3QgbG9nIHRoZSBlcnJvciBvYmplY3RcbiAgICBMaWIubG9nLmVycm9yKGAoQ09ERToke3RoaXMuZXJyb3JfLmNvZGV9ICR7TWVkaWFFcnJvci5lcnJvclR5cGVzW3RoaXMuZXJyb3JfLmNvZGVdfSlgLCB0aGlzLmVycm9yXy5tZXNzYWdlLCB0aGlzLmVycm9yXyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwiZW5kZWRcIiBzdGF0ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBlbmRlZCBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgZW5kZWQoKSB7IHJldHVybiB0aGlzLnRlY2hHZXQoJ2VuZGVkJyk7IH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcInNlZWtpbmdcIiBzdGF0ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBzZWVraW5nIHN0YXRlLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBzZWVraW5nKCkgeyByZXR1cm4gdGhpcy50ZWNoR2V0KCdzZWVraW5nJyk7IH1cblxuICByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9XG5cbiAgdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcbiAgICAgIGlmIChib29sICE9PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhcyBpbmFjdGl2ZSBhbmQgaXMgbm93IGFjdGl2ZSB3ZSB3YW50IHRvIHJlc2V0IHRoZVxuICAgICAgICAgIC8vIGluYWN0aXZpdHkgdGltZXJcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyYWN0aXZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UncmUgc3dpdGNoaW5nIHRoZSBzdGF0ZSB0byBpbmFjdGl2ZSBtYW51YWxseSwgc28gZXJhc2UgYW55IG90aGVyXG4gICAgICAgICAgLy8gYWN0aXZpdHlcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgICAgIC8vIENocm9tZS9TYWZhcmkvSUUgaGF2ZSBidWdzIHdoZXJlIHdoZW4geW91IGNoYW5nZSB0aGUgY3Vyc29yIGl0IGNhblxuICAgICAgICAgIC8vIHRyaWdnZXIgYSBtb3VzZW1vdmUgZXZlbnQuIFRoaXMgY2F1c2VzIGFuIGlzc3VlIHdoZW4geW91J3JlIGhpZGluZ1xuICAgICAgICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxuICAgICAgICAgIC8vIGFjdGl2aXR5LiBNYWtpbmcgaXQgaW1wb3NzaWJsZSB0byBnbyBpbnRvIGluYWN0aXZlIG1vZGUuIFNwZWNpZmljYWxseVxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBmdWxsc2NyZWVuIHdoZW4gd2UgcmVhbGx5IG5lZWQgdG8gaGlkZSB0aGUgY3Vyc29yLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2hlbiB0aGlzIGdldHMgcmVzb2x2ZWQgaW4gQUxMIGJyb3dzZXJzIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMzA0MVxuICAgICAgICAgIGlmKHRoaXMudGVjaCkge1xuICAgICAgICAgICAgdGhpcy50ZWNoLm9uZSgnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVzZXJBY3RpdmVfO1xuICB9XG5cbiAgbGlzdGVuRm9yVXNlckFjdGl2aXR5KCkge1xuICAgIGxldCBtb3VzZUluUHJvZ3Jlc3MsIGxhc3RNb3ZlWCwgbGFzdE1vdmVZO1xuXG4gICAgbGV0IG9uQWN0aXZpdHkgPSBMaWIuYmluZCh0aGlzLCB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICBsZXQgb25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZihlLnNjcmVlblggIT0gbGFzdE1vdmVYIHx8IGUuc2NyZWVuWSAhPSBsYXN0TW92ZVkpIHtcbiAgICAgICAgbGFzdE1vdmVYID0gZS5zY3JlZW5YO1xuICAgICAgICBsYXN0TW92ZVkgPSBlLnNjcmVlblk7XG4gICAgICAgIG9uQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IG9uTW91c2VEb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbkFjdGl2aXR5KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBTZXR0aW5nIHVzZXJBY3Rpdml0eT10cnVlIG5vdyBhbmQgc2V0dGluZyB0aGUgaW50ZXJ2YWwgdG8gdGhlIHNhbWUgdGltZVxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxuICAgICAgLy8gbmV4dCBhY3Rpdml0eUNoZWNrXG4gICAgICBtb3VzZUluUHJvZ3Jlc3MgPSB0aGlzLnNldEludGVydmFsKG9uQWN0aXZpdHksIDI1MCk7XG4gICAgfTtcblxuICAgIGxldCBvbk1vdXNlVXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgb25BY3Rpdml0eSgpO1xuICAgICAgLy8gU3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIG1vdXNlL3RvdWNoIGlzIGRvd25cbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgIH07XG5cbiAgICAvLyBBbnkgbW91c2UgbW92ZW1lbnQgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgYWN0aXZpdHlcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIHRoaXMub24oJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgLy8gU2hvdWxkbid0IG5lZWQgdG8gdXNlIGluUHJvZ3Jlc3MgaW50ZXJ2YWwgYmVjYXVzZSBvZiBrZXkgcmVwZWF0XG4gICAgdGhpcy5vbigna2V5ZG93bicsIG9uQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgb25BY3Rpdml0eSk7XG5cbiAgICAvLyBSdW4gYW4gaW50ZXJ2YWwgZXZlcnkgMjUwIG1pbGxpc2Vjb25kcyBpbnN0ZWFkIG9mIHN0dWZmaW5nIGV2ZXJ5dGhpbmcgaW50b1xuICAgIC8vIHRoZSBtb3VzZW1vdmUvdG91Y2htb3ZlIGZ1bmN0aW9uIGl0c2VsZiwgdG8gcHJldmVudCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi5cbiAgICAvLyBgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHlgIHNpbXBseSBzZXRzIHRoaXMudXNlckFjdGl2aXR5XyB0byB0cnVlLCB3aGljaFxuICAgIC8vIHRoZW4gZ2V0cyBwaWNrZWQgdXAgYnkgdGhpcyBsb29wXG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2xlYXJuaW5nLWZyb20tdHdpdHRlci9cbiAgICBsZXQgYWN0aXZpdHlDaGVjayA9IHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaW5hY3Rpdml0eVRpbWVvdXQ7XG5cbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBtb3VzZS90b3VjaCBhY3Rpdml0eSBoYXMgaGFwcGVuZWRcbiAgICAgIGlmICh0aGlzLnVzZXJBY3Rpdml0eV8pIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2aXR5IHRyYWNrZXJcbiAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgc3RhdGUgd2FzIGluYWN0aXZlLCBzZXQgdGhlIHN0YXRlIHRvIGFjdGl2ZVxuICAgICAgICB0aGlzLnVzZXJBY3RpdmUodHJ1ZSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGluYWN0aXZpdHkgdGltZW91dCB0byBzdGFydCB0aGUgdGltZXIgb3ZlclxuICAgICAgICB0aGlzLmNsZWFyVGltZW91dChpbmFjdGl2aXR5VGltZW91dCk7XG5cbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLm9wdGlvbnMoKVsnaW5hY3Rpdml0eVRpbWVvdXQnXTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgLy8gSW4gPHRpbWVvdXQ+IG1pbGxpc2Vjb25kcywgaWYgbm8gbW9yZSBhY3Rpdml0eSBoYXMgb2NjdXJyZWQgdGhlXG4gICAgICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgICAgICBpbmFjdGl2aXR5VGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIGluYWN0aXZpdHlUaW1lb3V0IGNhbiB0cmlnZ2VyIGp1c3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHlDaGVjayBsb29wXG4gICAgICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZXJBY3Rpdml0eV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMjUwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gIEEgcGxheWJhY2sgcmF0ZSBvZlxuICAgKiAxLjAgcmVwcmVzZW50cyBub3JtYWwgc3BlZWQgYW5kIDAuNSB3b3VsZCBpbmRpY2F0ZSBoYWxmLXNwZWVkXG4gICAqIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0gcmF0ZSAgICBOZXcgcGxheWJhY2sgcmF0ZSB0byBzZXQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZXR1cm5zIHRoZSBuZXcgcGxheWJhY2sgcmF0ZSB3aGVuIHNldHRpbmdcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmdcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZVxuICAgKi9cbiAgcGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRQbGF5YmFja1JhdGUnLCByYXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdwbGF5YmFja1JhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBhdWRpbyBmbGFnXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGJvb2wgICAgVHJ1ZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBhbiBhdWRpbyBwbGF5ZXIuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgUmV0dXJucyB0cnVlIGlmIHBsYXllciBpcyBhdWRpbywgZmFsc2UgaWYgbm90IHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgUmV0dXJucyB0aGUgcGxheWVyIGlmIHNldHRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQXVkaW8oYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNBdWRpb18gPSAhIWJvb2w7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmlzQXVkaW9fO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgbmV0d29yayBhY3Rpdml0eSBmb3IgdGhlIGVsZW1lbnQsIGZyb21cbiAgICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICAgKiAtIE5FVFdPUktfRU1QVFkgKG51bWVyaWMgdmFsdWUgMClcbiAgICogICBUaGUgZWxlbWVudCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpc2VkLiBBbGwgYXR0cmlidXRlcyBhcmUgaW5cbiAgICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAgICogLSBORVRXT1JLX0lETEUgKG51bWVyaWMgdmFsdWUgMSlcbiAgICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlIGFuZCBoYXNcbiAgICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gICAqICAgdGhpcyB0aW1lLlxuICAgKiAtIE5FVFdPUktfTE9BRElORyAobnVtZXJpYyB2YWx1ZSAyKVxuICAgKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICAgKiAtIE5FVFdPUktfTk9fU09VUkNFIChudW1lcmljIHZhbHVlIDMpXG4gICAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSwgYnV0IGl0IGhhc1xuICAgKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNuZXR3b3JrLXN0YXRlc1xuICAgKi9cbiAgbmV0d29ya1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXQoJ25ldHdvcmtTdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICAgKiB3aXRoIHJlc3BlY3QgdG8gcmVuZGVyaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLCBmcm9tIHRoZVxuICAgKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAgICogLSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcbiAgICogICBObyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgdGhlIG1lZGlhIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAgICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gICAqICAgRW5vdWdoIG9mIHRoZSByZXNvdXJjZSBoYXMgYmVlbiBvYnRhaW5lZCB0aGF0IHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAgICogICByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gICAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAgICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLlxuICAgKiAtIEhBVkVfRlVUVVJFX0RBVEEgKG51bWVyaWMgdmFsdWUgMylcbiAgICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICAgKiAgIHdlbGwgYXMgZW5vdWdoIGRhdGEgZm9yIHRoZSB1c2VyIGFnZW50IHRvIGFkdmFuY2UgdGhlIGN1cnJlbnRcbiAgICogICBwbGF5YmFjayBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIG9mIHBsYXliYWNrLlxuICAgKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAgICogICBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgZm9yXG4gICAqICAgcGxheWJhY2sgdG8gcHJvY2VlZCB1bmludGVycnVwdGVkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50IHBsYXliYWNrIHJlbmRlcmluZyBzdGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcmVhZHlzdGF0ZVxuICAgKi9cbiAgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdyZWFkeVN0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogVGV4dCB0cmFja3MgYXJlIHRyYWNrcyBvZiB0aW1lZCB0ZXh0IGV2ZW50cy5cbiAgICogQ2FwdGlvbnMgLSB0ZXh0IGRpc3BsYXllZCBvdmVyIHRoZSB2aWRlbyBmb3IgdGhlIGhlYXJpbmcgaW1wYWlyZWRcbiAgICogU3VidGl0bGVzIC0gdGV4dCBkaXNwbGF5ZWQgb3ZlciB0aGUgdmlkZW8gZm9yIHRob3NlIHdobyBkb24ndCB1bmRlcnN0YW5kIGxhbmd1YWdlIGluIHRoZSB2aWRlb1xuICAgKiBDaGFwdGVycyAtIHRleHQgZGlzcGxheWVkIGluIGEgbWVudSBhbGxvd2luZyB0aGUgdXNlciB0byBqdW1wIHRvIHBhcnRpY3VsYXIgcG9pbnRzIChjaGFwdGVycykgaW4gdGhlIHZpZGVvXG4gICAqIERlc2NyaXB0aW9ucyAobm90IHN1cHBvcnRlZCB5ZXQpIC0gYXVkaW8gZGVzY3JpcHRpb25zIHRoYXQgYXJlIHJlYWQgYmFjayB0byB0aGUgdXNlciBieSBhIHNjcmVlbiByZWFkaW5nIGRldmljZVxuICAgKi9cblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3MuIGNhcHRpb25zLCBzdWJ0aXRsZXMsIGNoYXB0ZXJzLCBkZXNjcmlwdGlvbnNcbiAgICogaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXRleHR0cmFja3NcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICBBcnJheSBvZiB0cmFjayBvYmplY3RzXG4gICAqL1xuICB0ZXh0VHJhY2tzKCkge1xuICAgIC8vIGNhbm5vdCB1c2UgdGVjaEdldCBkaXJlY3RseSBiZWNhdXNlIGl0IGNoZWNrcyB0byBzZWUgd2hldGhlciB0aGUgdGVjaCBpcyByZWFkeS5cbiAgICAvLyBGbGFzaCBpcyB1bmxpa2VseSB0byBiZSByZWFkeSBpbiB0aW1lIGJ1dCB0ZXh0VHJhY2tzIHNob3VsZCBzdGlsbCB3b3JrLlxuICAgIHJldHVybiB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWyd0ZXh0VHJhY2tzJ10oKTtcbiAgfVxuXG4gIHJlbW90ZVRleHRUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaCAmJiB0aGlzLnRlY2hbJ3JlbW90ZVRleHRUcmFja3MnXSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRleHQgdHJhY2tcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIFczQyBzZXR0aW5ncyB3ZSBhbGxvdyBhZGRpbmcgYWRkaXRpb25hbCBpbmZvIHRocm91Z2ggb3B0aW9ucy5cbiAgICogaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWFkZHRleHR0cmFja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gIGtpbmQgICAgICAgIENhcHRpb25zLCBzdWJ0aXRsZXMsIGNoYXB0ZXJzLCBkZXNjcmlwdGlvbnMsIG9yIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbGFiZWwgICAgICAgT3B0aW9uYWwgbGFiZWxcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBsYW5ndWFnZSAgICBPcHRpb25hbCBsYW5ndWFnZVxuICAgKi9cbiAgYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWydhZGRUZXh0VHJhY2snXShraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaFsnYWRkUmVtb3RlVGV4dFRyYWNrJ10ob3B0aW9ucyk7XG4gIH1cblxuICByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWydyZW1vdmVSZW1vdGVUZXh0VHJhY2snXSh0cmFjayk7XG4gIH1cblxuICAvLyBNZXRob2RzIHRvIGFkZCBzdXBwb3J0IGZvclxuICAvLyBpbml0aWFsVGltZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2luaXRpYWxUaW1lJyk7IH0sXG4gIC8vIHN0YXJ0T2Zmc2V0VGltZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ3N0YXJ0T2Zmc2V0VGltZScpOyB9LFxuICAvLyBwbGF5ZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdwbGF5ZWQnKTsgfSxcbiAgLy8gc2Vla2FibGU6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdzZWVrYWJsZScpOyB9LFxuICAvLyB2aWRlb1RyYWNrczogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ3ZpZGVvVHJhY2tzJyk7IH0sXG4gIC8vIGF1ZGlvVHJhY2tzOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnYXVkaW9UcmFja3MnKTsgfSxcbiAgLy8gdmlkZW9XaWR0aDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ3ZpZGVvV2lkdGgnKTsgfSxcbiAgLy8gdmlkZW9IZWlnaHQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCd2aWRlb0hlaWdodCcpOyB9LFxuICAvLyBkZWZhdWx0UGxheWJhY2tSYXRlOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnZGVmYXVsdFBsYXliYWNrUmF0ZScpOyB9LFxuICAvLyBtZWRpYUdyb3VwOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnbWVkaWFHcm91cCcpOyB9LFxuICAvLyBjb250cm9sbGVyOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnY29udHJvbGxlcicpOyB9LFxuICAvLyBkZWZhdWx0TXV0ZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdkZWZhdWx0TXV0ZWQnKTsgfVxuXG4gIC8vIFRPRE9cbiAgLy8gY3VycmVudFNyY0xpc3Q6IHRoZSBhcnJheSBvZiBzb3VyY2VzIGluY2x1ZGluZyBvdGhlciBmb3JtYXRzIGFuZCBiaXRyYXRlc1xuICAvLyBwbGF5TGlzdDogYXJyYXkgb2Ygc291cmNlIGxpc3RzIGluIG9yZGVyIG9mIHBsYXliYWNrXG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5ZXIncyBsYW5ndWFnZSBjb2RlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbGFuZ3VhZ2VDb2RlICBUaGUgbG9jYWxlIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBsb2NhbGUgc3RyaW5nIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgc2VsZiwgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBsYW5ndWFnZShsYW5ndWFnZUNvZGUpIHtcbiAgICBpZiAobGFuZ3VhZ2VDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlXztcbiAgICB9XG5cbiAgICB0aGlzLmxhbmd1YWdlXyA9IGxhbmd1YWdlQ29kZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsYXllcidzIGxhbmd1YWdlIGRpY3Rpb25hcnlcbiAgICovXG4gIGxhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5sYW5ndWFnZXNfO1xuICB9XG5cbiAgc3RhdGljIGdldFRhZ1NldHRpbmdzKHRhZykge1xuICAgIGxldCBiYXNlT3B0aW9ucyA9IHtcbiAgICAgICdzb3VyY2VzJzogW10sXG4gICAgICAndHJhY2tzJzogW11cbiAgICB9O1xuXG4gICAgY29uc3QgdGFnT3B0aW9ucyA9IExpYi5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuICAgIGNvbnN0IGRhdGFTZXR1cCA9IHRhZ09wdGlvbnNbJ2RhdGEtc2V0dXAnXTtcblxuICAgIC8vIENoZWNrIGlmIGRhdGEtc2V0dXAgYXR0ciBleGlzdHMuXG4gICAgaWYgKGRhdGFTZXR1cCAhPT0gbnVsbCl7XG4gICAgICAvLyBQYXJzZSBvcHRpb25zIEpTT05cbiAgICAgIC8vIElmIGVtcHR5IHN0cmluZywgbWFrZSBpdCBhIHBhcnNhYmxlIGpzb24gb2JqZWN0LlxuICAgICAgTGliLm9iai5tZXJnZSh0YWdPcHRpb25zLCBzYWZlUGFyc2VUdXBsZShkYXRhU2V0dXAgfHwgJ3t9JylbMV0pO1xuICAgIH1cblxuICAgIExpYi5vYmoubWVyZ2UoYmFzZU9wdGlvbnMsIHRhZ09wdGlvbnMpO1xuXG4gICAgLy8gR2V0IHRhZyBjaGlsZHJlbiBzZXR0aW5nc1xuICAgIGlmICh0YWcuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKGxldCBpPTAsIGo9Y2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnc291cmNlJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zWydzb3VyY2VzJ10ucHVzaChMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBiYXNlT3B0aW9uc1sndHJhY2tzJ10ucHVzaChMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfVxuXG59XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG4vKipcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICogQWxsIG9wdGlvbnMgc2hvdWxkIHVzZSBzdHJpbmcga2V5cyBzbyB0aGV5IGF2b2lkXG4gKiByZW5hbWluZyBieSBjbG9zdXJlIGNvbXBpbGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IE9wdGlvbnM7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBpbml0aWFsIGR1cmF0aW9uIGFuZCBkaW1lbnNpb24gaW5mb3JtYXRpb25cbiAqIEBldmVudCBsb2FkZWRtZXRhZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9uTG9hZGVkTWV0YURhdGE7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBkb3dubG9hZGVkIGRhdGEgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb25cbiAqIEBldmVudCBsb2FkZWRkYXRhXG4gKi9cblBsYXllci5wcm90b3R5cGUub25Mb2FkZWREYXRhO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZmluaXNoZWQgZG93bmxvYWRpbmcgdGhlIHNvdXJjZSBkYXRhXG4gKiBAZXZlbnQgbG9hZGVkYWxsZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9uTG9hZGVkQWxsRGF0YTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGFjdGl2ZSwgZS5nLiBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgcGxheWVyXG4gKiBAZXZlbnQgdXNlcmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9uVXNlckFjdGl2ZTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGluYWN0aXZlLCBlLmcuIGEgc2hvcnQgZGVsYXkgYWZ0ZXIgdGhlIGxhc3QgbW91c2UgbW92ZSBvciBjb250cm9sIGludGVyYWN0aW9uXG4gKiBAZXZlbnQgdXNlcmluYWN0aXZlXG4gKi9cblBsYXllci5wcm90b3R5cGUub25Vc2VySW5hY3RpdmU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuICpcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdXNlLlxuICogQGV2ZW50IHRpbWV1cGRhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vblRpbWVVcGRhdGU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqIEBldmVudCB2b2x1bWVjaGFuZ2VcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vblZvbHVtZUNoYW5nZTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICogQGV2ZW50IGVycm9yXG4gKi9cblBsYXllci5wcm90b3R5cGUub25FcnJvcjtcblxuUGxheWVyLnByb3RvdHlwZS5mbGV4Tm90U3VwcG9ydGVkXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblxuICByZXR1cm4gISgnZmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XG4gICAgICAgICAgJ3dlYmtpdEZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgICAgICAgICdtb3pGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHxcbiAgICAgICAgICAnbXNGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUpO1xufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xuZXhwb3J0IGRlZmF1bHQgUGxheWVyO1xuIiwiaW1wb3J0IFBsYXllciBmcm9tICcuL3BsYXllcic7XG5cbi8qKlxuICogdGhlIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgYSB2aWRlby5qcyBwbHVnaW5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsdWdpblxuICogQHBhcmFtICB7RnVuY3Rpb259IGluaXQgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIHdoZW4gdGhlIHBsYXllciBpbml0c1xuICovXG52YXIgcGx1Z2luID0gZnVuY3Rpb24obmFtZSwgaW5pdCl7XG4gIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBpbml0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuL2J1dHRvbic7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuXG4vKiBQb3N0ZXIgSW1hZ2Vcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFRoZSBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHNob3dpbmcgdGhlIHBvc3RlciBpbWFnZS5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUG9zdGVySW1hZ2UgZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcGxheWVyLm9uKCdwb3N0ZXJjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSBwb3N0ZXIgaW1hZ2VcbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBwb3N0ZXIgaW1hZ2UgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcG9zdGVyJyxcblxuICAgICAgLy8gRG9uJ3Qgd2FudCBwb3N0ZXIgdG8gYmUgdGFiYmFibGUuXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9KTtcblxuICAgIC8vIFRvIGVuc3VyZSB0aGUgcG9zdGVyIGltYWdlIHJlc2l6ZXMgd2hpbGUgbWFpbnRhaW5pbmcgaXRzIG9yaWdpbmFsIGFzcGVjdFxuICAgIC8vIHJhdGlvLCB1c2UgYSBkaXYgd2l0aCBgYmFja2dyb3VuZC1zaXplYCB3aGVuIGF2YWlsYWJsZS4gRm9yIGJyb3dzZXJzIHRoYXRcbiAgICAvLyBkbyBub3Qgc3VwcG9ydCBgYmFja2dyb3VuZC1zaXplYCAoZS5nLiBJRTgpLCBmYWxsIGJhY2sgb24gdXNpbmcgYSByZWd1bGFyXG4gICAgLy8gaW1nIGVsZW1lbnQuXG4gICAgaWYgKCFMaWIuQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRCkge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18gPSBMaWIuY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB1cGRhdGVzIHRvIHRoZSBwbGF5ZXIncyBwb3N0ZXIgc291cmNlXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgbGV0IHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc3RlciBzb3VyY2UgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZFxuICAgKi9cbiAgc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYmFja2dyb3VuZEltYWdlID0gJyc7XG4gICAgICAvLyBBbnkgZmFsc2V5IHZhbHVlcyBzaG91bGQgc3RheSBhcyBhbiBlbXB0eSBzdHJpbmcsIG90aGVyd2lzZVxuICAgICAgLy8gdGhpcyB3aWxsIHRocm93IGFuIGV4dHJhIGVycm9yXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke3VybH1cIilgO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsXy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrcyBvbiB0aGUgcG9zdGVyIGltYWdlXG4gICAqL1xuICBvbkNsaWNrKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgYSBjbGljayB0byB0cmlnZ2VyIHBsYXliYWNrIHdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkXG4gICAgLy8gYnV0IENTUyBzaG91bGQgYmUgaGlkaW5nIHRoZSBwb3N0ZXIgdG8gcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbn1cblxuQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcbmV4cG9ydCBkZWZhdWx0IFBvc3RlckltYWdlO1xuIiwiaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxubGV0IF93aW5kb3dMb2FkZWQgPSBmYWxzZTtcbmxldCB2aWRlb2pzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRnVuY3Rpb25zIGZvciBhdXRvbWF0aWNhbGx5IHNldHRpbmcgdXAgYSBwbGF5ZXJcbiAqIGJhc2VkIG9uIHRoZSBkYXRhLXNldHVwIGF0dHJpYnV0ZSBvZiB0aGUgdmlkZW8gdGFnXG4gKi9cblxuLy8gQXV0b21hdGljYWxseSBzZXQgdXAgYW55IHRhZ3MgdGhhdCBoYXZlIGEgZGF0YS1zZXR1cCBhdHRyaWJ1dGVcbnZhciBhdXRvU2V0dXAgPSBmdW5jdGlvbigpe1xuICAvLyBPbmUgZGF5LCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBJRTgsIGdvIGJhY2sgdG8gdGhpcywgYnV0IGluIHRoZSBtZWFudGltZS4uLipoYWNrIGhhY2sgaGFjaypcbiAgLy8gdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIC8vIHZhciBtZWRpYUVscyA9IHZpZHMuY29uY2F0KGF1ZGlvcyk7XG5cbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGVhY2ggbGlzdCBvZiBlbGVtZW50c1xuICAvLyB0byBidWlsZCB1cCBhIG5ldywgY29tYmluZWQgbGlzdCBvZiBlbGVtZW50cy5cbiAgdmFyIHZpZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpO1xuICB2YXIgbWVkaWFFbHMgPSBbXTtcbiAgaWYgKHZpZHMgJiYgdmlkcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yKGxldCBpPTAsIGU9dmlkcy5sZW5ndGg7IGk8ZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKHZpZHNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAoYXVkaW9zICYmIGF1ZGlvcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yKGxldCBpPTAsIGU9YXVkaW9zLmxlbmd0aDsgaTxlOyBpKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goYXVkaW9zW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgbWVkaWEgZWxlbWVudHMgZXhpc3RcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcblxuICAgIGZvciAobGV0IGk9MCwgZT1tZWRpYUVscy5sZW5ndGg7IGk8ZTsgaSsrKSB7XG4gICAgICBsZXQgbWVkaWFFbCA9IG1lZGlhRWxzW2ldO1xuXG4gICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGV4aXN0cywgaGFzIGdldEF0dHJpYnV0ZSBmdW5jLlxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWxbJ3BsYXllciddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXQgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICBsZXQgcGxheWVyID0gdmlkZW9qcyhtZWRpYUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgZ2V0QXR0cmlidXRlIGlzbid0IGRlZmluZWQsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAvLyBObyB2aWRlb3Mgd2VyZSBmb3VuZCwgc28ga2VlcCBsb29waW5nIHVubGVzcyBwYWdlIGlzIGZpbmlzaGVkIGxvYWRpbmcuXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcbiAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICB9XG59O1xuXG4vLyBQYXVzZSB0byBsZXQgdGhlIERPTSBrZWVwIHByb2Nlc3NpbmdcbnZhciBhdXRvU2V0dXBUaW1lb3V0ID0gZnVuY3Rpb24od2FpdCwgdmpzKXtcbiAgdmlkZW9qcyA9IHZqcztcbiAgc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xufTtcblxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG59IGVsc2Uge1xuICBFdmVudHMub25lKHdpbmRvdywgJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xuICB9KTtcbn1cblxudmFyIGhhc0xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3dpbmRvd0xvYWRlZDtcbn07XG5cbmV4cG9ydCB7IGF1dG9TZXR1cCwgYXV0b1NldHVwVGltZW91dCwgaGFzTG9hZGVkIH07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcblxuLyoqXG4gKiBTZWVrQmFyIEJlaGF2aW9yIGluY2x1ZGVzIHBsYXkgcHJvZ3Jlc3MgYmFyLCBhbmQgc2VlayBoYW5kbGVcbiAqIE5lZWRlZCBzbyBpdCBjYW4gZGV0ZXJtaW5lIHNlZWsgcG9zaXRpb24gYmFzZWQgb24gaGFuZGxlIHBvc2l0aW9uL3NpemVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTbGlkZXJIYW5kbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXItaGFuZGxlJztcbiAgICBwcm9wcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmRlZmF1bHRWYWx1ZSB8fCAwfTwvc3Bhbj5gXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCBwcm9wcyk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlckhhbmRsZScsIFNsaWRlckhhbmRsZSk7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXJIYW5kbGU7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKiBTbGlkZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIHNsaWRlcnMgbGlrZSB0aGUgdm9sdW1lIGJhciBhbmQgc2VlayBiYXJcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2xpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciBhbmQgaGFuZGxlIHRvIG1hdGNoIHdpdGggdGhlIGNoaWxkIFNsaWRlciBjbGFzcyBpcyBsb29raW5nIGZvclxuICAgIHRoaXMuYmFyID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydiYXJOYW1lJ10pO1xuICAgIHRoaXMuaGFuZGxlID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydoYW5kbGVOYW1lJ10pO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICB0aGlzLnZlcnRpY2FsKCEhdGhpcy5vcHRpb25zKClbJ3ZlcnRpY2FsJ10pO1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24pO1xuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vbkZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAnY29udHJvbHN2aXNpYmxlJywgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMub24ocGxheWVyLCB0aGlzLnBsYXllckV2ZW50LCB0aGlzLnVwZGF0ZSk7XG4gIH1cblxuICBjcmVhdGVFbCh0eXBlLCBwcm9wcz17fSkge1xuICAgIC8vIEFkZCB0aGUgc2xpZGVyIGVsZW1lbnQgY2xhc3MgdG8gYWxsIHN1YiBjbGFzc2VzXG4gICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyB2anMtc2xpZGVyJztcbiAgICBwcm9wcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwodHlwZSwgcHJvcHMpO1xuICB9XG5cbiAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIExpYi5ibG9ja1RleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGluZycpO1xuXG4gICAgdGhpcy5vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLm9uTW91c2VVcCk7XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIFRvIGJlIG92ZXJyaWRkZW4gYnkgYSBzdWJjbGFzc1xuICBvbk1vdXNlTW92ZSgpIHt9XG5cbiAgb25Nb3VzZVVwKCkge1xuICAgIExpYi51bmJsb2NrVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG5cbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLm9uTW91c2VVcCk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIEluIFZvbHVtZUJhciBpbml0IHdlIGhhdmUgYSBzZXRUaW1lb3V0IGZvciB1cGRhdGUgdGhhdCBwb3BzIGFuZCB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAvLyBleGVjdXRpb24gc3RhY2suIFRoZSBwbGF5ZXIgaXMgZGVzdHJveWVkIGJlZm9yZSB0aGVuIHVwZGF0ZSB3aWxsIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKCF0aGlzLmVsXykgcmV0dXJuO1xuXG4gICAgLy8gSWYgc2NydWJiaW5nLCB3ZSBjb3VsZCB1c2UgYSBjYWNoZWQgdmFsdWUgdG8gbWFrZSB0aGUgaGFuZGxlIGtlZXAgdXAgd2l0aCB0aGUgdXNlcidzIG1vdXNlLlxuICAgIC8vIE9uIEhUTUw1IGJyb3dzZXJzIHNjcnViYmluZyBpcyByZWFsbHkgc21vb3RoLCBidXQgc29tZSBmbGFzaCBwbGF5ZXJzIGFyZSBzbG93LCBzbyB3ZSBtaWdodCB3YW50IHRvIHV0aWxpemUgdGhpcyBsYXRlci5cbiAgICAvLyB2YXIgcHJvZ3Jlc3MgPSAgKHRoaXMucGxheWVyXy5zY3J1YmJpbmcpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgbGV0IHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgbGV0IGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikgcmV0dXJuO1xuXG4gICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vIGR1cmF0aW9uIGFuZCBvdGhlciBkaXZpc2lvbiBpc3N1ZXNcbiAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBwcm9ncmVzcyAhPT0gcHJvZ3Jlc3MgfHxcbiAgICAgICAgcHJvZ3Jlc3MgPCAwIHx8XG4gICAgICAgIHByb2dyZXNzID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGhhbmRsZSwgd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGUgaGFuZGxlIGluIG91ciBjYWxjdWxhdGlvbiBmb3IgcHJvZ3Jlc3MgYmFyXG4gICAgLy8gc28gdGhhdCBpdCBkb2Vzbid0IGZhbGwgc2hvcnQgb2Ygb3IgZXh0ZW5kIHBhc3QgdGhlIGhhbmRsZS5cbiAgICBsZXQgYmFyUHJvZ3Jlc3MgPSB0aGlzLnVwZGF0ZUhhbmRsZVBvc2l0aW9uKHByb2dyZXNzKTtcblxuICAgIC8vIENvbnZlcnQgdG8gYSBwZXJjZW50YWdlIGZvciBzZXR0aW5nXG4gICAgbGV0IHBlcmNlbnRhZ2UgPSBMaWIucm91bmQoYmFyUHJvZ3Jlc3MgKiAxMDAsIDIpICsgJyUnO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgYmFyIHdpZHRoIG9yIGhlaWdodFxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIGJhci5lbCgpLnN0eWxlLmhlaWdodCA9IHBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhci5lbCgpLnN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBVcGRhdGUgdGhlIGhhbmRsZSBwb3NpdGlvbi5cbiAgKi9cbiAgdXBkYXRlSGFuZGxlUG9zaXRpb24ocHJvZ3Jlc3MpIHtcbiAgICBsZXQgaGFuZGxlID0gdGhpcy5oYW5kbGU7XG4gICAgaWYgKCFoYW5kbGUpIHJldHVybjtcblxuICAgIGxldCB2ZXJ0aWNhbCA9IHRoaXMudmVydGljYWwoKTtcbiAgICBsZXQgYm94ID0gdGhpcy5lbF87XG5cbiAgICBsZXQgYm94U2l6ZSwgaGFuZGxlU2l6ZTtcbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGJveFNpemUgPSBib3gub2Zmc2V0SGVpZ2h0O1xuICAgICAgaGFuZGxlU2l6ZSA9IGhhbmRsZS5lbCgpLm9mZnNldEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94U2l6ZSA9IGJveC5vZmZzZXRXaWR0aDtcbiAgICAgIGhhbmRsZVNpemUgPSBoYW5kbGUuZWwoKS5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBUaGUgd2lkdGggb2YgdGhlIGhhbmRsZSBpbiBwZXJjZW50IG9mIHRoZSBjb250YWluaW5nIGJveFxuICAgIC8vIEluIElFLCB3aWR0aHMgbWF5IG5vdCBiZSByZWFkeSB5ZXQgY2F1c2luZyBOYU5cbiAgICBsZXQgaGFuZGxlUGVyY2VudCA9IChoYW5kbGVTaXplKSA/IGhhbmRsZVNpemUgLyBib3hTaXplIDogMDtcblxuICAgIC8vIEdldCB0aGUgYWRqdXN0ZWQgc2l6ZSBvZiB0aGUgYm94LCBjb25zaWRlcmluZyB0aGF0IHRoZSBoYW5kbGUncyBjZW50ZXIgbmV2ZXIgdG91Y2hlcyB0aGUgbGVmdCBvciByaWdodCBzaWRlLlxuICAgIC8vIFRoZXJlIGlzIGEgbWFyZ2luIG9mIGhhbGYgdGhlIGhhbmRsZSdzIHdpZHRoIG9uIGJvdGggc2lkZXMuXG4gICAgbGV0IGJveEFkanVzdGVkUGVyY2VudCA9IDEgLSBoYW5kbGVQZXJjZW50O1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwcm9ncmVzcyB0aGF0IHdlJ2xsIHVzZSB0byBzZXQgd2lkdGhzIHRvIHRoZSBuZXcgYWRqdXN0ZWQgYm94IHdpZHRoXG4gICAgbGV0IGFkanVzdGVkUHJvZ3Jlc3MgPSBwcm9ncmVzcyAqIGJveEFkanVzdGVkUGVyY2VudDtcblxuICAgIC8vIFRoZSBiYXIgZG9lcyByZWFjaCB0aGUgbGVmdCBzaWRlLCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMgaW4gdGhlIGJhcidzIHdpZHRoXG4gICAgbGV0IGJhclByb2dyZXNzID0gYWRqdXN0ZWRQcm9ncmVzcyArIChoYW5kbGVQZXJjZW50IC8gMik7XG5cbiAgICBsZXQgcGVyY2VudGFnZSA9IExpYi5yb3VuZChhZGp1c3RlZFByb2dyZXNzICogMTAwLCAyKSArICclJztcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgaGFuZGxlLmVsKCkuc3R5bGUuYm90dG9tID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlLmVsKCkuc3R5bGUubGVmdCA9IHBlcmNlbnRhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhclByb2dyZXNzO1xuICB9XG5cbiAgY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpe1xuICAgIGxldCBlbCA9IHRoaXMuZWxfO1xuICAgIGxldCBib3ggPSBMaWIuZmluZFBvc2l0aW9uKGVsKTtcbiAgICBsZXQgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICAgIGxldCBib3hIID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGxldCBoYW5kbGUgPSB0aGlzLmhhbmRsZTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMoKVsndmVydGljYWwnXSkge1xuICAgICAgbGV0IGJveFkgPSBib3gudG9wO1xuXG4gICAgICBsZXQgcGFnZVk7XG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcGFnZVkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgdmFyIGhhbmRsZUggPSBoYW5kbGUuZWwoKS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIEFkanVzdGVkIFggYW5kIFdpZHRoLCBzbyBoYW5kbGUgZG9lc24ndCBnbyBvdXRzaWRlIHRoZSBiYXJcbiAgICAgICAgYm94WSA9IGJveFkgKyAoaGFuZGxlSCAvIDIpO1xuICAgICAgICBib3hIID0gYm94SCAtIGhhbmRsZUg7XG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmNlbnQgdGhhdCB0aGUgY2xpY2sgaXMgdGhyb3VnaCB0aGUgYWRqdXN0ZWQgYXJlYVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICgoYm94WSAtIHBhZ2VZKSArIGJveEgpIC8gYm94SCkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBib3hYID0gYm94LmxlZnQ7XG5cbiAgICAgIGxldCBwYWdlWDtcbiAgICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICB2YXIgaGFuZGxlVyA9IGhhbmRsZS5lbCgpLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIEFkanVzdGVkIFggYW5kIFdpZHRoLCBzbyBoYW5kbGUgZG9lc24ndCBnbyBvdXRzaWRlIHRoZSBiYXJcbiAgICAgICAgYm94WCA9IGJveFggKyAoaGFuZGxlVyAvIDIpO1xuICAgICAgICBib3hXID0gYm94VyAtIGhhbmRsZVc7XG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmNlbnQgdGhhdCB0aGUgY2xpY2sgaXMgdGhyb3VnaCB0aGUgYWRqdXN0ZWQgYXJlYVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChwYWdlWCAtIGJveFgpIC8gYm94VykpO1xuICAgIH1cbiAgfVxuXG4gIG9uRm9jdXMoKSB7XG4gICAgdGhpcy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLm9uS2V5UHJlc3MpO1xuICB9XG5cbiAgb25LZXlQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC53aGljaCA9PSAzNyB8fCBldmVudC53aGljaCA9PSA0MCkgeyAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09IDM4IHx8IGV2ZW50LndoaWNoID09IDM5KSB7IC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG4gICAgfVxuICB9XG5cbiAgb25CbHVyKCkge1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMub25LZXlQcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuZXIgZm9yIGNsaWNrIGV2ZW50cyBvbiBzbGlkZXIsIHVzZWQgdG8gcHJldmVudCBjbGlja3NcbiAgICogICBmcm9tIGJ1YmJsaW5nIHVwIHRvIHBhcmVudCBlbGVtZW50cyBsaWtlIGJ1dHRvbiBtZW51cy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2xpZGVyJywgU2xpZGVyKTtcbmV4cG9ydCBkZWZhdWx0IFNsaWRlcjtcbiIsImZ1bmN0aW9uIEZsYXNoUnRtcERlY29yYXRvcihGbGFzaCkge1xuICBGbGFzaC5zdHJlYW1pbmdGb3JtYXRzID0ge1xuICAgICdydG1wL21wNCc6ICdNUDQnLFxuICAgICdydG1wL2Zsdic6ICdGTFYnXG4gIH07XG5cbiAgRmxhc2guc3RyZWFtRnJvbVBhcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gKyAnJicgKyBzdHJlYW07XG4gIH07XG5cbiAgRmxhc2guc3RyZWFtVG9QYXJ0cyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIGxldCBwYXJ0cyA9IHtcbiAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgc3RyZWFtOiAnJ1xuICAgIH07XG5cbiAgICBpZiAoIXNyYykgcmV0dXJuIHBhcnRzO1xuXG4gICAgLy8gTG9vayBmb3IgdGhlIG5vcm1hbCBVUkwgc2VwYXJhdG9yIHdlIGV4cGVjdCwgJyYnLlxuICAgIC8vIElmIGZvdW5kLCB3ZSBzcGxpdCB0aGUgVVJMIGludG8gdHdvIHBpZWNlcyBhcm91bmQgdGhlXG4gICAgLy8gZmlyc3QgJyYnLlxuICAgIGxldCBjb25uRW5kID0gc3JjLmluZGV4T2YoJyYnKTtcbiAgICBsZXQgc3RyZWFtQmVnaW47XG4gICAgaWYgKGNvbm5FbmQgIT09IC0xKSB7XG4gICAgICBzdHJlYW1CZWdpbiA9IGNvbm5FbmQgKyAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm90IGEgJyYnLCB3ZSB1c2UgdGhlIGxhc3QgJy8nIGFzIHRoZSBkZWxpbWl0ZXIuXG4gICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGFzdEluZGV4T2YoJy8nKSArIDE7XG4gICAgICBpZiAoY29ubkVuZCA9PT0gMCkge1xuICAgICAgICAvLyByZWFsbHksIHRoZXJlJ3Mgbm90IGEgJy8nP1xuICAgICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0cy5jb25uZWN0aW9uID0gc3JjLnN1YnN0cmluZygwLCBjb25uRW5kKTtcbiAgICBwYXJ0cy5zdHJlYW0gPSBzcmMuc3Vic3RyaW5nKHN0cmVhbUJlZ2luLCBzcmMubGVuZ3RoKTtcblxuICAgIHJldHVybiBwYXJ0cztcbiAgfTtcblxuICBGbGFzaC5pc1N0cmVhbWluZ1R5cGUgPSBmdW5jdGlvbihzcmNUeXBlKSB7XG4gICAgcmV0dXJuIHNyY1R5cGUgaW4gRmxhc2guc3RyZWFtaW5nRm9ybWF0cztcbiAgfTtcblxuICAvLyBSVE1QIGhhcyBmb3VyIHZhcmlhdGlvbnMsIGFueSBzdHJpbmcgc3RhcnRpbmdcbiAgLy8gd2l0aCBvbmUgb2YgdGhlc2UgcHJvdG9jb2xzIHNob3VsZCBiZSB2YWxpZFxuICBGbGFzaC5SVE1QX1JFID0gL15ydG1wW3NldF0/OlxcL1xcLy9pO1xuXG4gIEZsYXNoLmlzU3RyZWFtaW5nU3JjID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgcmV0dXJuIEZsYXNoLlJUTVBfUkUudGVzdChzcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNvdXJjZSBoYW5kbGVyIGZvciBSVE1QIHVybHNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyID0ge307XG5cbiAgLyoqXG4gICAqIENoZWNrIEZsYXNoIGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIGlmIChGbGFzaC5pc1N0cmVhbWluZ1R5cGUoc291cmNlLnR5cGUpIHx8IEZsYXNoLmlzU3RyZWFtaW5nU3JjKHNvdXJjZS5zcmMpKSB7XG4gICAgICByZXR1cm4gJ21heWJlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgZmxhc2ggb2JqZWN0XG4gICAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAgICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtGbGFzaH0gdGVjaCAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgRmxhc2ggdGVjaFxuICAgKi9cbiAgRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgICBsZXQgc3JjUGFydHMgPSBGbGFzaC5zdHJlYW1Ub1BhcnRzKHNvdXJjZS5zcmMpO1xuXG4gICAgdGVjaFsnc2V0UnRtcENvbm5lY3Rpb24nXShzcmNQYXJ0cy5jb25uZWN0aW9uKTtcbiAgICB0ZWNoWydzZXRSdG1wU3RyZWFtJ10oc3JjUGFydHMuc3RyZWFtKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG4gIEZsYXNoLnJlZ2lzdGVyU291cmNlSGFuZGxlcihGbGFzaC5ydG1wU291cmNlSGFuZGxlcik7XG5cbiAgcmV0dXJuIEZsYXNoO1xufVxuXG5leHBvcnQgZGVmYXVsdCBGbGFzaFJ0bXBEZWNvcmF0b3I7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmlkZW9KUy1TV0YgLSBDdXN0b20gRmxhc2ggUGxheWVyIHdpdGggSFRNTDUtaXNoIEFQSVxuICogaHR0cHM6Ly9naXRodWIuY29tL3plbmNvZGVyL3ZpZGVvLWpzLXN3ZlxuICogTm90IHVzaW5nIHNldHVwVHJpZ2dlcnMuIFVzaW5nIGdsb2JhbCBvbkV2ZW50IGZ1bmMgdG8gZGlzdHJpYnV0ZSBldmVudHNcbiAqL1xuXG5pbXBvcnQgVGVjaCBmcm9tICcuL3RlY2gnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgRmxhc2hSdG1wRGVjb3JhdG9yIGZyb20gJy4vZmxhc2gtcnRtcCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xubGV0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbi8qKlxuICogRmxhc2ggTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIGZhbGxiYWNrIFNXRiBBUElcbiAqXG4gKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEZsYXNoIGV4dGVuZHMgVGVjaCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgICBsZXQgeyBzb3VyY2UsIHBhcmVudEVsIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgdG8gYmUgcmVwbGFjZWQgYnkgc3dmIG9iamVjdFxuICAgIGxldCBwbGFjZUhvbGRlciA9IHRoaXMuZWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7IGlkOiBwbGF5ZXIuaWQoKSArICdfdGVtcF9mbGFzaCcgfSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBJRCBmb3Igc3dmIG9iamVjdFxuICAgIGxldCBvYmpJZCA9IHBsYXllci5pZCgpKydfZmxhc2hfYXBpJztcblxuICAgIC8vIFN0b3JlIHBsYXllciBvcHRpb25zIGluIGxvY2FsIHZhciBmb3Igb3B0aW1pemF0aW9uXG4gICAgLy8gVE9ETzogc3dpdGNoIHRvIHVzaW5nIHBsYXllciBtZXRob2RzIGluc3RlYWQgb2Ygb3B0aW9uc1xuICAgIC8vIGUuZy4gcGxheWVyLmF1dG9wbGF5KCk7XG4gICAgbGV0IHBsYXllck9wdGlvbnMgPSBwbGF5ZXIub3B0aW9uc187XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IGZsYXNodmFycyB3aXRoIG9uZXMgcGFzc2VkIGluIHRvIGluaXRcbiAgICBsZXQgZmxhc2hWYXJzID0gTGliLm9iai5tZXJnZSh7XG5cbiAgICAgIC8vIFNXRiBDYWxsYmFjayBGdW5jdGlvbnNcbiAgICAgICdyZWFkeUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25SZWFkeScsXG4gICAgICAnZXZlbnRQcm94eUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25FdmVudCcsXG4gICAgICAnZXJyb3JFdmVudFByb3h5RnVuY3Rpb24nOiAndmlkZW9qcy5GbGFzaC5vbkVycm9yJyxcblxuICAgICAgLy8gUGxheWVyIFNldHRpbmdzXG4gICAgICAnYXV0b3BsYXknOiBwbGF5ZXJPcHRpb25zLmF1dG9wbGF5LFxuICAgICAgJ3ByZWxvYWQnOiBwbGF5ZXJPcHRpb25zLnByZWxvYWQsXG4gICAgICAnbG9vcCc6IHBsYXllck9wdGlvbnMubG9vcCxcbiAgICAgICdtdXRlZCc6IHBsYXllck9wdGlvbnMubXV0ZWRcblxuICAgIH0sIG9wdGlvbnNbJ2ZsYXNoVmFycyddKTtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgcGFyYW1lcyB3aXRoIG9uZXMgcGFzc2VkIGluXG4gICAgbGV0IHBhcmFtcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgICAgJ3dtb2RlJzogJ29wYXF1ZScsIC8vIE9wYXF1ZSBpcyBuZWVkZWQgdG8gb3ZlcmxheSBjb250cm9scywgYnV0IGNhbiBhZmZlY3QgcGxheWJhY2sgcGVyZm9ybWFuY2VcbiAgICAgICdiZ2NvbG9yJzogJyMwMDAwMDAnIC8vIFVzaW5nIGJnY29sb3IgcHJldmVudHMgYSB3aGl0ZSBmbGFzaCB3aGVuIHRoZSBvYmplY3QgaXMgbG9hZGluZ1xuICAgIH0sIG9wdGlvbnNbJ3BhcmFtcyddKTtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgYXR0cmlidXRlcyB3aXRoIG9uZXMgcGFzc2VkIGluXG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBMaWIub2JqLm1lcmdlKHtcbiAgICAgICdpZCc6IG9iaklkLFxuICAgICAgJ25hbWUnOiBvYmpJZCwgLy8gQm90aCBJRCBhbmQgTmFtZSBuZWVkZWQgb3Igc3dmIHRvIGlkZW50aWZ5IGl0c2VsZlxuICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgIH0sIG9wdGlvbnNbJ2F0dHJpYnV0ZXMnXSk7XG5cbiAgICAvLyBJZiBzb3VyY2Ugd2FzIHN1cHBsaWVkIHBhc3MgYXMgYSBmbGFzaCB2YXIuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHBsYWNlaG9sZGVyIHRvIHBsYXllciBkaXZcbiAgICBMaWIuaW5zZXJ0Rmlyc3QocGxhY2VIb2xkZXIsIHBhcmVudEVsKTtcblxuICAgIC8vIEhhdmluZyBpc3N1ZXMgd2l0aCBGbGFzaCByZWxvYWRpbmcgb24gY2VydGFpbiBwYWdlIGFjdGlvbnMgKGhpZGUvcmVzaXplL2Z1bGxzY3JlZW4pIGluIGNlcnRhaW4gYnJvd3NlcnNcbiAgICAvLyBUaGlzIGFsbG93cyByZXNldHRpbmcgdGhlIHBsYXloZWFkIHdoZW4gd2UgY2F0Y2ggdGhlIHJlbG9hZFxuICAgIGlmIChvcHRpb25zWydzdGFydFRpbWUnXSkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIHRoaXNbJ2N1cnJlbnRUaW1lJ10ob3B0aW9uc1snc3RhcnRUaW1lJ10pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZmlyZWZveCBkb2Vzbid0IGJ1YmJsZSBtb3VzZW1vdmUgZXZlbnRzIHRvIHBhcmVudC4gdmlkZW9qcy92aWRlby1qcy1zd2YjMzdcbiAgICAvLyBidWd6aWxsYSBidWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgzNjc4NlxuICAgIGlmIChMaWIuSVNfRklSRUZPWCkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHNpbmNlIGl0J3MgYSBjdXN0b20gZXZlbnQsIGRvbid0IGJ1YmJsZSBoaWdoZXIgdGhhbiB0aGUgcGxheWVyXG4gICAgICAgICAgdGhpcy5wbGF5ZXIoKS50cmlnZ2VyKHsgJ3R5cGUnOidtb3VzZW1vdmUnLCAnYnViYmxlcyc6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIG5hdGl2ZSBjbGljayBldmVudHMgb24gdGhlIFNXRiBhcmVuJ3QgdHJpZ2dlcmVkIG9uIElFMTEsIFdpbjguMVJUXG4gICAgLy8gdXNlIHN0YWdlY2xpY2sgZXZlbnRzIHRyaWdnZXJlZCBmcm9tIGluc2lkZSB0aGUgU1dGIGluc3RlYWRcbiAgICBwbGF5ZXIub24oJ3N0YWdlY2xpY2snLCBwbGF5ZXIucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHRoaXMuZWxfID0gRmxhc2guZW1iZWQob3B0aW9uc1snc3dmJ10sIHBsYWNlSG9sZGVyLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyk7XG4gIH1cblxuICBwbGF5KCkge1xuICAgIHRoaXMuZWxfLnZqc19wbGF5KCk7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmVsXy52anNfcGF1c2UoKTtcbiAgfVxuXG4gIHNyYyhzcmMpIHtcbiAgICBpZiAoc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzWydjdXJyZW50U3JjJ10oKTtcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIG5vdCBgc2V0U3JjYCB3aWxsIGJlIGRlcHJlY2F0ZWRcbiAgICByZXR1cm4gdGhpcy5zZXRTcmMoc3JjKTtcbiAgfVxuXG4gIHNldFNyYyhzcmMpIHtcbiAgICAvLyBNYWtlIHN1cmUgc291cmNlIFVSTCBpcyBhYnNvbHV0ZS5cbiAgICBzcmMgPSBMaWIuZ2V0QWJzb2x1dGVVUkwoc3JjKTtcbiAgICB0aGlzLmVsXy52anNfc3JjKHNyYyk7XG5cbiAgICAvLyBDdXJyZW50bHkgdGhlIFNXRiBkb2Vzbid0IGF1dG9wbGF5IGlmIHlvdSBsb2FkIGEgc291cmNlIGxhdGVyLlxuICAgIC8vIGUuZy4gTG9hZCBwbGF5ZXIgdy8gbm8gc291cmNlLCB3YWl0IDJzLCBzZXQgc3JjLlxuICAgIGlmICh0aGlzLnBsYXllcl8uYXV0b3BsYXkoKSkge1xuICAgICAgdmFyIHRlY2ggPSB0aGlzO1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHRlY2gucGxheSgpOyB9LCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgdGhpcy5sYXN0U2Vla1RhcmdldF8gPSB0aW1lO1xuICAgIHRoaXMuZWxfLnZqc19zZXRQcm9wZXJ0eSgnY3VycmVudFRpbWUnLCB0aW1lKTtcbiAgICBzdXBlci5zZXRDdXJyZW50VGltZSgpO1xuICB9XG5cbiAgY3VycmVudFRpbWUodGltZSkge1xuICAgIC8vIHdoZW4gc2Vla2luZyBtYWtlIHRoZSByZXBvcnRlZCB0aW1lIGtlZXAgdXAgd2l0aCB0aGUgcmVxdWVzdGVkIHRpbWVcbiAgICAvLyBieSByZWFkaW5nIHRoZSB0aW1lIHdlJ3JlIHNlZWtpbmcgdG9cbiAgICBpZiAodGhpcy5zZWVraW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTZWVrVGFyZ2V0XyB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50VGltZScpO1xuICB9XG5cbiAgY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50U3JjJyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmVsXy52anNfbG9hZCgpO1xuICB9XG5cbiAgcG9zdGVyKCkge1xuICAgIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgncG9zdGVyJyk7XG4gIH1cblxuICAvLyBwb3N0ZXIgaW1hZ2VzIGFyZSBub3QgaGFuZGxlZCBieSB0aGUgRmxhc2ggdGVjaCBzbyBtYWtlIHRoaXMgYSBuby1vcFxuICBzZXRQb3N0ZXIoKSB7fVxuXG4gIGJ1ZmZlcmVkKCkge1xuICAgIHJldHVybiBMaWIuY3JlYXRlVGltZVJhbmdlKDAsIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgnYnVmZmVyZWQnKSk7XG4gIH1cblxuICBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBGbGFzaCBkb2VzIG5vdCBhbGxvdyBmdWxsc2NyZWVuIHRocm91Z2ggamF2YXNjcmlwdFxuICB9XG5cbiAgZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cblxuLy8gQ3JlYXRlIHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIGF0dHJpYnV0ZXNcbmNvbnN0IF9hcGkgPSBGbGFzaC5wcm90b3R5cGU7XG5jb25zdCBfcmVhZFdyaXRlID0gJ3J0bXBDb25uZWN0aW9uLHJ0bXBTdHJlYW0scHJlbG9hZCxkZWZhdWx0UGxheWJhY2tSYXRlLHBsYXliYWNrUmF0ZSxhdXRvcGxheSxsb29wLG1lZGlhR3JvdXAsY29udHJvbGxlcixjb250cm9scyx2b2x1bWUsbXV0ZWQsZGVmYXVsdE11dGVkJy5zcGxpdCgnLCcpO1xuY29uc3QgX3JlYWRPbmx5ID0gJ2Vycm9yLG5ldHdvcmtTdGF0ZSxyZWFkeVN0YXRlLHNlZWtpbmcsaW5pdGlhbFRpbWUsZHVyYXRpb24sc3RhcnRPZmZzZXRUaW1lLHBhdXNlZCxwbGF5ZWQsc2Vla2FibGUsZW5kZWQsdmlkZW9UcmFja3MsYXVkaW9UcmFja3MsdmlkZW9XaWR0aCx2aWRlb0hlaWdodCcuc3BsaXQoJywnKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVNldHRlcihhdHRyKXtcbiAgdmFyIGF0dHJVcHBlciA9IGF0dHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBhdHRyLnNsaWNlKDEpO1xuICBfYXBpWydzZXQnK2F0dHJVcHBlcl0gPSBmdW5jdGlvbih2YWwpeyByZXR1cm4gdGhpcy5lbF8udmpzX3NldFByb3BlcnR5KGF0dHIsIHZhbCk7IH07XG59XG5mdW5jdGlvbiBfY3JlYXRlR2V0dGVyKGF0dHIpIHtcbiAgX2FwaVthdHRyXSA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoYXR0cik7IH07XG59XG5cbi8vIENyZWF0ZSBnZXR0ZXIgYW5kIHNldHRlcnMgZm9yIGFsbCByZWFkL3dyaXRlIGF0dHJpYnV0ZXNcbmZvciAobGV0IGkgPSAwOyBpIDwgX3JlYWRXcml0ZS5sZW5ndGg7IGkrKykge1xuICBfY3JlYXRlR2V0dGVyKF9yZWFkV3JpdGVbaV0pO1xuICBfY3JlYXRlU2V0dGVyKF9yZWFkV3JpdGVbaV0pO1xufVxuXG4vLyBDcmVhdGUgZ2V0dGVycyBmb3IgcmVhZC1vbmx5IGF0dHJpYnV0ZXNcbmZvciAobGV0IGkgPSAwOyBpIDwgX3JlYWRPbmx5Lmxlbmd0aDsgaSsrKSB7XG4gIF9jcmVhdGVHZXR0ZXIoX3JlYWRPbmx5W2ldKTtcbn1cblxuLyogRmxhc2ggU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbkZsYXNoLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIEZsYXNoLnZlcnNpb24oKVswXSA+PSAxMDtcbiAgLy8gcmV0dXJuIHN3Zm9iamVjdC5oYXNGbGFzaFBsYXllclZlcnNpb24oJzEwJyk7XG59O1xuXG4vLyBBZGQgU291cmNlIEhhbmRsZXIgcGF0dGVybiBmdW5jdGlvbnMgdG8gdGhpcyB0ZWNoXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyhGbGFzaCk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbmF0aXZlIHNvdXJjZSBoYW5kbGVyLlxuICogVGhpcyBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIHZpZGVvIGVsZW1lbnQuIE5vdGhpbmcgZmFuY3kuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtGbGFzaH0gdGVjaCAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBDaGVjayBGbGFzaCBjYW4gaGFuZGxlIHRoZSBzb3VyY2UgbmF0aXZlbHlcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICBUaGUgc291cmNlIG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuSGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlKXtcbiAgdmFyIHR5cGU7XG5cbiAgZnVuY3Rpb24gZ3Vlc3NNaW1lVHlwZShzcmMpIHtcbiAgICB2YXIgZXh0ID0gTGliLmdldEZpbGVFeHRlbnNpb24oc3JjKTtcbiAgICBpZiAoZXh0KSB7XG4gICAgICByZXR1cm4gYHZpZGVvLyR7ZXh0fWA7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghc291cmNlLnR5cGUpIHtcbiAgICB0eXBlID0gZ3Vlc3NNaW1lVHlwZShzb3VyY2Uuc3JjKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpcCBjb2RlIGluZm9ybWF0aW9uIGZyb20gdGhlIHR5cGUgYmVjYXVzZSB3ZSBkb24ndCBnZXQgdGhhdCBzcGVjaWZpY1xuICAgIHR5cGUgPSBzb3VyY2UudHlwZS5yZXBsYWNlKC87LiovLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGlmICh0eXBlIGluIEZsYXNoLmZvcm1hdHMpIHtcbiAgICByZXR1cm4gJ21heWJlJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBmbGFzaCBvYmplY3RcbiAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAqIHZpZGVvIGRhdGEgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtGbGFzaH0gdGVjaCAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgRmxhc2ggdGVjaFxuICovXG5GbGFzaC5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGVjaCl7XG4gIHRlY2guc2V0U3JjKHNvdXJjZS5zcmMpO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0aGUgc291cmNlIGhhbmRsZXIgd2hlbiBkaXNwb3NpbmcgdGhlIHBsYXllciBvciBzd2l0Y2hpbmcgc291cmNlcy4uXG4gKiAobm8gY2xlYW51cCBpcyBuZWVkZWQgd2hlbiBzdXBwb3J0aW5nIHRoZSBmb3JtYXQgbmF0aXZlbHkpXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7fTtcblxuLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuRmxhc2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKEZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpO1xuXG5GbGFzaC5mb3JtYXRzID0ge1xuICAndmlkZW8vZmx2JzogJ0ZMVicsXG4gICd2aWRlby94LWZsdic6ICdGTFYnLFxuICAndmlkZW8vbXA0JzogJ01QNCcsXG4gICd2aWRlby9tNHYnOiAnTVA0J1xufTtcblxuRmxhc2hbJ29uUmVhZHknXSA9IGZ1bmN0aW9uKGN1cnJTd2Ype1xuICBsZXQgZWwgPSBMaWIuZWwoY3VyclN3Zik7XG5cbiAgLy8gZ2V0IHBsYXllciBmcm9tIHRoZSBwbGF5ZXIgZGl2IHByb3BlcnR5XG4gIGNvbnN0IHBsYXllciA9IGVsICYmIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZVsncGxheWVyJ107XG5cbiAgLy8gaWYgdGhlcmUgaXMgbm8gZWwgb3IgcGxheWVyIHRoZW4gdGhlIHRlY2ggaGFzIGJlZW4gZGlzcG9zZWRcbiAgLy8gYW5kIHRoZSB0ZWNoIGVsZW1lbnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyIGRpdlxuICBpZiAocGxheWVyKSB7XG4gICAgLy8gcmVmZXJlbmNlIHBsYXllciBvbiB0ZWNoIGVsZW1lbnRcbiAgICBlbFsncGxheWVyJ10gPSBwbGF5ZXI7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZmxhc2ggb2JqZWN0IGlzIHJlYWxseSByZWFkeVxuICAgIEZsYXNoWydjaGVja1JlYWR5J10ocGxheWVyLnRlY2gpO1xuICB9XG59O1xuXG4vLyBUaGUgU1dGIGlzbid0IGFsd2F5cyByZWFkeSB3aGVuIGl0IHNheXMgaXQgaXMuIFNvbWV0aW1lcyB0aGUgQVBJIGZ1bmN0aW9ucyBzdGlsbCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBvYmplY3QuXG4vLyBJZiBpdCdzIG5vdCByZWFkeSwgd2Ugc2V0IGEgdGltZW91dCB0byBjaGVjayBhZ2FpbiBzaG9ydGx5LlxuRmxhc2hbJ2NoZWNrUmVhZHknXSA9IGZ1bmN0aW9uKHRlY2gpe1xuICAvLyBzdG9wIHdvcnJ5aW5nIGlmIHRoZSB0ZWNoIGhhcyBiZWVuIGRpc3Bvc2VkXG4gIGlmICghdGVjaC5lbCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgQVBJIHByb3BlcnR5IGV4aXN0c1xuICBpZiAodGVjaC5lbCgpLnZqc19nZXRQcm9wZXJ0eSkge1xuICAgIC8vIHRlbGwgdGVjaCBpdCdzIHJlYWR5XG4gICAgdGVjaC50cmlnZ2VyUmVhZHkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3YWl0IGxvbmdlclxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgRmxhc2hbJ2NoZWNrUmVhZHknXSh0ZWNoKTtcbiAgICB9LCA1MCk7XG4gIH1cbn07XG5cbi8vIFRyaWdnZXIgZXZlbnRzIGZyb20gdGhlIHN3ZiBvbiB0aGUgcGxheWVyXG5GbGFzaFsnb25FdmVudCddID0gZnVuY3Rpb24oc3dmSUQsIGV2ZW50TmFtZSl7XG4gIGxldCBwbGF5ZXIgPSBMaWIuZWwoc3dmSUQpWydwbGF5ZXInXTtcbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lKTtcbn07XG5cbi8vIExvZyBlcnJvcnMgZnJvbSB0aGUgc3dmXG5GbGFzaFsnb25FcnJvciddID0gZnVuY3Rpb24oc3dmSUQsIGVycil7XG4gIGNvbnN0IHBsYXllciA9IExpYi5lbChzd2ZJRClbJ3BsYXllciddO1xuICBjb25zdCBtc2cgPSAnRkxBU0g6ICcrZXJyO1xuXG4gIGlmIChlcnIgPT0gJ3NyY25vdGZvdW5kJykge1xuICAgIHBsYXllci5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IG1zZyB9KTtcblxuICAvLyBlcnJvcnMgd2UgaGF2ZW4ndCBjYXRlZ29yaXplZCBpbnRvIHRoZSBtZWRpYSBlcnJvcnNcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIuZXJyb3IobXNnKTtcbiAgfVxufTtcblxuLy8gRmxhc2ggVmVyc2lvbiBDaGVja1xuRmxhc2gudmVyc2lvbiA9IGZ1bmN0aW9uKCl7XG4gIGxldCB2ZXJzaW9uID0gJzAsMCwwJztcblxuICAvLyBJRVxuICB0cnkge1xuICAgIHZlcnNpb24gPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJykucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG5cbiAgLy8gb3RoZXIgYnJvd3NlcnNcbiAgfSBjYXRjaChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pe1xuICAgICAgICB2ZXJzaW9uID0gKG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2ggMi4wJ10gfHwgbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddKS5kZXNjcmlwdGlvbi5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge31cbiAgfVxuICByZXR1cm4gdmVyc2lvbi5zcGxpdCgnLCcpO1xufTtcblxuLy8gRmxhc2ggZW1iZWRkaW5nIG1ldGhvZC4gT25seSB1c2VkIGluIG5vbi1pZnJhbWUgbW9kZVxuRmxhc2guZW1iZWQgPSBmdW5jdGlvbihzd2YsIHBsYWNlSG9sZGVyLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyl7XG4gIGNvbnN0IGNvZGUgPSBGbGFzaC5nZXRFbWJlZENvZGUoc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyk7XG5cbiAgLy8gR2V0IGVsZW1lbnQgYnkgZW1iZWRkaW5nIGNvZGUgYW5kIHJldHJpZXZpbmcgY3JlYXRlZCBlbGVtZW50XG4gIGNvbnN0IG9iaiA9IExpYi5jcmVhdGVFbCgnZGl2JywgeyBpbm5lckhUTUw6IGNvZGUgfSkuY2hpbGROb2Rlc1swXTtcblxuICBjb25zdCBwYXIgPSBwbGFjZUhvbGRlci5wYXJlbnROb2RlO1xuXG4gIHBsYWNlSG9sZGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG9iaiwgcGxhY2VIb2xkZXIpO1xuICByZXR1cm4gb2JqO1xufTtcblxuRmxhc2guZ2V0RW1iZWRDb2RlID0gZnVuY3Rpb24oc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyl7XG4gIGNvbnN0IG9ialRhZyA9ICc8b2JqZWN0IHR5cGU9XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiICc7XG4gIGxldCBmbGFzaFZhcnNTdHJpbmcgPSAnJztcbiAgbGV0IHBhcmFtc1N0cmluZyA9ICcnO1xuICBsZXQgYXR0cnNTdHJpbmcgPSAnJztcblxuICAvLyBDb252ZXJ0IGZsYXNoIHZhcnMgdG8gc3RyaW5nXG4gIGlmIChmbGFzaFZhcnMpIHtcbiAgICBMaWIub2JqLmVhY2goZmxhc2hWYXJzLCBmdW5jdGlvbihrZXksIHZhbCl7XG4gICAgICBmbGFzaFZhcnNTdHJpbmcgKz0gYCR7a2V5fT0ke3ZhbH0mYW1wO2A7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBZGQgc3dmLCBmbGFzaFZhcnMsIGFuZCBvdGhlciBkZWZhdWx0IHBhcmFtc1xuICBwYXJhbXMgPSBMaWIub2JqLm1lcmdlKHtcbiAgICAnbW92aWUnOiBzd2YsXG4gICAgJ2ZsYXNodmFycyc6IGZsYXNoVmFyc1N0cmluZyxcbiAgICAnYWxsb3dTY3JpcHRBY2Nlc3MnOiAnYWx3YXlzJywgLy8gUmVxdWlyZWQgdG8gdGFsayB0byBzd2ZcbiAgICAnYWxsb3dOZXR3b3JraW5nJzogJ2FsbCcgLy8gQWxsIHNob3VsZCBiZSBkZWZhdWx0LCBidXQgaGF2aW5nIHNlY3VyaXR5IGlzc3Vlcy5cbiAgfSwgcGFyYW1zKTtcblxuICAvLyBDcmVhdGUgcGFyYW0gdGFncyBzdHJpbmdcbiAgTGliLm9iai5lYWNoKHBhcmFtcywgZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgIHBhcmFtc1N0cmluZyArPSBgPHBhcmFtIG5hbWU9XCIke2tleX1cIiB2YWx1ZT1cIiR7dmFsfVwiIC8+YDtcbiAgfSk7XG5cbiAgYXR0cmlidXRlcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgIC8vIEFkZCBzd2YgdG8gYXR0cmlidXRlcyAobmVlZCBib3RoIGZvciBJRSBhbmQgT3RoZXJzIHRvIHdvcmspXG4gICAgJ2RhdGEnOiBzd2YsXG5cbiAgICAvLyBEZWZhdWx0IHRvIDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICdoZWlnaHQnOiAnMTAwJSdcblxuICB9LCBhdHRyaWJ1dGVzKTtcblxuICAvLyBDcmVhdGUgQXR0cmlidXRlcyBzdHJpbmdcbiAgTGliLm9iai5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgICBhdHRyc1N0cmluZyArPSBgJHtrZXl9PVwiJHt2YWx9XCIgYDtcbiAgfSk7XG5cbiAgcmV0dXJuIGAke29ialRhZ30ke2F0dHJzU3RyaW5nfT4ke3BhcmFtc1N0cmluZ308L29iamVjdD5gO1xufTtcblxuLy8gUnVuIEZsYXNoIHRocm91Z2ggdGhlIFJUTVAgZGVjb3JhdG9yXG5GbGFzaFJ0bXBEZWNvcmF0b3IoRmxhc2gpO1xuXG5UZWNoLnJlZ2lzdGVyQ29tcG9uZW50KCdGbGFzaCcsIEZsYXNoKTtcbmV4cG9ydCBkZWZhdWx0IEZsYXNoO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEhUTUw1IE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBIVE1MNSBNZWRpYSBBUElcbiAqL1xuXG5pbXBvcnQgVGVjaCBmcm9tICcuL3RlY2guanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgKiBhcyBWanNVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgSHRtbDUgZXh0ZW5kcyBUZWNoIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIHRoaXMuc2V0dXBUcmlnZ2VycygpO1xuXG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9uc1snc291cmNlJ107XG5cbiAgICAvLyBTZXQgdGhlIHNvdXJjZSBpZiBvbmUgaXMgcHJvdmlkZWRcbiAgICAvLyAxKSBDaGVjayBpZiB0aGUgc291cmNlIGlzIG5ldyAoaWYgbm90LCB3ZSB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIHNvIHBsYXliYWNrIGlzbid0IGludGVycnVwdGVkKVxuICAgIC8vIDIpIENoZWNrIHRvIHNlZSBpZiB0aGUgbmV0d29yayBzdGF0ZSBvZiB0aGUgdGFnIHdhcyBmYWlsZWQgYXQgaW5pdCwgYW5kIGlmIHNvLCByZXNldCB0aGUgc291cmNlXG4gICAgLy8gYW55d2F5IHNvIHRoZSBlcnJvciBnZXRzIGZpcmVkLlxuICAgIGlmIChzb3VyY2UgJiYgKHRoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgKHBsYXllci50YWcgJiYgcGxheWVyLnRhZy5pbml0TmV0d29ya1N0YXRlXyA9PT0gMykpKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgbGV0IG5vZGVzID0gdGhpcy5lbF8uY2hpbGROb2RlcztcbiAgICAgIGxldCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIGxldCByZW1vdmVOb2RlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZXNMZW5ndGgtLSkge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW25vZGVzTGVuZ3RoXTtcbiAgICAgICAgbGV0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICAgICAgICAvLyBFbXB0eSB2aWRlbyB0YWcgdHJhY2tzIHNvIHRoZSBidWlsdC1pbiBwbGF5ZXIgZG9lc24ndCB1c2UgdGhlbSBhbHNvLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbm90IGJlIGZhc3QgZW5vdWdoIHRvIHN0b3AgSFRNTDUgYnJvd3NlcnMgZnJvbSByZWFkaW5nIHRoZSB0YWdzXG4gICAgICAgICAgICAvLyBzbyB3ZSdsbCBuZWVkIHRvIHR1cm4gb2ZmIGFueSBkZWZhdWx0IHRyYWNrcyBpZiB3ZSdyZSBtYW51YWxseSBkb2luZ1xuICAgICAgICAgICAgLy8gY2FwdGlvbnMgYW5kIHN1YnRpdGxlcy4gdmlkZW9FbGVtZW50LnRleHRUcmFja3NcbiAgICAgICAgICAgIHJlbW92ZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrXyhub2RlWyd0cmFjayddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaT0wOyBpPHJlbW92ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWxfLnJlbW92ZUNoaWxkKHJlbW92ZU5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpc1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHRoaXMub24oJ2xvYWRzdGFydCcsIExpYi5iaW5kKHRoaXMsIHRoaXMuaGlkZUNhcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgIC8vIE91ciBnb2FsIHNob3VsZCBiZSB0byBnZXQgdGhlIGN1c3RvbSBjb250cm9scyBvbiBtb2JpbGUgc29saWQgZXZlcnl3aGVyZVxuICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhpcyBhbGwgdG9nZXRoZXIuIFJpZ2h0IG5vdyB0aGlzIHdpbGwgYmxvY2sgY3VzdG9tXG4gICAgLy8gY29udHJvbHMgb24gdG91Y2ggZW5hYmxlZCBsYXB0b3BzIGxpa2UgdGhlIENocm9tZSBQaXhlbFxuICAgIGlmIChMaWIuVE9VQ0hfRU5BQkxFRCAmJiBwbGF5ZXIub3B0aW9ucygpWyduYXRpdmVDb250cm9sc0ZvclRvdWNoJ10gPT09IHRydWUpIHtcbiAgICAgIHRoaXMudXNlTmF0aXZlQ29udHJvbHMoKTtcbiAgICB9XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgcGxheWVyLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy50YWcgJiYgdGhpcy5vcHRpb25zX1snYXV0b3BsYXknXSAmJiB0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhZ1sncG9zdGVyJ107IC8vIENocm9tZSBGaXguIEZpeGVkIGluIENocm9tZSB2MTYuXG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgfVxuXG5cbiAgZGlzcG9zZSgpIHtcbiAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMuZWxfKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgcGxheWVyID0gdGhpcy5wbGF5ZXJfO1xuICAgIGxldCBlbCA9IHBsYXllci50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8IHRoaXNbJ21vdmluZ01lZGlhRWxlbWVudEluRE9NJ10gPT09IGZhbHNlKSB7XG5cbiAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0YWcgaXMgc3RpbGwgdGhlcmUsIGNsb25lIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KGVsKTtcbiAgICAgICAgZWwgPSBjbG9uZTtcbiAgICAgICAgcGxheWVyLnRhZyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IExpYi5jcmVhdGVFbCgndmlkZW8nKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIGxldCBhdHRyaWJ1dGVzID0gVmpzVXRpbC5tZXJnZU9wdGlvbnMoe30sIHBsYXllci50YWdBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKCFMaWIuVE9VQ0hfRU5BQkxFRCB8fCBwbGF5ZXIub3B0aW9ucygpWyduYXRpdmVDb250cm9sc0ZvclRvdWNoJ10gIT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5jb250cm9scztcbiAgICAgICAgfVxuXG4gICAgICAgIExpYi5zZXRFbGVtZW50QXR0cmlidXRlcyhlbCxcbiAgICAgICAgICBMaWIub2JqLm1lcmdlKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGlkOiBwbGF5ZXIuaWQoKSArICdfaHRtbDVfYXBpJyxcbiAgICAgICAgICAgIGNsYXNzOiAndmpzLXRlY2gnXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGFzc29jaWF0ZSB0aGUgcGxheWVyIHdpdGggdGhlIG5ldyB0YWdcbiAgICAgIGVsWydwbGF5ZXInXSA9IHBsYXllcjtcblxuICAgICAgaWYgKHBsYXllci5vcHRpb25zXy50cmFja3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXIub3B0aW9uc18udHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBwbGF5ZXIub3B0aW9uc18udHJhY2tzW2ldO1xuICAgICAgICAgIGxldCB0cmFja0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbiAgICAgICAgICB0cmFja0VsLmtpbmQgPSB0cmFjay5raW5kO1xuICAgICAgICAgIHRyYWNrRWwubGFiZWwgPSB0cmFjay5sYWJlbDtcbiAgICAgICAgICB0cmFja0VsLnNyY2xhbmcgPSB0cmFjay5zcmNsYW5nO1xuICAgICAgICAgIHRyYWNrRWwuc3JjID0gdHJhY2suc3JjO1xuICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gdHJhY2spIHtcbiAgICAgICAgICAgIHRyYWNrRWwuc2V0QXR0cmlidXRlKCdkZWZhdWx0JywgJ2RlZmF1bHQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQodHJhY2tFbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgTGliLmluc2VydEZpcnN0KGVsLCBwbGF5ZXIuZWwoKSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIGxldCBzZXR0aW5nc0F0dHJzID0gWydhdXRvcGxheScsJ3ByZWxvYWQnLCdsb29wJywnbXV0ZWQnXTtcbiAgICBmb3IgKGxldCBpID0gc2V0dGluZ3NBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICBsZXQgb3ZlcndyaXRlQXR0cnMgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgcGxheWVyLm9wdGlvbnNfW2F0dHJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvdmVyd3JpdGVBdHRyc1thdHRyXSA9IHBsYXllci5vcHRpb25zX1thdHRyXTtcbiAgICAgIH1cbiAgICAgIExpYi5zZXRFbGVtZW50QXR0cmlidXRlcyhlbCwgb3ZlcndyaXRlQXR0cnMpO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgICAvLyBqZW5uaWlzYXdlc29tZSA9IHRydWU7XG4gIH1cblxuXG4gIGhpZGVDYXB0aW9ucygpIHtcbiAgICBsZXQgdHJhY2tzID0gdGhpcy5lbF8ucXVlcnlTZWxlY3RvckFsbCgndHJhY2snKTtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3Qga2luZHMgPSB7XG4gICAgICAnY2FwdGlvbnMnOiAxLFxuICAgICAgJ3N1YnRpdGxlcyc6IDFcbiAgICB9O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldLnRyYWNrO1xuICAgICAgaWYgKCh0cmFjayAmJiB0cmFja1sna2luZCddIGluIGtpbmRzKSAmJlxuICAgICAgICAgICghdHJhY2tzW2ldWydkZWZhdWx0J10pKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1ha2UgdmlkZW8gZXZlbnRzIHRyaWdnZXIgcGxheWVyIGV2ZW50c1xuICAvLyBNYXkgc2VlbSB2ZXJib3NlIGhlcmUsIGJ1dCBtYWtlcyBvdGhlciBBUElzIHBvc3NpYmxlLlxuICAvLyBUcmlnZ2VycyByZW1vdmVkIHVzaW5nIHRoaXMub2ZmIHdoZW4gZGlzcG9zZWRcbiAgc2V0dXBUcmlnZ2VycygpIHtcbiAgICBmb3IgKGxldCBpID0gSHRtbDUuRXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLm9uKEh0bWw1LkV2ZW50c1tpXSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGV2ZW50SGFuZGxlcihldnQpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbiBlcnJvciBvbiB0aGUgdmlkZW8gZWxlbWVudCwgc2V0IHRoZSBlcnJvciBwcm9wXG4gICAgLy8gb24gdGhlIHBsYXllciBhbmQgbGV0IHRoZSBwbGF5ZXIgaGFuZGxlIHRyaWdnZXJpbmcgdGhlIGV2ZW50LiBPblxuICAgIC8vIHNvbWUgcGxhdGZvcm1zLCBlcnJvciBldmVudHMgZmlyZSB0aGF0IGRvIG5vdCBjYXVzZSB0aGUgZXJyb3JcbiAgICAvLyBwcm9wZXJ0eSBvbiB0aGUgdmlkZW8gZWxlbWVudCB0byBiZSBzZXQuIFNlZSAjMTQ2NSBmb3IgYW4gZXhhbXBsZS5cbiAgICBpZiAoZXZ0LnR5cGUgPT0gJ2Vycm9yJyAmJiB0aGlzLmVycm9yKCkpIHtcbiAgICAgIHRoaXMucGxheWVyKCkuZXJyb3IodGhpcy5lcnJvcigpLmNvZGUpO1xuXG4gICAgLy8gaW4gc29tZSBjYXNlcyB3ZSBwYXNzIHRoZSBldmVudCBkaXJlY3RseSB0byB0aGUgcGxheWVyXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIG1lZGlhIGV2ZW50cyB0byBidWJibGUgdXAuXG4gICAgICBldnQuYnViYmxlcyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLnBsYXllcigpLnRyaWdnZXIoZXZ0KTtcbiAgICB9XG4gIH1cblxuICB1c2VOYXRpdmVDb250cm9scygpIHtcbiAgICBsZXQgdGVjaCA9IHRoaXM7XG4gICAgbGV0IHBsYXllciA9IHRoaXMucGxheWVyKCk7XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyIGNvbnRyb2xzIGFyZSBlbmFibGVkIHR1cm4gb24gdGhlIG5hdGl2ZSBjb250cm9sc1xuICAgIHRlY2guc2V0Q29udHJvbHMocGxheWVyLmNvbnRyb2xzKCkpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBuYXRpdmUgY29udHJvbHMgd2hlbiBwbGF5ZXIgY29udHJvbHMgc3RhdGUgaXMgdXBkYXRlZFxuICAgIGxldCBjb250cm9sc09uID0gZnVuY3Rpb24oKXtcbiAgICAgIHRlY2guc2V0Q29udHJvbHModHJ1ZSk7XG4gICAgfTtcbiAgICBsZXQgY29udHJvbHNPZmYgPSBmdW5jdGlvbigpe1xuICAgICAgdGVjaC5zZXRDb250cm9scyhmYWxzZSk7XG4gICAgfTtcbiAgICBwbGF5ZXIub24oJ2NvbnRyb2xzZW5hYmxlZCcsIGNvbnRyb2xzT24pO1xuICAgIHBsYXllci5vbignY29udHJvbHNkaXNhYmxlZCcsIGNvbnRyb2xzT2ZmKTtcblxuICAgIC8vIENsZWFuIHVwIHdoZW4gbm90IHVzaW5nIG5hdGl2ZSBjb250cm9scyBhbnltb3JlXG4gICAgbGV0IGNsZWFuVXAgPSBmdW5jdGlvbigpe1xuICAgICAgcGxheWVyLm9mZignY29udHJvbHNlbmFibGVkJywgY29udHJvbHNPbik7XG4gICAgICBwbGF5ZXIub2ZmKCdjb250cm9sc2Rpc2FibGVkJywgY29udHJvbHNPZmYpO1xuICAgIH07XG4gICAgdGVjaC5vbignZGlzcG9zZScsIGNsZWFuVXApO1xuICAgIHBsYXllci5vbigndXNpbmdjdXN0b21jb250cm9scycsIGNsZWFuVXApO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgcGxheWVyIHRvIHVzaW5nIG5hdGl2ZSBjb250cm9sc1xuICAgIHBsYXllci51c2luZ05hdGl2ZUNvbnRyb2xzKHRydWUpO1xuICB9XG5cblxuICBwbGF5KCkgeyB0aGlzLmVsXy5wbGF5KCk7IH1cbiAgcGF1c2UoKSB7IHRoaXMuZWxfLnBhdXNlKCk7IH1cbiAgcGF1c2VkKCkgeyByZXR1cm4gdGhpcy5lbF8ucGF1c2VkOyB9XG5cbiAgY3VycmVudFRpbWUoKSB7IHJldHVybiB0aGlzLmVsXy5jdXJyZW50VGltZTsgfVxuICBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZWxfLmN1cnJlbnRUaW1lID0gc2Vjb25kcztcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIExpYi5sb2coZSwgJ1ZpZGVvIGlzIG5vdCByZWFkeS4gKFZpZGVvLmpzKScpO1xuICAgICAgLy8gdGhpcy53YXJuaW5nKFZpZGVvSlMud2FybmluZ3MudmlkZW9Ob3RSZWFkeSk7XG4gICAgfVxuICB9XG5cbiAgZHVyYXRpb24oKSB7IHJldHVybiB0aGlzLmVsXy5kdXJhdGlvbiB8fCAwOyB9XG5cbiAgYnVmZmVyZWQoKSB7IHJldHVybiB0aGlzLmVsXy5idWZmZXJlZDsgfVxuXG4gIHZvbHVtZSgpIHsgcmV0dXJuIHRoaXMuZWxfLnZvbHVtZTsgfVxuICBzZXRWb2x1bWUocGVyY2VudEFzRGVjaW1hbCkgeyB0aGlzLmVsXy52b2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsOyB9XG5cbiAgbXV0ZWQoKSB7IHJldHVybiB0aGlzLmVsXy5tdXRlZDsgfVxuICBzZXRNdXRlZChtdXRlZCkgeyB0aGlzLmVsXy5tdXRlZCA9IG11dGVkOyB9XG5cbiAgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDsgfVxuICBoZWlnaHQoKSB7ICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0SGVpZ2h0OyB9XG5cbiAgc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbF8ud2Via2l0RW50ZXJGdWxsU2NyZWVuID09ICdmdW5jdGlvbicpIHtcblxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxuICAgICAgaWYgKC9BbmRyb2lkLy50ZXN0KExpYi5VU0VSX0FHRU5UKSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KExpYi5VU0VSX0FHRU5UKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHZhciB2aWRlbyA9IHRoaXMuZWxfO1xuXG4gICAgaWYgKCd3ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbicgaW4gdmlkZW8pIHtcbiAgICAgIHRoaXMub25lKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbih0cnVlKTtcblxuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgIHRoaXMucGxheWVyXy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucGxheWVyXy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmlkZW8ucGF1c2VkICYmIHZpZGVvLm5ldHdvcmtTdGF0ZSA8PSB2aWRlby5IQVZFX01FVEFEQVRBKSB7XG4gICAgICAvLyBhdHRlbXB0IHRvIHByaW1lIHRoZSB2aWRlbyBlbGVtZW50IGZvciBwcm9ncmFtbWF0aWMgYWNjZXNzXG4gICAgICAvLyB0aGlzIGlzbid0IG5lY2Vzc2FyeSBvbiB0aGUgZGVza3RvcCBidXQgc2hvdWxkbid0IGh1cnRcbiAgICAgIHRoaXMuZWxfLnBsYXkoKTtcblxuICAgICAgLy8gcGxheWluZyBhbmQgcGF1c2luZyBzeW5jaHJvbm91c2x5IGR1cmluZyB0aGUgdHJhbnNpdGlvbiB0byBmdWxsc2NyZWVuXG4gICAgICAvLyBjYW4gZ2V0IGlPUyB+Ni4xIGRldmljZXMgaW50byBhIHBsYXkvcGF1c2UgbG9vcFxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgIH1cbiAgfVxuXG4gIGV4aXRGdWxsU2NyZWVuKCkge1xuICAgIHRoaXMuZWxfLndlYmtpdEV4aXRGdWxsU2NyZWVuKCk7XG4gIH1cblxuICBzcmMoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbF8uc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgICB0aGlzLnNldFNyYyhzcmMpO1xuICAgIH1cbiAgfVxuXG4gIHNldFNyYyhzcmMpIHsgdGhpcy5lbF8uc3JjID0gc3JjOyB9XG5cbiAgbG9hZCgpeyB0aGlzLmVsXy5sb2FkKCk7IH1cblxuICBjdXJyZW50U3JjKCkgeyByZXR1cm4gdGhpcy5lbF8uY3VycmVudFNyYzsgfVxuXG4gIHBvc3RlcigpIHsgcmV0dXJuIHRoaXMuZWxfLnBvc3RlcjsgfVxuICBzZXRQb3N0ZXIodmFsKSB7IHRoaXMuZWxfLnBvc3RlciA9IHZhbDsgfVxuXG4gIHByZWxvYWQoKSB7IHJldHVybiB0aGlzLmVsXy5wcmVsb2FkOyB9XG4gIHNldFByZWxvYWQodmFsKSB7IHRoaXMuZWxfLnByZWxvYWQgPSB2YWw7IH1cblxuICBhdXRvcGxheSgpIHsgcmV0dXJuIHRoaXMuZWxfLmF1dG9wbGF5OyB9XG4gIHNldEF1dG9wbGF5KHZhbCkgeyB0aGlzLmVsXy5hdXRvcGxheSA9IHZhbDsgfVxuXG4gIGNvbnRyb2xzKCkgeyByZXR1cm4gdGhpcy5lbF8uY29udHJvbHM7IH1cbiAgc2V0Q29udHJvbHModmFsKSB7IHRoaXMuZWxfLmNvbnRyb2xzID0gISF2YWw7IH1cblxuICBsb29wKCkgeyByZXR1cm4gdGhpcy5lbF8ubG9vcDsgfVxuICBzZXRMb29wKHZhbCkgeyB0aGlzLmVsXy5sb29wID0gdmFsOyB9XG5cbiAgZXJyb3IoKSB7IHJldHVybiB0aGlzLmVsXy5lcnJvcjsgfVxuICBzZWVraW5nKCkgeyByZXR1cm4gdGhpcy5lbF8uc2Vla2luZzsgfVxuICBlbmRlZCgpIHsgcmV0dXJuIHRoaXMuZWxfLmVuZGVkOyB9XG4gIGRlZmF1bHRNdXRlZCgpIHsgcmV0dXJuIHRoaXMuZWxfLmRlZmF1bHRNdXRlZDsgfVxuXG4gIHBsYXliYWNrUmF0ZSgpIHsgcmV0dXJuIHRoaXMuZWxfLnBsYXliYWNrUmF0ZTsgfVxuICBzZXRQbGF5YmFja1JhdGUodmFsKSB7IHRoaXMuZWxfLnBsYXliYWNrUmF0ZSA9IHZhbDsgfVxuXG4gIG5ldHdvcmtTdGF0ZSgpIHsgcmV0dXJuIHRoaXMuZWxfLm5ldHdvcmtTdGF0ZTsgfVxuICByZWFkeVN0YXRlKCkgeyByZXR1cm4gdGhpcy5lbF8ucmVhZHlTdGF0ZTsgfVxuXG4gIHRleHRUcmFja3MoKSB7XG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnRleHRUcmFja3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbF8udGV4dFRyYWNrcztcbiAgfVxuICBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zPXt9KSB7XG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gICAgaWYgKG9wdGlvbnNbJ2tpbmQnXSkge1xuICAgICAgdHJhY2tbJ2tpbmQnXSA9IG9wdGlvbnNbJ2tpbmQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2xhYmVsJ10pIHtcbiAgICAgIHRyYWNrWydsYWJlbCddID0gb3B0aW9uc1snbGFiZWwnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2xhbmd1YWdlJ10gfHwgb3B0aW9uc1snc3JjbGFuZyddKSB7XG4gICAgICB0cmFja1snc3JjbGFuZyddID0gb3B0aW9uc1snbGFuZ3VhZ2UnXSB8fCBvcHRpb25zWydzcmNsYW5nJ107XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcbiAgICAgIHRyYWNrWydkZWZhdWx0J10gPSBvcHRpb25zWydkZWZhdWx0J107XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydpZCddKSB7XG4gICAgICB0cmFja1snaWQnXSA9IG9wdGlvbnNbJ2lkJ107XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydzcmMnXSkge1xuICAgICAgdHJhY2tbJ3NyYyddID0gb3B0aW9uc1snc3JjJ107XG4gICAgfVxuXG4gICAgdGhpcy5lbCgpLmFwcGVuZENoaWxkKHRyYWNrKTtcblxuICAgIGlmICh0cmFjay50cmFja1sna2luZCddID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICB0cmFja1sndHJhY2snXVsnbW9kZSddID0gJ2hpZGRlbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrWyd0cmFjayddWydtb2RlJ10gPSAnZGlzYWJsZWQnO1xuICAgIH1cblxuICAgIHRyYWNrWydvbmxvYWQnXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR0ID0gdHJhY2tbJ3RyYWNrJ107XG4gICAgICBpZiAodHJhY2sucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIGlmICh0dFsna2luZCddID09PSAnbWV0YWRhdGEnICYmIHR0Wydtb2RlJ10gIT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgdHRbJ21vZGUnXSA9ICdoaWRkZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR0WydraW5kJ10gIT09ICdtZXRhZGF0YScgJiYgdHRbJ21vZGUnXSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgIHR0Wydtb2RlJ10gPSAnZGlzYWJsZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrWydvbmxvYWQnXSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrXyh0cmFjay50cmFjayk7XG5cbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tzLCBpO1xuXG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2tfKHRyYWNrKTtcblxuICAgIHRyYWNrcyA9IHRoaXMuZWwoKVsncXVlcnlTZWxlY3RvckFsbCddKCd0cmFjaycpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrc1tpXSA9PT0gdHJhY2sgfHwgdHJhY2tzW2ldWyd0cmFjayddID09PSB0cmFjaykge1xuICAgICAgICB0cmFja3NbaV1bJ3BhcmVudE5vZGUnXVsncmVtb3ZlQ2hpbGQnXSh0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5cbi8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogQ2hlY2sgaWYgSFRNTDUgdmlkZW8gaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkh0bWw1LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKXtcbiAgLy8gSUU5IHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXG4gIHRyeSB7XG4gICAgTGliLlRFU1RfVklEWyd2b2x1bWUnXSA9IDAuNTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIUxpYi5URVNUX1ZJRC5jYW5QbGF5VHlwZTtcbn07XG5cbi8vIEFkZCBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuIGZ1bmN0aW9ucyB0byB0aGlzIHRlY2hcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBuYXRpdmUgc291cmNlIGhhbmRsZXIuXG4gKiBUaGlzIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudC4gTm90aGluZyBmYW5jeS5cbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0h0bWw1fSB0ZWNoICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2hcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2aWRlbyBlbGVtZW50IGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICB2YXIgbWF0Y2gsIGV4dDtcblxuICBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKXtcbiAgICAvLyBJRTkgb24gV2luZG93cyA3IHdpdGhvdXQgTWVkaWFQbGF5ZXIgdGhyb3dzIGFuIGVycm9yIGhlcmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBMaWIuVEVTVF9WSUQuY2FuUGxheVR5cGUodHlwZSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSB0eXBlIHdhcyBwcm92aWRlZCB3ZSBzaG91bGQgcmVseSBvbiB0aGF0XG4gIGlmIChzb3VyY2UudHlwZSkge1xuICAgIHJldHVybiBjYW5QbGF5VHlwZShzb3VyY2UudHlwZSk7XG4gIH0gZWxzZSBpZiAoc291cmNlLnNyYykge1xuICAgIC8vIElmIG5vIHR5cGUsIGZhbGwgYmFjayB0byBjaGVja2luZyAndmlkZW8vW0VYVEVOU0lPTl0nXG4gICAgZXh0ID0gTGliLmdldEZpbGVFeHRlbnNpb24oc291cmNlLnNyYyk7XG5cbiAgICByZXR1cm4gY2FuUGxheVR5cGUoYHZpZGVvLyR7ZXh0fWApO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAqIHZpZGVvIGRhdGEgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtIdG1sNX0gdGVjaCAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgSHRtbDUgdGVjaFxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGVjaCl7XG4gIHRlY2guc2V0U3JjKHNvdXJjZS5zcmMpO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0aGUgc291cmNlIGhhbmRsZXIgd2hlbiBkaXNwb3NpbmcgdGhlIHBsYXllciBvciBzd2l0Y2hpbmcgc291cmNlcy4uXG4gKiAobm8gY2xlYW51cCBpcyBuZWVkZWQgd2hlbiBzdXBwb3J0aW5nIHRoZSBmb3JtYXQgbmF0aXZlbHkpXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7fTtcblxuLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuSHRtbDUucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqIFZvbHVtZSBjYW5ub3QgYmUgY2hhbmdlZCBpbiBhIGxvdCBvZiBtb2JpbGUgZGV2aWNlcy5cbiAqIFNwZWNpZmljYWxseSwgaXQgY2FuJ3QgYmUgY2hhbmdlZCBmcm9tIDEgb24gaU9TLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuY2FuQ29udHJvbFZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciB2b2x1bWUgPSAgTGliLlRFU1RfVklELnZvbHVtZTtcbiAgTGliLlRFU1RfVklELnZvbHVtZSA9ICh2b2x1bWUgLyAyKSArIDAuMTtcbiAgcmV0dXJuIHZvbHVtZSAhPT0gTGliLlRFU1RfVklELnZvbHVtZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgcGxheWJhY2tSYXRlIGlzIHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgcGxheWJhY2tSYXRlID0gIExpYi5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG4gIExpYi5URVNUX1ZJRC5wbGF5YmFja1JhdGUgPSAocGxheWJhY2tSYXRlIC8gMikgKyAwLjE7XG4gIHJldHVybiBwbGF5YmFja1JhdGUgIT09IExpYi5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgdGV4dCB0cmFja3MgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5IdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1cHBvcnRzVGV4dFRyYWNrcztcblxuICAvLyBGaWd1cmUgb3V0IG5hdGl2ZSB0ZXh0IHRyYWNrIHN1cHBvcnRcbiAgLy8gSWYgbW9kZSBpcyBhIG51bWJlciwgd2UgY2Fubm90IGNoYW5nZSBpdCBiZWNhdXNlIGl0J2xsIGRpc2FwcGVhciBmcm9tIHZpZXcuXG4gIC8vIEJyb3dzZXJzIHdpdGggbnVtZXJpYyBtb2RlcyBpbmNsdWRlIElFMTAgYW5kIG9sZGVyICg8PTIwMTMpIHNhbXN1bmcgYW5kcm9pZCBtb2RlbHMuXG4gIC8vIEZpcmVmb3ggaXNuJ3QgcGxheWluZyBuaWNlIGVpdGhlciB3aXRoIG1vZGlmeWluZyB0aGUgbW9kZVxuICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBmaXJlZm94OiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMTg2MlxuICBzdXBwb3J0c1RleHRUcmFja3MgPSAhIUxpYi5URVNUX1ZJRC50ZXh0VHJhY2tzO1xuICBpZiAoc3VwcG9ydHNUZXh0VHJhY2tzICYmIExpYi5URVNUX1ZJRC50ZXh0VHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICBzdXBwb3J0c1RleHRUcmFja3MgPSB0eXBlb2YgTGliLlRFU1RfVklELnRleHRUcmFja3NbMF1bJ21vZGUnXSAhPT0gJ251bWJlcic7XG4gIH1cbiAgaWYgKHN1cHBvcnRzVGV4dFRyYWNrcyAmJiBMaWIuSVNfRklSRUZPWCkge1xuICAgIHN1cHBvcnRzVGV4dFRyYWNrcyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzVGV4dFRyYWNrcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0ZWNoJ3Mgdm9sdW1lIGNvbnRyb2wgc3VwcG9ydCBzdGF0dXNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID0gSHRtbDUuY2FuQ29udHJvbFZvbHVtZSgpO1xuXG4vKipcbiAqIFNldCB0aGUgdGVjaCdzIHBsYXliYWNrUmF0ZSBzdXBwb3J0IHN0YXR1c1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNQbGF5YmFja1JhdGUnXSA9IEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRlY2gncyBzdGF0dXMgb24gbW92aW5nIHRoZSB2aWRlbyBlbGVtZW50LlxuICogSW4gaU9TLCBpZiB5b3UgbW92ZSBhIHZpZGVvIGVsZW1lbnQgaW4gdGhlIERPTSwgaXQgYnJlYWtzIHZpZGVvIHBsYXliYWNrLlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnbW92aW5nTWVkaWFFbGVtZW50SW5ET00nXSA9ICFMaWIuSVNfSU9TO1xuXG4vKipcbiAqIFNldCB0aGUgdGhlIHRlY2gncyBmdWxsc2NyZWVuIHJlc2l6ZSBzdXBwb3J0IHN0YXR1cy5cbiAqIEhUTUwgdmlkZW8gaXMgYWJsZSB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB3aGVuIGdvaW5nIHRvIGZ1bGxzY3JlZW4uXG4gKiAoTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuKVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSddID0gdHJ1ZTtcblxuLyoqXG4gKiBTZXQgdGhlIHRlY2gncyBwcm9ncmVzcyBldmVudCBzdXBwb3J0IHN0YXR1c1xuICogKHRoaXMgZGlzYWJsZXMgdGhlIG1hbnVhbCBwcm9ncmVzcyBldmVudHMgb2YgdGhlIFRlY2gpXG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyddID0gdHJ1ZTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0ZWNoJ3Mgc3RhdHVzIG9uIG5hdGl2ZSB0ZXh0IHRyYWNrIHN1cHBvcnRcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzKCk7XG5cbi8vIEhUTUw1IEZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBEZXZpY2UgRml4ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5sZXQgY2FuUGxheVR5cGU7XG5jb25zdCBtcGVndXJsUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86eC18dm5kXFwuYXBwbGVcXC4pbXBlZ3VybC9pO1xuY29uc3QgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgaWYgKExpYi5BTkRST0lEX1ZFUlNJT04gPj0gNC4wKSB7XG4gICAgaWYgKCFjYW5QbGF5VHlwZSkge1xuICAgICAgY2FuUGxheVR5cGUgPSBMaWIuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xuICAgIH1cblxuICAgIExpYi5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBpZiAodHlwZSAmJiBtcGVndXJsUkUudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ21heWJlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5QbGF5VHlwZS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIH07XG4gIH1cblxuICAvLyBPdmVycmlkZSBBbmRyb2lkIDIuMiBhbmQgbGVzcyBjYW5QbGF5VHlwZSBtZXRob2Qgd2hpY2ggaXMgYnJva2VuXG4gIGlmIChMaWIuSVNfT0xEX0FORFJPSUQpIHtcbiAgICBpZiAoIWNhblBsYXlUeXBlKSB7XG4gICAgICBjYW5QbGF5VHlwZSA9IExpYi5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gICAgfVxuXG4gICAgTGliLlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgaWYgKHR5cGUgJiYgbXA0UkUudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ21heWJlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5QbGF5VHlwZS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIH07XG4gIH1cbn07XG5cbkh0bWw1LnVucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IExpYi5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gIExpYi5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBjYW5QbGF5VHlwZTtcbiAgY2FuUGxheVR5cGUgPSBudWxsO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIGJ5IGRlZmF1bHQsIHBhdGNoIHRoZSB2aWRlbyBlbGVtZW50XG5IdG1sNS5wYXRjaENhblBsYXlUeXBlKCk7XG5cbi8vIExpc3Qgb2YgYWxsIEhUTUw1IGV2ZW50cyAodmFyaW91cyB1c2VzKS5cbkh0bWw1LkV2ZW50cyA9ICdsb2Fkc3RhcnQsc3VzcGVuZCxhYm9ydCxlcnJvcixlbXB0aWVkLHN0YWxsZWQsbG9hZGVkbWV0YWRhdGEsbG9hZGVkZGF0YSxjYW5wbGF5LGNhbnBsYXl0aHJvdWdoLHBsYXlpbmcsd2FpdGluZyxzZWVraW5nLHNlZWtlZCxlbmRlZCxkdXJhdGlvbmNoYW5nZSx0aW1ldXBkYXRlLHByb2dyZXNzLHBsYXkscGF1c2UscmF0ZWNoYW5nZSx2b2x1bWVjaGFuZ2UnLnNwbGl0KCcsJyk7XG5cbkh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbihlbCl7XG4gIGlmICghZWwpIHsgcmV0dXJuOyB9XG5cbiAgZWxbJ3BsYXllciddID0gbnVsbDtcblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdIdG1sNScsIEh0bWw1KTtcbmV4cG9ydCBkZWZhdWx0IEh0bWw1O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG4vKipcbiAqIFRoZSBNZWRpYSBMb2FkZXIgaXMgdGhlIGNvbXBvbmVudCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1lZGlhTG9hZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcbiAgICAvLyBsb2FkIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcGxheWJhY2sgdGVjaG5vbG9neS5cbiAgICBpZiAoIXBsYXllci5vcHRpb25zX1snc291cmNlcyddIHx8IHBsYXllci5vcHRpb25zX1snc291cmNlcyddLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaT0wLCBqPXBsYXllci5vcHRpb25zX1sndGVjaE9yZGVyJ107IGk8ai5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGVjaE5hbWUgPSBMaWIuY2FwaXRhbGl6ZShqW2ldKTtcbiAgICAgICAgbGV0IHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRlY2ggJiYgdGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgcGxheWVyLmxvYWRUZWNoKHRlY2hOYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAvLyBMb29wIHRocm91Z2ggcGxheWJhY2sgdGVjaG5vbG9naWVzIChIVE1MNSwgRmxhc2gpIGFuZCBjaGVjayBmb3Igc3VwcG9ydC5cbiAgICAgIC8vIC8vIFRoZW4gbG9hZCB0aGUgYmVzdCBzb3VyY2UuXG4gICAgICAvLyAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgLy8gLy8gICBBbGwgcGxheWJhY2sgdGVjaG5vbG9naWVzIHJlc3BlY3QgcHJlbG9hZCBmYWxzZS5cbiAgICAgIHBsYXllci5zcmMocGxheWVyLm9wdGlvbnNfWydzb3VyY2VzJ10pO1xuICAgIH1cbiAgfVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lZGlhTG9hZGVyJywgTWVkaWFMb2FkZXIpO1xuZXhwb3J0IGRlZmF1bHQgTWVkaWFMb2FkZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWEgVGVjaG5vbG9neSBDb250cm9sbGVyIC0gQmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2tcbiAqIHRlY2hub2xvZ3kgY29udHJvbGxlcnMgbGlrZSBGbGFzaCBhbmQgSFRNTDVcbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgVGV4dFRyYWNrIGZyb20gJy4uL3RyYWNrcy90ZXh0LXRyYWNrJztcbmltcG9ydCBUZXh0VHJhY2tMaXN0IGZyb20gJy4uL3RyYWNrcy90ZXh0LXRyYWNrLWxpc3QnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWVkaWEgKEhUTUw1IFZpZGVvLCBGbGFzaCkgY29udHJvbGxlcnNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyICBDZW50cmFsIHBsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGVjaCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zPXt9LCByZWFkeT1mdW5jdGlvbigpe30pe1xuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHRlY2ggdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHkgYXV0b21hdGljYWxseS5cbiAgICAvLyBUaGlzIGlzIGRvbmUgbWFudWFsbHkgaW4gYWRkQ29udHJvbHNMaXN0ZW5lcnNcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMnXSkge1xuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09uKCk7XG4gICAgfVxuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgdGltZXVwZGF0ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghdGhpc1snZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzJ10pIHtcbiAgICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXNPbigpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdENvbnRyb2xzTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAob3B0aW9uc1snbmF0aXZlQ2FwdGlvbnMnXSA9PT0gZmFsc2UgfHwgb3B0aW9uc1snbmF0aXZlVGV4dFRyYWNrcyddID09PSBmYWxzZSkge1xuICAgICAgdGhpc1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICB0aGlzLmVtdWxhdGVUZXh0VHJhY2tzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0VGV4dFRyYWNrTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGNsaWNrIGFuZCB0b3VjaCBsaXN0ZW5lcnMgZm9yIHRoZSBwbGF5YmFjayBlbGVtZW50XG4gICAqIE9uIGRlc2t0b3BzLCBhIGNsaWNrIG9uIHRoZSB2aWRlbyBpdHNlbGYgd2lsbCB0b2dnbGUgcGxheWJhY2ssXG4gICAqIG9uIGEgbW9iaWxlIGRldmljZSBhIGNsaWNrIG9uIHRoZSB2aWRlbyB0b2dnbGVzIGNvbnRyb2xzLlxuICAgKiAodG9nZ2xpbmcgY29udHJvbHMgaXMgZG9uZSBieSB0b2dnbGluZyB0aGUgdXNlciBzdGF0ZSBiZXR3ZWVuIGFjdGl2ZSBhbmRcbiAgICogaW5hY3RpdmUpXG4gICAqXG4gICAqIEEgdGFwIGNhbiBzaWduYWwgdGhhdCBhIHVzZXIgaGFzIGJlY29tZSBhY3RpdmUsIG9yIGhhcyBiZWNvbWUgaW5hY3RpdmVcbiAgICogZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogcXVpY2sgdGFwIHNob3VsZCBoaWRlIHRoZW0gYWdhaW4gKHNpZ25hbGluZyB0aGUgdXNlciBpcyBpbiBhbiBpbmFjdGl2ZVxuICAgKiB2aWV3aW5nIHN0YXRlKVxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogYSBmZXcgc2Vjb25kcyBvZiBpbmFjdGl2aXR5LlxuICAgKlxuICAgKiBOb3RlOiB0aGUgb25seSBwYXJ0IG9mIGlPUyBpbnRlcmFjdGlvbiB3ZSBjYW4ndCBtaW1pYyB3aXRoIHRoaXMgc2V0dXBcbiAgICogaXMgYSB0b3VjaCBhbmQgaG9sZCBvbiB0aGUgdmlkZW8gZWxlbWVudCBjb3VudGluZyBhcyBhY3Rpdml0eSBpbiBvcmRlciB0b1xuICAgKiBrZWVwIHRoZSBjb250cm9scyBzaG93aW5nLCBidXQgdGhhdCBzaG91bGRuJ3QgYmUgYW4gaXNzdWUuIEEgdG91Y2ggYW5kIGhvbGQgb25cbiAgICogYW55IGNvbnRyb2xzIHdpbGwgc3RpbGwga2VlcCB0aGUgdXNlciBhY3RpdmVcbiAgICovXG4gIGluaXRDb250cm9sc0xpc3RlbmVycygpIHtcbiAgICBsZXQgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgIGxldCBhY3RpdmF0ZUNvbnRyb2xzID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChwbGF5ZXIuY29udHJvbHMoKSAmJiAhcGxheWVyLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICB0aGlzLmFkZENvbnRyb2xzTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnMgb25jZSB0aGUgdGVjaCBpcyByZWFkeSBhbmQgaGFzIGFuIGVsZW1lbnQgdG8gYXBwbHlcbiAgICAvLyBsaXN0ZW5lcnMgdG9cbiAgICB0aGlzLnJlYWR5KGFjdGl2YXRlQ29udHJvbHMpO1xuICAgIHRoaXMub24ocGxheWVyLCAnY29udHJvbHNlbmFibGVkJywgYWN0aXZhdGVDb250cm9scyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc2Rpc2FibGVkJywgdGhpcy5yZW1vdmVDb250cm9sc0xpc3RlbmVycyk7XG5cbiAgICAvLyBpZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZyBvciBwbGF5aW5nIHRoZVxuICAgIC8vIHZpZGVvIChvZnRlbiB3aXRoIGF1dG9wbGF5IG9uKSB0aGVuIHRoZSBsb2Fkc3RhcnQgZXZlbnQgaGFzIGFscmVhZHkgZmlyZWQgYW5kIHdlXG4gICAgLy8gbmVlZCB0byBmaXJlIGl0IG1hbnVhbGx5IGJlY2F1c2UgbWFueSB0aGluZ3MgcmVseSBvbiBpdC5cbiAgICAvLyBMb25nIHRlcm0gd2UgbWlnaHQgY29uc2lkZXIgaG93IHdlIHdvdWxkIGRvIHRoaXMgZm9yIG90aGVyIGV2ZW50cyBsaWtlICdjYW5wbGF5J1xuICAgIC8vIHRoYXQgbWF5IGFsc28gaGF2ZSBmaXJlZC5cbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy5uZXR3b3JrU3RhdGUgJiYgdGhpcy5uZXR3b3JrU3RhdGUoKSA+IDApIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIoKS50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFkZENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIGxldCB1c2VyV2FzQWN0aXZlO1xuXG4gICAgLy8gU29tZSBicm93c2VycyAoQ2hyb21lICYgSUUpIGRvbid0IHRyaWdnZXIgYSBjbGljayBvbiBhIGZsYXNoIHN3ZiwgYnV0IGRvXG4gICAgLy8gdHJpZ2dlciBtb3VzZWRvd24vdXAuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDQ0NTYyL2phdmFzY3JpcHQtb25jbGljay1ldmVudC1vdmVyLWZsYXNoLW9iamVjdFxuICAgIC8vIEFueSB0b3VjaCBldmVudHMgYXJlIHNldCB0byBibG9jayB0aGUgbW91c2Vkb3duIGV2ZW50IGZyb20gaGFwcGVuaW5nXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbkNsaWNrKTtcblxuICAgIC8vIElmIHRoZSBjb250cm9scyB3ZXJlIGhpZGRlbiB3ZSBkb24ndCB3YW50IHRoYXQgdG8gY2hhbmdlIHdpdGhvdXQgYSB0YXAgZXZlbnRcbiAgICAvLyBzbyB3ZSdsbCBjaGVjayBpZiB0aGUgY29udHJvbHMgd2VyZSBhbHJlYWR5IHNob3dpbmcgYmVmb3JlIHJlcG9ydGluZyB1c2VyXG4gICAgLy8gYWN0aXZpdHlcbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHVzZXJXYXNBY3RpdmUgPSB0aGlzLnBsYXllcl8udXNlckFjdGl2ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbigndG91Y2htb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmICh1c2VyV2FzQWN0aXZlKXtcbiAgICAgICAgdGhpcy5wbGF5ZXIoKS5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgLy8gVHVybiBvbiBjb21wb25lbnQgdGFwIGV2ZW50c1xuICAgIHRoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgLy8gVGhlIHRhcCBsaXN0ZW5lciBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSB0b3VjaGVuZCBsaXN0ZW5lciBiZWNhdXNlIHRoZSB0YXBcbiAgICAvLyBsaXN0ZW5lciBjYW5jZWxzIG91dCBhbnkgcmVwb3J0ZWRVc2VyQWN0aXZpdHkgd2hlbiBzZXR0aW5nIHVzZXJBY3RpdmUoZmFsc2UpXG4gICAgdGhpcy5vbigndGFwJywgdGhpcy5vblRhcCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdXNlZCBmb3IgY2xpY2sgYW5kIHRhcCBjb250cm9scy4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cbiAgICovXG4gIHJlbW92ZUNvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYoJ3RhcCcpO1xuICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0Jyk7XG4gICAgdGhpcy5vZmYoJ3RvdWNobW92ZScpO1xuICAgIHRoaXMub2ZmKCd0b3VjaGxlYXZlJyk7XG4gICAgdGhpcy5vZmYoJ3RvdWNoY2FuY2VsJyk7XG4gICAgdGhpcy5vZmYoJ3RvdWNoZW5kJyk7XG4gICAgdGhpcy5vZmYoJ2NsaWNrJyk7XG4gICAgdGhpcy5vZmYoJ21vdXNlZG93bicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBCeSBkZWZhdWx0IHdpbGwgcGxheS9wYXVzZSB0aGUgbWVkaWEuXG4gICAqL1xuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2UncmUgdXNpbmcgbW91c2Vkb3duIHRvIGRldGVjdCBjbGlja3MgdGhhbmtzIHRvIEZsYXNoLCBidXQgbW91c2Vkb3duXG4gICAgLy8gd2lsbCBhbHNvIGJlIHRyaWdnZXJlZCB3aXRoIHJpZ2h0LWNsaWNrcywgc28gd2UgbmVlZCB0byBwcmV2ZW50IHRoYXRcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAvLyBXaGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZCBhIGNsaWNrIHNob3VsZCBub3QgdG9nZ2xlIHBsYXliYWNrIGJlY2F1c2VcbiAgICAvLyB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIGNvbnRyb2xcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5jb250cm9scygpKSB7XG4gICAgICBpZiAodGhpcy5wbGF5ZXIoKS5wYXVzZWQoKSkge1xuICAgICAgICB0aGlzLnBsYXllcigpLnBsYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGxheWVyKCkucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBCeSBkZWZhdWx0IGl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKi9cbiAgb25UYXAoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS51c2VyQWN0aXZlKCF0aGlzLnBsYXllcigpLnVzZXJBY3RpdmUoKSk7XG4gIH1cblxuICAvKiBGYWxsYmFja3MgZm9yIHVuc3VwcG9ydGVkIGV2ZW50IHR5cGVzXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gIC8vIE1hbnVhbGx5IHRyaWdnZXIgcHJvZ3Jlc3MgZXZlbnRzIGJhc2VkIG9uIGNoYW5nZXMgdG8gdGhlIGJ1ZmZlcmVkIGFtb3VudFxuICAvLyBNYW55IGZsYXNoIHBsYXllcnMgYW5kIG9sZGVyIEhUTUw1IGJyb3dzZXJzIGRvbid0IHNlbmQgcHJvZ3Jlc3Mgb3IgcHJvZ3Jlc3MtbGlrZSBldmVudHNcbiAgbWFudWFsUHJvZ3Jlc3NPbigpIHtcbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gdHJ1ZTtcblxuICAgIC8vIFRyaWdnZXIgcHJvZ3Jlc3Mgd2F0Y2hpbmcgd2hlbiBhIHNvdXJjZSBiZWdpbnMgbG9hZGluZ1xuICAgIHRoaXMudHJhY2tQcm9ncmVzcygpO1xuICB9XG5cbiAgbWFudWFsUHJvZ3Jlc3NPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcbiAgfVxuXG4gIHRyYWNrUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciB1bmxlc3MgYnVmZmVyZWQgYW1vdW50IGlzIGdyZWF0ZXIgdGhhbiBsYXN0IHRpbWVcblxuICAgICAgbGV0IGJ1ZmZlcmVkUGVyY2VudCA9IHRoaXMucGxheWVyKCkuYnVmZmVyZWRQZXJjZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gIT0gYnVmZmVyZWRQZXJjZW50KSB7XG4gICAgICAgIHRoaXMucGxheWVyKCkudHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXJlZFBlcmNlbnRfID0gYnVmZmVyZWRQZXJjZW50O1xuXG4gICAgICBpZiAoYnVmZmVyZWRQZXJjZW50ID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcbiAgICAgIH1cbiAgICB9LCA1MDApO1xuICB9XG5cbiAgc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH1cblxuICAvKiEgVGltZSBUcmFja2luZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIGxldCBwbGF5ZXIgPSB0aGlzLnBsYXllcl87XG5cbiAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzID0gdHJ1ZTtcblxuICAgIHRoaXMub24ocGxheWVyLCAncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICAgIC8vIHRpbWV1cGRhdGUgaXMgYWxzbyBjYWxsZWQgYnkgLmN1cnJlbnRUaW1lIHdoZW5ldmVyIGN1cnJlbnQgdGltZSBpcyBzZXRcblxuICAgIC8vIFdhdGNoIGZvciBuYXRpdmUgdGltZXVwZGF0ZSBldmVudFxuICAgIHRoaXMub25lKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24oKXtcbiAgICAgIC8vIFVwZGF0ZSBrbm93biBwcm9ncmVzcyBzdXBwb3J0IGZvciB0aGlzIHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICAgIHRoaXNbJ2ZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyddID0gdHJ1ZTtcbiAgICAgIC8vIFR1cm4gb2ZmIG1hbnVhbCBwcm9ncmVzcyB0cmFja2luZ1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09mZigpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgbGV0IHBsYXllciA9IHRoaXMucGxheWVyXztcblxuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5vZmYocGxheWVyLCAncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYocGxheWVyLCAncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfVxuXG4gIHRyYWNrQ3VycmVudFRpbWUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCkgeyB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7IH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnBsYXllcigpLnRyaWdnZXIoJ3RpbWV1cGRhdGUnKTtcbiAgICB9LCAyNTApOyAvLyA0MiA9IDI0IGZwcyAvLyAyNTAgaXMgd2hhdCBXZWJraXQgdXNlcyAvLyBGRiB1c2VzIDE1XG4gIH1cblxuICAvLyBUdXJuIG9mZiBwbGF5IHByb2dyZXNzIHRyYWNraW5nICh3aGVuIHBhdXNlZCBvciBkcmFnZ2luZylcbiAgc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCk7XG5cbiAgICAvLyAjMTAwMiAtIGlmIHRoZSB2aWRlbyBlbmRzIHJpZ2h0IGJlZm9yZSB0aGUgbmV4dCB0aW1ldXBkYXRlIHdvdWxkIGhhcHBlbixcbiAgICAvLyB0aGUgcHJvZ3Jlc3MgYmFyIHdvbid0IG1ha2UgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZFxuICAgIHRoaXMucGxheWVyKCkudHJpZ2dlcigndGltZXVwZGF0ZScpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykgeyB0aGlzLm1hbnVhbFByb2dyZXNzT2ZmKCk7IH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7IHRoaXMubWFudWFsVGltZVVwZGF0ZXNPZmYoKTsgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHsgdGhpcy5wbGF5ZXIoKS50cmlnZ2VyKCd0aW1ldXBkYXRlJyk7IH1cbiAgfVxuXG4gIC8vIFRPRE86IENvbnNpZGVyIGxvb2tpbmcgYXQgbW92aW5nIHRoaXMgaW50byB0aGUgdGV4dCB0cmFjayBkaXNwbGF5IGRpcmVjdGx5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8xODYzXG4gIGluaXRUZXh0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgbGV0IHBsYXllciA9IHRoaXMucGxheWVyXztcblxuICAgIGxldCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHRleHRUcmFja0Rpc3BsYXkgPSBwbGF5ZXIuZ2V0Q2hpbGQoJ3RleHRUcmFja0Rpc3BsYXknKTtcblxuICAgICAgaWYgKHRleHRUcmFja0Rpc3BsYXkpIHtcbiAgICAgICAgdGV4dFRyYWNrRGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tzKSByZXR1cm47XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuICAgIH0pKTtcbiAgfVxuXG4gIGVtdWxhdGVUZXh0VHJhY2tzKCkge1xuICAgIGxldCBwbGF5ZXIgPSB0aGlzLnBsYXllcl87XG5cbiAgICBpZiAoIXdpbmRvd1snV2ViVlRUJ10pIHtcbiAgICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdC5zcmMgPSBwbGF5ZXIub3B0aW9ucygpWyd2dHQuanMnXSB8fCAnLi4vbm9kZV9tb2R1bGVzL3Z0dC5qcy9kaXN0L3Z0dC5qcyc7XG4gICAgICBwbGF5ZXIuZWwoKS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgd2luZG93WydXZWJWVFQnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRleHRUcmFja3NDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgdGV4dFRyYWNrRGlzcGxheSA9IHBsYXllci5nZXRDaGlsZCgndGV4dFRyYWNrRGlzcGxheScpO1xuXG4gICAgICB0ZXh0VHJhY2tEaXNwbGF5LnVwZGF0ZURpc3BsYXkoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRoaXNbaV07XG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIExpYi5iaW5kKHRleHRUcmFja0Rpc3BsYXksIHRleHRUcmFja0Rpc3BsYXkudXBkYXRlRGlzcGxheSkpO1xuICAgICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgTGliLmJpbmQodGV4dFRyYWNrRGlzcGxheSwgdGV4dFRyYWNrRGlzcGxheS51cGRhdGVEaXNwbGF5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgZGVmYXVsdCBtZXRob2RzIGZvciB0ZXh0IHRyYWNrcy5cbiAgICpcbiAgICogSHRtbDUgdGVjaCBvdmVycmlkZXMgdGhlc2UuXG4gICAqL1xuXG4gIHRleHRUcmFja3MoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnRleHRUcmFja3NfID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3NfIHx8IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy50ZXh0VHJhY2tzXztcbiAgfVxuXG4gIHJlbW90ZVRleHRUcmFja3MoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja3NfID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja3NfIHx8IG5ldyBUZXh0VHJhY2tMaXN0KCk7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tzXztcbiAgfVxuXG4gIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIWtpbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dFRyYWNrIGtpbmQgaXMgcmVxdWlyZWQgYnV0IHdhcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlVHJhY2tIZWxwZXIodGhpcywga2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgbGV0IHRyYWNrID0gY3JlYXRlVHJhY2tIZWxwZXIodGhpcywgb3B0aW9uc1sna2luZCddLCBvcHRpb25zWydsYWJlbCddLCBvcHRpb25zWydsYW5ndWFnZSddLCBvcHRpb25zKTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFja18odHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB0cmFjazogdHJhY2tcbiAgICB9O1xuICB9XG5cbiAgcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2tfKHRyYWNrKTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBkZWZhdWx0IHNldFBvc3RlciBtZXRob2QgZm9yIHRlY2hzXG4gICAqXG4gICAqIFBvc3RlciBzdXBwb3J0IGZvciB0ZWNocyBzaG91bGQgYmUgb3B0aW9uYWwsIHNvIHdlIGRvbid0IHdhbnQgdGVjaHMgdG9cbiAgICogYnJlYWsgaWYgdGhleSBkb24ndCBoYXZlIGEgd2F5IHRvIHNldCBhIHBvc3Rlci5cbiAgICovXG4gIHNldFBvc3RlcigpIHt9XG5cbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3NcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblRlY2gucHJvdG90eXBlLnRleHRUcmFja3NfO1xuXG52YXIgY3JlYXRlVHJhY2tIZWxwZXIgPSBmdW5jdGlvbihzZWxmLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UsIG9wdGlvbnM9e30pIHtcbiAgbGV0IHRyYWNrcyA9IHNlbGYudGV4dFRyYWNrcygpO1xuXG4gIG9wdGlvbnNbJ2tpbmQnXSA9IGtpbmQ7XG4gIGlmIChsYWJlbCkge1xuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBsYWJlbDtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBvcHRpb25zWydsYW5ndWFnZSddID0gbGFuZ3VhZ2U7XG4gIH1cbiAgb3B0aW9uc1sncGxheWVyJ10gPSBzZWxmLnBsYXllcl87XG5cbiAgbGV0IHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcbiAgdHJhY2tzLmFkZFRyYWNrXyh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufTtcblxuVGVjaC5wcm90b3R5cGVbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID0gdHJ1ZTtcblxuLy8gUmVzaXppbmcgcGx1Z2lucyB1c2luZyByZXF1ZXN0IGZ1bGxzY3JlZW4gcmVsb2FkcyB0aGUgcGx1Z2luXG5UZWNoLnByb3RvdHlwZVsnZmVhdHVyZXNGdWxsc2NyZWVuUmVzaXplJ10gPSBmYWxzZTtcblRlY2gucHJvdG90eXBlWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddID0gZmFsc2U7XG5cbi8vIE9wdGlvbmFsIGV2ZW50cyB0aGF0IHdlIGNhbiBtYW51YWxseSBtaW1pYyB3aXRoIHRpbWVyc1xuLy8gY3VycmVudGx5IG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmXG5UZWNoLnByb3RvdHlwZVsnZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyddID0gZmFsc2U7XG5UZWNoLnByb3RvdHlwZVsnZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzJ10gPSBmYWxzZTtcblxuVGVjaC5wcm90b3R5cGVbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddID0gZmFsc2U7XG5cbi8qKlxuICogQSBmdW5jdGlvbmFsIG1peGluIGZvciB0ZWNocyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuLlxuICpcbiAqICMjIyMjIEVYQU1QTEU6XG4gKlxuICogICBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7XG4gKlxuICovXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyA9IGZ1bmN0aW9uKF9UZWNoKXtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgc291cmNlIGhhbmRsZXJcbiAgICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxuICAgKiBUaGUgc291cmNlIGhhbmRsZXIgcGF0dGVybiBpcyB1c2VkIGZvciBhZGFwdGl2ZSBmb3JtYXRzIChITFMsIERBU0gpIHRoYXRcbiAgICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXIgIFRoZSBzb3VyY2UgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgZmlyc3QgICAgUmVnaXN0ZXIgaXQgYmVmb3JlIGFueSBleGlzdGluZyBoYW5kbGVyc1xuICAgKi9cbiAgIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIsIGluZGV4KXtcbiAgICBsZXQgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgIGluZGV4ID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqIFRPRE86IEFuc3dlciBxdWVzdGlvbjogc2hvdWxkICdwcm9iYWJseScgYmUgcHJpb3JpdGl6ZWQgb3ZlciAnbWF5YmUnXG4gICAqIEBwYXJhbSAge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgIFRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICogQHJldHVybnMge251bGx9ICAgICAgICAgTnVsbCBpZiBubyBzb3VyY2UgaGFuZGxlciBpcyBmb3VuZFxuICAgKi9cbiAgIF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIGxldCBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIGxldCBjYW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICAqIEBwYXJhbSAge09iamVjdH0gc3JjT2JqICBUaGUgc291cmNlIG9iamVjdFxuICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAqL1xuICBfVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24oc3JjT2JqKXtcbiAgICBsZXQgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNyY09iaik7XG5cbiAgICBpZiAoc2gpIHtcbiAgICAgIHJldHVybiBzaC5jYW5IYW5kbGVTb3VyY2Uoc3JjT2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBzb3VyY2UgdXNpbmcgYSBzb3VyY2Ugb2JqZWN0XG4gICAqIGFuZCBzb3VyY2UgaGFuZGxlcnMuXG4gICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIGEgc291cmNlIGhhbmRsZXIgd2FzIGZvdW5kLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKiBAcmV0dXJuIHtUZWNofSBzZWxmXG4gICAqL1xuICAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgbGV0IHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzb3VyY2UpO1xuXG4gICAgaWYgKCFzaCkge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGEgbmF0aXZlIHNvdXJjZSBoYW5kZXIgd2hlbiB1bnN1cHBvcnRlZCBzb3VyY2VzIGFyZVxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxuICAgICAgaWYgKF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgc2ggPSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTGliLmxvZy5lcnJvcignTm8gc291cmNlIGhhbmRlciBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3Bvc2UgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcigpO1xuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAqL1xuICAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UpIHtcbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZWNoJywgVGVjaCk7XG4vLyBPbGQgbmFtZSBmb3IgVGVjaFxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYVRlY2hDb250cm9sbGVyJywgVGVjaCk7XG5leHBvcnQgZGVmYXVsdCBUZWNoO1xuIiwiaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWVsaXN0XG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFja0N1ZUxpc3Qge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2tDdWUgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2tDdWU/IGdldEN1ZUJ5SWQoRE9NU3RyaW5nIGlkKTtcbiAqIH07XG4gKi9cblxubGV0IFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbihjdWVzKSB7XG4gIGxldCBsaXN0ID0gdGhpcztcblxuICBpZiAoTGliLklTX0lFOCkge1xuICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXy5jYWxsKGxpc3QsIGN1ZXMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhfO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKExpYi5JU19JRTgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufTtcblxuVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18gPSBmdW5jdGlvbihjdWVzKSB7XG4gIGxldCBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBsID0gY3Vlcy5sZW5ndGg7XG5cbiAgdGhpcy5jdWVzXyA9IGN1ZXM7XG4gIHRoaXMubGVuZ3RoXyA9IGN1ZXMubGVuZ3RoO1xuXG4gIGxldCBkZWZpbmVQcm9wID0gZnVuY3Rpb24oaSkge1xuICAgIGlmICghKCcnK2kgaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJyArIGksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jdWVzX1tpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChvbGRMZW5ndGggPCBsKSB7XG4gICAgaSA9IG9sZExlbmd0aDtcblxuICAgIGZvcig7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRlZmluZVByb3AuY2FsbCh0aGlzLCBpKTtcbiAgICB9XG4gIH1cbn07XG5cblRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLmdldEN1ZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjdWUgPSB0aGlzW2ldO1xuICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICByZXN1bHQgPSBjdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrQ3VlTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBNZW51IGZyb20gJy4uL21lbnUvbWVudS5qcyc7XG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi4vbWVudS9tZW51LWl0ZW0uanMnO1xuaW1wb3J0IE1lbnVCdXR0b24gZnJvbSAnLi4vbWVudS9tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuY29uc3QgZGFya0dyYXkgPSAnIzIyMic7XG5jb25zdCBsaWdodEdyYXkgPSAnI2NjYyc7XG5jb25zdCBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICAgICAgICAgICAgICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICAgICAgICAgICAgICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICAgICAgICAgICAgICAgICAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICAgICAgICAnXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UnLFxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgcHJvcG9ydGlvbmFsU2VyaWY6ICAgICAnc2VyaWYnLFxuICBjYXN1YWw6ICAgICAgICAgICAgICAgICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAgICAgICAgICAgICAgICAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICAgICAgICAgICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIHRleHQgdHJhY2sgY3Vlc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0VHJhY2tEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgTGliLmJpbmQodGhpcywgdGhpcy50b2dnbGVEaXNwbGF5KSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwbGF5ZXIudGVjaCAmJiBwbGF5ZXIudGVjaFsnZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG5cbiAgICAgIGxldCB0cmFja3MgPSBwbGF5ZXIub3B0aW9uc19bJ3RyYWNrcyddIHx8IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICB0aGlzLnBsYXllcl8uYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICB0b2dnbGVEaXNwbGF5KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaCAmJiB0aGlzLnBsYXllcl8udGVjaFsnZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXG4gICAgfSk7XG4gIH1cblxuICBjbGVhckRpc3BsYXkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3dbJ1dlYlZUVCddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3dbJ1dlYlZUVCddWydwcm9jZXNzQ3VlcyddKHdpbmRvdywgW10sIHRoaXMuZWxfKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgdGhpcy5jbGVhckRpc3BsYXkoKTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAodHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2sodHJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUZvclRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3dbJ1dlYlZUVCddICE9PSAnZnVuY3Rpb24nIHx8ICF0cmFja1snYWN0aXZlQ3VlcyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG92ZXJyaWRlcyA9IHRoaXMucGxheWVyX1sndGV4dFRyYWNrU2V0dGluZ3MnXS5nZXRWYWx1ZXMoKTtcblxuICAgIGxldCBjdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja1snYWN0aXZlQ3VlcyddLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdWVzLnB1c2godHJhY2tbJ2FjdGl2ZUN1ZXMnXVtpXSk7XG4gICAgfVxuXG4gICAgd2luZG93WydXZWJWVFQnXVsncHJvY2Vzc0N1ZXMnXSh3aW5kb3csIHRyYWNrWydhY3RpdmVDdWVzJ10sIHRoaXMuZWxfKTtcblxuICAgIGxldCBpID0gY3Vlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgbGV0IGN1ZURpdiA9IGN1ZXNbaV0uZGlzcGxheVN0YXRlO1xuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICdjb2xvcicsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMud2luZG93Q29sb3IsIG92ZXJyaWRlcy53aW5kb3dPcGFjaXR5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJyaWRlcy53aW5kb3dDb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdkcm9wc2hhZG93Jykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSBgMnB4IDJweCAzcHggJHtkYXJrR3JheX0sIDJweCAycHggNHB4ICR7ZGFya0dyYXl9LCAycHggMnB4IDVweCAke2RhcmtHcmF5fWA7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gYDFweCAxcHggJHtkYXJrR3JheX0sIDJweCAycHggJHtkYXJrR3JheX0sIDNweCAzcHggJHtkYXJrR3JheX1gO1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdkZXByZXNzZWQnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9IGAxcHggMXB4ICR7bGlnaHRHcmF5fSwgMCAxcHggJHtsaWdodEdyYXl9LCAtMXB4IC0xcHggJHtkYXJrR3JheX0sIDAgLTFweCAke2RhcmtHcmF5fWA7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9IGAwIDAgNHB4ICR7ZGFya0dyYXl9LCAwIDAgNHB4ICR7ZGFya0dyYXl9LCAwIDAgNHB4ICR7ZGFya0dyYXl9LCAwIDAgNHB4ICR7ZGFya0dyYXl9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5mb250UGVyY2VudCAmJiBvdmVycmlkZXMuZm9udFBlcmNlbnQgIT09IDEpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB3aW5kb3cucGFyc2VGbG9hdChjdWVEaXYuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICBjdWVEaXYuc3R5bGUuZm9udFNpemUgPSAoZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQpICsgJ3B4JztcbiAgICAgICAgY3VlRGl2LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgY3VlRGl2LnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgY3VlRGl2LnN0eWxlLmJvdHRvbSA9ICcycHgnO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5mb250RmFtaWx5ICYmIG92ZXJyaWRlcy5mb250RmFtaWx5ICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5mb250RmFtaWx5ID09PSAnc21hbGwtY2FwcycpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5mb250VmFyaWFudCA9ICdzbWFsbC1jYXBzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5mb250RmFtaWx5ID0gZm9udE1hcFtvdmVycmlkZXMuZm9udEZhbWlseV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG4vLyBBZGQgY3VlIEhUTUwgdG8gZGlzcGxheVxuZnVuY3Rpb24gY29uc3RydWN0Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgcmV0dXJuICdyZ2JhKCcgK1xuICAgIC8vIGNvbG9yIGxvb2tzIGxpa2UgXCIjZjBlXCJcbiAgICBwYXJzZUludChjb2xvclsxXSArIGNvbG9yWzFdLCAxNikgKyAnLCcgK1xuICAgIHBhcnNlSW50KGNvbG9yWzJdICsgY29sb3JbMl0sIDE2KSArICcsJyArXG4gICAgcGFyc2VJbnQoY29sb3JbM10gKyBjb2xvclszXSwgMTYpICsgJywnICtcbiAgICBvcGFjaXR5ICsgJyknO1xufVxuXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgLy8gc29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIHBhcnRpY3VsYXJseSBpbiBJRTguIFRob3NlIHNob3VsZCBiZSBub29wcy5cbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0Rpc3BsYXknLCBUZXh0VHJhY2tEaXNwbGF5KTtcbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFja0Rpc3BsYXk7XG4iLCIvKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja21vZGVcbiAqXG4gKiBlbnVtIFRleHRUcmFja01vZGUgeyBcImRpc2FibGVkXCIsICBcImhpZGRlblwiLCAgXCJzaG93aW5nXCIgfTtcbiAqL1xudmFyIFRleHRUcmFja01vZGUgPSB7XG4gICdkaXNhYmxlZCc6ICdkaXNhYmxlZCcsXG4gICdoaWRkZW4nOiAnaGlkZGVuJyxcbiAgJ3Nob3dpbmcnOiAnc2hvd2luZydcbn07XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNra2luZFxuICpcbiAqIGVudW0gVGV4dFRyYWNrS2luZCB7IFwic3VidGl0bGVzXCIsICBcImNhcHRpb25zXCIsICBcImRlc2NyaXB0aW9uc1wiLCAgXCJjaGFwdGVyc1wiLCAgXCJtZXRhZGF0YVwiIH07XG4gKi9cbnZhciBUZXh0VHJhY2tLaW5kID0ge1xuICAnc3VidGl0bGVzJzogJ3N1YnRpdGxlcycsXG4gICdjYXB0aW9ucyc6ICdjYXB0aW9ucycsXG4gICdkZXNjcmlwdGlvbnMnOiAnZGVzY3JpcHRpb25zJyxcbiAgJ2NoYXB0ZXJzJzogJ2NoYXB0ZXJzJyxcbiAgJ21ldGFkYXRhJzogJ21ldGFkYXRhJ1xufTtcblxuZXhwb3J0IHsgVGV4dFRyYWNrTW9kZSwgVGV4dFRyYWNrS2luZCB9O1xuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9ldmVudC1lbWl0dGVyJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi9saWInO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdFxuICpcbiAqIGludGVyZmFjZSBUZXh0VHJhY2tMaXN0IDogRXZlbnRUYXJnZXQge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2sgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2s/IGdldFRyYWNrQnlJZChET01TdHJpbmcgaWQpO1xuICpcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmNoYW5nZTtcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmFkZHRyYWNrO1xuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9ucmVtb3ZldHJhY2s7XG4gKiB9O1xuICovXG5sZXQgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uKHRyYWNrcykge1xuICBsZXQgbGlzdCA9IHRoaXM7XG5cbiAgaWYgKExpYi5JU19JRTgpIHtcbiAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIFRleHRUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICBsaXN0W3Byb3BdID0gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgdHJhY2tzID0gdHJhY2tzIHx8IFtdO1xuICBsaXN0LnRyYWNrc18gPSBbXTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzXy5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGxpc3QuYWRkVHJhY2tfKHRyYWNrc1tpXSk7XG4gIH1cblxuICBpZiAoTGliLklTX0lFOCkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG59O1xuXG5UZXh0VHJhY2tMaXN0LnByb3RvdHlwZSA9IExpYi5vYmouY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0VHJhY2tMaXN0O1xuXG4vKlxuICogY2hhbmdlIC0gT25lIG9yIG1vcmUgdHJhY2tzIGluIHRoZSB0cmFjayBsaXN0IGhhdmUgYmVlbiBlbmFibGVkIG9yIGRpc2FibGVkLlxuICogYWRkdHJhY2sgLSBBIHRyYWNrIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB0cmFjayBsaXN0LlxuICogcmVtb3ZldHJhY2sgLSBBIHRyYWNrIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgdHJhY2sgbGlzdC5cbiovXG5UZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgJ2NoYW5nZSc6ICdjaGFuZ2UnLFxuICAnYWRkdHJhY2snOiAnYWRkdHJhY2snLFxuICAncmVtb3ZldHJhY2snOiAncmVtb3ZldHJhY2snXG59O1xuXG4vLyBlbXVsYXRlIGF0dHJpYnV0ZSBFdmVudEhhbmRsZXIgc3VwcG9ydCB0byBhbGxvdyBmb3IgZmVhdHVyZSBkZXRlY3Rpb25cbmZvciAobGV0IGV2ZW50IGluIFRleHRUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfKSB7XG4gIFRleHRUcmFja0xpc3QucHJvdG90eXBlWydvbicgKyBldmVudF0gPSBudWxsO1xufVxuXG5UZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFja18gPSBmdW5jdGlvbih0cmFjaykge1xuICBsZXQgaW5kZXggPSB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICBpZiAoISgnJytpbmRleCBpbiB0aGlzKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzX1tpbmRleF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgTGliLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgfSkpO1xuICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG5cbiAgdGhpcy50cmlnZ2VyKHtcbiAgICB0eXBlOiAnYWRkdHJhY2snLFxuICAgIHRyYWNrOiB0cmFja1xuICB9KTtcbn07XG5cblRleHRUcmFja0xpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrXyA9IGZ1bmN0aW9uKHJ0cmFjaykge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgbGV0IHRyYWNrO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0cmFjayA9IHRoaXNbaV07XG4gICAgaWYgKHRyYWNrID09PSBydHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzXy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoe1xuICAgIHR5cGU6ICdyZW1vdmV0cmFjaycsXG4gICAgdHJhY2s6IHRyYWNrXG4gIH0pO1xufTtcblxuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuZ2V0VHJhY2tCeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCB0cmFjayA9IHRoaXNbaV07XG4gICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi9saWInO1xuaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgc2FmZVBhcnNlVHVwbGUgZnJvbSAnc2FmZS1qc29uLXBhcnNlL3R1cGxlJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmNsYXNzIFRleHRUcmFja1NldHRpbmdzIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWRvbmUtYnV0dG9uJyksICdjbGljaycsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pKTtcblxuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtcGVyY2VudCBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMjtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pKTtcblxuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1mZy1jb2xvciA+IHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0JyksICdjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy10ZXh0LW9wYWNpdHkgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0JyksICdjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1mb250LXBlcmNlbnQgc2VsZWN0JyksICdjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuXG4gICAgaWYgKHBsYXllci5vcHRpb25zKClbJ3BlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyddKSB7XG4gICAgICB0aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNhcHRpb24tc2V0dGluZ3MgdmpzLW1vZGFsLW92ZXJsYXknLFxuICAgICAgaW5uZXJIVE1MOiBjYXB0aW9uT3B0aW9uc01lbnVUZW1wbGF0ZSgpXG4gICAgfSk7XG4gIH1cblxuICBnZXRWYWx1ZXMoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsKCk7XG5cbiAgICBjb25zdCB0ZXh0RWRnZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy1lZGdlLXN0eWxlIHNlbGVjdCcpKTtcbiAgICBjb25zdCBmb250RmFtaWx5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtZmFtaWx5IHNlbGVjdCcpKTtcbiAgICBjb25zdCBmZ0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IHRleHRPcGFjaXR5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpKTtcbiAgICBjb25zdCBiZ0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IGJnT3BhY2l0eSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IHdpbmRvd0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcud2luZG93LWNvbG9yID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IHdpbmRvd09wYWNpdHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKSk7XG4gICAgY29uc3QgZm9udFBlcmNlbnQgPSB3aW5kb3dbJ3BhcnNlRmxvYXQnXShnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JykpKTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAnYmFja2dyb3VuZE9wYWNpdHknOiBiZ09wYWNpdHksXG4gICAgICAndGV4dE9wYWNpdHknOiB0ZXh0T3BhY2l0eSxcbiAgICAgICd3aW5kb3dPcGFjaXR5Jzogd2luZG93T3BhY2l0eSxcbiAgICAgICdlZGdlU3R5bGUnOiB0ZXh0RWRnZSxcbiAgICAgICdmb250RmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICdjb2xvcic6IGZnQ29sb3IsXG4gICAgICAnYmFja2dyb3VuZENvbG9yJzogYmdDb2xvcixcbiAgICAgICd3aW5kb3dDb2xvcic6IHdpbmRvd0NvbG9yLFxuICAgICAgJ2ZvbnRQZXJjZW50JzogZm9udFBlcmNlbnRcbiAgICB9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gcmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0W25hbWVdID09PSAnJyB8fCByZXN1bHRbbmFtZV0gPT09ICdub25lJyB8fCAobmFtZSA9PT0gJ2ZvbnRQZXJjZW50JyAmJiByZXN1bHRbbmFtZV0gPT09IDEuMDApKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsKCk7XG5cbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0JyksIHZhbHVlcy5lZGdlU3R5bGUpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1mYW1pbHkgc2VsZWN0JyksIHZhbHVlcy5mb250RmFtaWx5KTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0JyksIHZhbHVlcy5jb2xvcik7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy10ZXh0LW9wYWNpdHkgPiBzZWxlY3QnKSwgdmFsdWVzLnRleHRPcGFjaXR5KTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0JyksIHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcpLCB2YWx1ZXMuYmFja2dyb3VuZE9wYWNpdHkpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLndpbmRvd0NvbG9yKTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy53aW5kb3dPcGFjaXR5KTtcblxuICAgIGxldCBmb250UGVyY2VudCA9IHZhbHVlcy5mb250UGVyY2VudDtcblxuICAgIGlmIChmb250UGVyY2VudCkge1xuICAgICAgZm9udFBlcmNlbnQgPSBmb250UGVyY2VudC50b0ZpeGVkKDIpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JyksIGZvbnRQZXJjZW50KTtcbiAgfVxuXG4gIHJlc3RvcmVTZXR0aW5ncygpIHtcbiAgICBsZXQgdmFsdWVzO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBzYWZlUGFyc2VUdXBsZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJykpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5vcHRpb25zKClbJ3BlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghTGliLmlzRW1wdHkodmFsdWVzKSkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgbGV0IHR0RGlzcGxheSA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgndGV4dFRyYWNrRGlzcGxheScpO1xuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0YXJnZXQpIHtcbiAgbGV0IHNlbGVjdGVkT3B0aW9uO1xuICAvLyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgc2VsZWN0ZWRPcHRpb25zLCBzbywgZmFsbGJhY2sgdG8gb3B0aW9uc1xuICBpZiAodGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgfSBlbHNlIGlmICh0YXJnZXQub3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0Lm9wdGlvbnNbdGFyZ2V0Lm9wdGlvbnMuc2VsZWN0ZWRJbmRleF07XG4gIH1cblxuICByZXR1cm4gc2VsZWN0ZWRPcHRpb24udmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0Lm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSB0YXJnZXQub3B0aW9uc1tpXTtcbiAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnNlbGVjdGVkSW5kZXggPSBpO1xufVxuXG5mdW5jdGlvbiBjYXB0aW9uT3B0aW9uc01lbnVUZW1wbGF0ZSgpIHtcbiAgbGV0IHRlbXBsYXRlID0gYDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5nc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInZqcy10cmFja3NldHRpbmdzLWNvbG9yc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPkZvcmVncm91bmQ8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tLTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGRlwiPldoaXRlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDAwXCI+QmxhY2s8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMDBcIj5SZWQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRjBcIj5HcmVlbjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwRlwiPkJsdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRjBcIj5ZZWxsb3c8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMEZcIj5NYWdlbnRhPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEZGXCI+Q3lhbjwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy10ZXh0LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj5cbiAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1mZy1jb2xvciAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1iZy1jb2xvciB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5CYWNrZ3JvdW5kPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRkZcIj5XaGl0ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwMFwiPkJsYWNrPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjAwXCI+UmVkPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEYwXCI+R3JlZW48L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMEZcIj5CbHVlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkYwXCI+WWVsbG93PC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjBGXCI+TWFnZW50YTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGRlwiPkN5YW48L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtYmctb3BhY2l0eSB2anMtb3BhY2l0eVwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiPk9wYXF1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNVwiPlNlbWktVHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+VHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWJnLWNvbG9yIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwid2luZG93LWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPldpbmRvdzwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkZGXCI+V2hpdGU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMDBcIj5CbGFjazwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwMFwiPlJlZDwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGMFwiPkdyZWVuPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDBGXCI+Qmx1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGMFwiPlllbGxvdzwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwRlwiPk1hZ2VudGE8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRkZcIj5DeWFuPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+T3BhcXVlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjBcIj5UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtd2luZG93LWNvbG9yIC0tPlxuICAgICAgPC9kaXY+IDwhLS0gdmpzLXRyYWNrc2V0dGluZ3MgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtZm9udFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwidmpzLWxhYmVsXCI+Rm9udCBTaXplPC9sYWJlbD5cbiAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNTBcIj41MCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwLjc1XCI+NzUlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS4wMFwiIHNlbGVjdGVkPjEwMCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjI1XCI+MTI1JTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEuNTBcIj4xNTAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS43NVwiPjE3NSU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyLjAwXCI+MjAwJTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjMuMDBcIj4zMDAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNC4wMFwiPjQwMCU8L29wdGlvbj5cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWZvbnQtcGVyY2VudCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5UZXh0IEVkZ2UgU3R5bGU8L2xhYmVsPlxuICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibm9uZVwiPk5vbmU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyYWlzZWRcIj5SYWlzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJkZXByZXNzZWRcIj5EZXByZXNzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ1bmlmb3JtXCI+VW5pZm9ybTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRyb3BzaGFkb3dcIj5Ecm9wc2hhZG93PC9vcHRpb24+XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1lZGdlLXN0eWxlIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5Gb250IEZhbWlseTwvbGFiZWw+XG4gICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5EZWZhdWx0PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibW9ub3NwYWNlU2VyaWZcIj5Nb25vc3BhY2UgU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJwcm9wb3J0aW9uYWxTZXJpZlwiPlByb3BvcnRpb25hbCBTZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1vbm9zcGFjZVNhbnNTZXJpZlwiPk1vbm9zcGFjZSBTYW5zLVNlcmlmPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicHJvcG9ydGlvbmFsU2Fuc1NlcmlmXCI+UHJvcG9ydGlvbmFsIFNhbnMtU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjYXN1YWxcIj5DYXN1YWw8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzY3JpcHRcIj5TY3JpcHQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzbWFsbC1jYXBzXCI+U21hbGwgQ2Fwczwvb3B0aW9uPlxuICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtZm9udC1mYW1pbHkgLS0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtY29udHJvbHNcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJ2anMtZGVmYXVsdC1idXR0b25cIj5EZWZhdWx0czwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInZqcy1kb25lLWJ1dHRvblwiPkRvbmU8L2J1dHRvbj5cbiAgICA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tTZXR0aW5ncztcbiIsImltcG9ydCBUZXh0VHJhY2tDdWVMaXN0IGZyb20gJy4vdGV4dC10cmFjay1jdWUtbGlzdCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliJztcbmltcG9ydCAqIGFzIFRleHRUcmFja0VudW0gZnJvbSAnLi90ZXh0LXRyYWNrLWVudW1zJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgWEhSIGZyb20gJy4uL3hoci5qcyc7XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrXG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFjayA6IEV2ZW50VGFyZ2V0IHtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0tpbmQga2luZDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYWJlbDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYW5ndWFnZTtcbiAqXG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaWQ7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZTtcbiAqXG4gKiAgIGF0dHJpYnV0ZSBUZXh0VHJhY2tNb2RlIG1vZGU7XG4gKlxuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrQ3VlTGlzdD8gY3VlcztcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0N1ZUxpc3Q/IGFjdGl2ZUN1ZXM7XG4gKlxuICogICB2b2lkIGFkZEN1ZShUZXh0VHJhY2tDdWUgY3VlKTtcbiAqICAgdm9pZCByZW1vdmVDdWUoVGV4dFRyYWNrQ3VlIGN1ZSk7XG4gKlxuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9uY3VlY2hhbmdlO1xuICogfTtcbiAqL1xubGV0IFRleHRUcmFjayA9IGZ1bmN0aW9uKG9wdGlvbnM9e30pIHtcbiAgaWYgKCFvcHRpb25zWydwbGF5ZXInXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBwbGF5ZXIgd2FzIG5vdCBwcm92aWRlZC4nKTtcbiAgfVxuXG4gIGxldCB0dCA9IHRoaXM7XG4gIGlmIChMaWIuSVNfSUU4KSB7XG4gICAgdHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gVGV4dFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgdHRbcHJvcF0gPSBUZXh0VHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHR0LnBsYXllcl8gPSBvcHRpb25zWydwbGF5ZXInXTtcblxuICBsZXQgbW9kZSA9IFRleHRUcmFja0VudW0uVGV4dFRyYWNrTW9kZVtvcHRpb25zWydtb2RlJ11dIHx8ICdkaXNhYmxlZCc7XG4gIGxldCBraW5kID0gVGV4dFRyYWNrRW51bS5UZXh0VHJhY2tLaW5kW29wdGlvbnNbJ2tpbmQnXV0gfHwgJ3N1YnRpdGxlcyc7XG4gIGxldCBsYWJlbCA9IG9wdGlvbnNbJ2xhYmVsJ10gfHwgJyc7XG4gIGxldCBsYW5ndWFnZSA9IG9wdGlvbnNbJ2xhbmd1YWdlJ10gfHwgb3B0aW9uc1snc3JjbGFuZyddIHx8ICcnO1xuICBsZXQgaWQgPSBvcHRpb25zWydpZCddIHx8ICd2anNfdGV4dF90cmFja18nICsgTGliLmd1aWQrKztcblxuICBpZiAoa2luZCA9PT0gJ21ldGFkYXRhJyB8fCBraW5kID09PSAnY2hhcHRlcnMnKSB7XG4gICAgbW9kZSA9ICdoaWRkZW4nO1xuICB9XG5cbiAgdHQuY3Vlc18gPSBbXTtcbiAgdHQuYWN0aXZlQ3Vlc18gPSBbXTtcblxuICBsZXQgY3VlcyA9IG5ldyBUZXh0VHJhY2tDdWVMaXN0KHR0LmN1ZXNfKTtcbiAgbGV0IGFjdGl2ZUN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5hY3RpdmVDdWVzXyk7XG5cbiAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgbGV0IHRpbWV1cGRhdGVIYW5kbGVyID0gTGliLmJpbmQodHQsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ2FjdGl2ZUN1ZXMnXTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpc1sndHJpZ2dlciddKCdjdWVjaGFuZ2UnKTtcbiAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuICAgIHR0LnBsYXllcl8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdraW5kJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ga2luZDtcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2xhYmVsJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdsYW5ndWFnZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnaWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ21vZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgICBpZiAoIVRleHRUcmFja0VudW0uVGV4dFRyYWNrTW9kZVtuZXdNb2RlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlID0gbmV3TW9kZTtcbiAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlY2hhbmdlJyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdjdWVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1ZXM7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdhY3RpdmVDdWVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbJ2N1ZXMnXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgIH1cblxuICAgICAgbGV0IGN0ID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgICBsZXQgYWN0aXZlID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpc1snY3VlcyddLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsZXQgY3VlID0gdGhpc1snY3VlcyddW2ldO1xuICAgICAgICBpZiAoY3VlWydzdGFydFRpbWUnXSA8PSBjdCAmJiBjdWVbJ2VuZFRpbWUnXSA+PSBjdCkge1xuICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VlWydzdGFydFRpbWUnXSA9PT0gY3VlWydlbmRUaW1lJ10gJiYgY3VlWydzdGFydFRpbWUnXSA8PSBjdCAmJiBjdWVbJ3N0YXJ0VGltZSddICsgMC41ID49IGN0KSB7XG4gICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChhY3RpdmUubGVuZ3RoICE9PSB0aGlzLmFjdGl2ZUN1ZXNfLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLmFjdGl2ZUN1ZXNfLCBhY3RpdmVbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aXZlQ3Vlc18gPSBhY3RpdmU7XG4gICAgICBhY3RpdmVDdWVzLnNldEN1ZXNfKHRoaXMuYWN0aXZlQ3Vlc18pO1xuXG4gICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIGlmIChvcHRpb25zLnNyYykge1xuICAgIGxvYWRUcmFjayhvcHRpb25zLnNyYywgdHQpO1xuICB9IGVsc2Uge1xuICAgIHR0LmxvYWRlZF8gPSB0cnVlO1xuICB9XG5cbiAgaWYgKExpYi5JU19JRTgpIHtcbiAgICByZXR1cm4gdHQ7XG4gIH1cbn07XG5cblRleHRUcmFjay5wcm90b3R5cGUgPSBMaWIub2JqLmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblRleHRUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0VHJhY2s7XG5cbi8qXG4gKiBjdWVjaGFuZ2UgLSBPbmUgb3IgbW9yZSBjdWVzIGluIHRoZSB0cmFjayBoYXZlIGJlY29tZSBhY3RpdmUgb3Igc3RvcHBlZCBiZWluZyBhY3RpdmUuXG4gKi9cblRleHRUcmFjay5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gICdjdWVjaGFuZ2UnOiAnY3VlY2hhbmdlJ1xufTtcblxuVGV4dFRyYWNrLnByb3RvdHlwZS5hZGRDdWUgPSBmdW5jdGlvbihjdWUpIHtcbiAgbGV0IHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgaWYgKHRyYWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XG4gICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmN1ZXNfLnB1c2goY3VlKTtcbiAgdGhpc1snY3VlcyddLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xufTtcblxuVGV4dFRyYWNrLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbihyZW1vdmVDdWUpIHtcbiAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY3Vlc18ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGN1ZSA9IHRoaXMuY3Vlc19baV07XG4gICAgaWYgKGN1ZSA9PT0gcmVtb3ZlQ3VlKSB7XG4gICAgICB0aGlzLmN1ZXNfLnNwbGljZShpLCAxKTtcbiAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdmVkKSB7XG4gICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICB9XG59O1xuXG4vKlxuICogRG93bmxvYWRpbmcgc3R1ZmYgaGFwcGVucyBiZWxvdyB0aGlzIHBvaW50XG4gKi9cbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbihzcmNDb250ZW50LCB0cmFjaykge1xuICBpZiAodHlwZW9mIHdpbmRvd1snV2ViVlRUJ10gIT09ICdmdW5jdGlvbicpIHtcbiAgICAvL3RyeSBhZ2FpbiBhIGJpdCBsYXRlclxuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHBhcnNlQ3VlcyhzcmNDb250ZW50LCB0cmFjayk7XG4gICAgfSwgMjUpO1xuICB9XG5cbiAgbGV0IHBhcnNlciA9IG5ldyB3aW5kb3dbJ1dlYlZUVCddWydQYXJzZXInXSh3aW5kb3csIHdpbmRvd1sndnR0anMnXSwgd2luZG93WydXZWJWVFQnXVsnU3RyaW5nRGVjb2RlciddKCkpO1xuXG4gIHBhcnNlclsnb25jdWUnXSA9IGZ1bmN0aW9uKGN1ZSkge1xuICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICB9O1xuICBwYXJzZXJbJ29ucGFyc2luZ2Vycm9yJ10gPSBmdW5jdGlvbihlcnJvcikge1xuICAgIExpYi5sb2cuZXJyb3IoZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlclsncGFyc2UnXShzcmNDb250ZW50KTtcbiAgcGFyc2VyWydmbHVzaCddKCk7XG59O1xuXG52YXIgbG9hZFRyYWNrID0gZnVuY3Rpb24oc3JjLCB0cmFjaykge1xuICBYSFIoc3JjLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBMaWIubG9nLmVycm9yKGVycik7XG4gICAgfVxuXG5cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcbiAgICBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gIH0pKTtcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gIGlmICh0aGlzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gIH1cblxuICBsZXQgTyA9IE9iamVjdCh0aGlzKTtcblxuICBsZXQgbGVuID0gTy5sZW5ndGggPj4+IDA7XG5cbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGxldCBuID0gK2Zyb21JbmRleCB8fCAwO1xuXG4gIGlmIChNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkpIHtcbiAgICBuID0gMDtcbiAgfVxuXG4gIGlmIChuID49IGxlbikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGxldCBrID0gTWF0aC5tYXgobiA+PSAwID8gbiA6IGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblxuICB3aGlsZSAoayA8IGxlbikge1xuICAgIGlmIChrIGluIE8gJiYgT1trXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGsrKztcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2s7XG4iLCJpbXBvcnQgeyBvYmogfSBmcm9tICcuL2xpYic7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgbmFtZXNwYWNlXG4gKiBAbmFtZXNwYWNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdXRpbCA9IHt9O1xuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb25zIG9iamVjdHMsIHJlY3Vyc2l2ZWx5IG1lcmdpbmcgYW55IHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzIGFzXG4gKiB3ZWxsLiAgUHJldmlvdXNseSBgZGVlcE1lcmdlYFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqMSBPYmplY3QgdG8gb3ZlcnJpZGUgdmFsdWVzIGluXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajIgT3ZlcnJpZGluZyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICBOZXcgb2JqZWN0IC0tIG9iajEgYW5kIG9iajIgd2lsbCBiZSB1bnRvdWNoZWRcbiAqL1xudmFyIG1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uKG9iajEsIG9iajIpe1xuICB2YXIga2V5LCB2YWwxLCB2YWwyO1xuXG4gIC8vIG1ha2UgYSBjb3B5IG9mIG9iajEgc28gd2UncmUgbm90IG92ZXJ3cml0aW5nIG9yaWdpbmFsIHZhbHVlcy5cbiAgLy8gbGlrZSBwcm90b3R5cGUub3B0aW9uc18gYW5kIGFsbCBzdWIgb3B0aW9ucyBvYmplY3RzXG4gIG9iajEgPSBvYmouY29weShvYmoxKTtcblxuICBmb3IgKGtleSBpbiBvYmoyKXtcbiAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YWwxID0gb2JqMVtrZXldO1xuICAgICAgdmFsMiA9IG9iajJba2V5XTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwcm9wZXJ0aWVzIGFyZSBwdXJlIG9iamVjdHMgYW5kIGRvIGEgZGVlcCBtZXJnZSBpZiBzb1xuICAgICAgaWYgKG9iai5pc1BsYWluKHZhbDEpICYmIG9iai5pc1BsYWluKHZhbDIpKSB7XG4gICAgICAgIG9iajFba2V5XSA9IG1lcmdlT3B0aW9ucyh2YWwxLCB2YWwyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iajFba2V5XSA9IG9iajJba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajE7XG59O1xuXG5leHBvcnQgeyBtZXJnZU9wdGlvbnMgfTtcbiIsImltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG5pbXBvcnQgTWVkaWFMb2FkZXIgZnJvbSAnLi90ZWNoL2xvYWRlci5qcyc7XG5pbXBvcnQgSHRtbDUgZnJvbSAnLi90ZWNoL2h0bWw1LmpzJztcbmltcG9ydCBGbGFzaCBmcm9tICcuL3RlY2gvZmxhc2guanMnO1xuaW1wb3J0IFBvc3RlckltYWdlIGZyb20gJy4vcG9zdGVyLWltYWdlLmpzJztcbmltcG9ydCBUZXh0VHJhY2tEaXNwbGF5IGZyb20gJy4vdHJhY2tzL3RleHQtdHJhY2stZGlzcGxheS5qcyc7XG5pbXBvcnQgTG9hZGluZ1NwaW5uZXIgZnJvbSAnLi9sb2FkaW5nLXNwaW5uZXIuanMnO1xuaW1wb3J0IEJpZ1BsYXlCdXR0b24gZnJvbSAnLi9iaWctcGxheS1idXR0b24uanMnO1xuaW1wb3J0IENvbnRyb2xCYXIgZnJvbSAnLi9jb250cm9sLWJhci9jb250cm9sLWJhci5qcyc7XG5pbXBvcnQgRXJyb3JEaXNwbGF5IGZyb20gJy4vZXJyb3ItZGlzcGxheS5qcyc7XG5cbmltcG9ydCB2aWRlb2pzIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgKiBhcyBzZXR1cCBmcm9tICcuL3NldHVwJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCBQbGF5ZXIgZnJvbSAnLi9wbGF5ZXInO1xuaW1wb3J0IGV4dGVuZHNGbiBmcm9tICcuL2V4dGVuZHMuanMnO1xuXG5pZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG59XG5cbi8vIFJ1biBBdXRvLWxvYWQgcGxheWVyc1xuLy8gWW91IGhhdmUgdG8gd2FpdCBhdCBsZWFzdCBvbmNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIGFmdGVyIHlvdXIgdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5zZXR1cC5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xuXG52aWRlb2pzLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG52aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50O1xuXG4vLyBBUElzIHRoYXQgd2lsbCBiZSByZW1vdmVkIHdpdGggNS4wLCBidXQgbmVlZCB0aGVtIHRvIGdldCB0ZXN0cyBwYXNzaW5nXG4vLyBpbiBFUzYgdHJhbnNpdGlvblxudmlkZW9qcy5UT1VDSF9FTkFCTEVEID0gTGliLlRPVUNIX0VOQUJMRUQ7XG52aWRlb2pzLnV0aWwgPSBVdGlsO1xuXG4vLyBQcm9iYWJseSB3YW50IHRvIGtlZXAgdGhpcyBvbmUgZm9yIDUuMD9cbnZpZGVvanMucGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuXG52aWRlb2pzLmV4dGVuZHMgPSBleHRlbmRzRm47XG5cbi8vIFJFTU9WSU5HOiBXZSBwcm9iYWJseSBzaG91bGQgbm90IGluY2x1ZGUgdGhpcyBpbiA1LjAgdGhvdWdodCBpdCB3b3VsZCBtYWtlIGl0XG4vLyBtb3JlIGJhY2t3YXJkcyBjb21wYXRpYmxlXG4vLyAvLyBFeHBvc2UgYnV0IGRlcHJlY2F0ZSB0aGUgd2luZG93W2NvbXBvbmVudE5hbWVdIG1ldGhvZCBmb3IgYWNjZXNzaW5nIGNvbXBvbmVudHNcbi8vIExpYi5vYmouZWFjaChDb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24obmFtZSwgY29tcG9uZW50KXtcbi8vICAgLy8gQSBkZXByZWNhdGlvbiB3YXJuaW5nIGFzIHRoZSBjb25zdHVjdG9yXG4vLyAgIG1vZHVsZS5leHBvcnRzW25hbWVdID0gZnVuY3Rpb24ocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4vLyAgICAgTGliLmxvZy53YXJuKCdVc2luZyB2aWRlb2pzLicrbmFtZSsnIHRvIGFjY2VzcyB0aGUgJytuYW1lKycgY29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdmlkZW9qcy5nZXRDb21wb25lbnQoXCJjb21wb25lbnROYW1lXCIpJyk7XG4vL1xuLy8gICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuLy8gICB9O1xuLy9cbi8vICAgLy8gQWxsb3cgdGhlIHByb3RvdHlwZSBhbmQgY2xhc3MgbWV0aG9kcyB0byBiZSBhY2Nlc3NpYmxlIHN0aWxsIHRoaXMgd2F5XG4vLyAgIC8vIFRob3VnaCBhbnl0aGluZyB0aGF0IGF0dGVtcHRzIHRvIG92ZXJyaWRlIGNsYXNzIG1ldGhvZHMgd2lsbCBubyBsb25nZXIgd29ya1xuLy8gICBMaWIub2JqLm1lcmdlKG1vZHVsZS5leHBvcnRzW25hbWVdLCBjb21wb25lbnQpO1xuLy8gfSk7XG5cbmV4cG9ydCBkZWZhdWx0IHZpZGVvanM7XG4iLCJpbXBvcnQgKiBhcyBWanNVdGlscyBmcm9tICcuL3V0aWwnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4vbGliJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbi8qKlxuICogU2ltcGxlIGh0dHAgcmVxdWVzdCBmb3IgcmV0cmlldmluZyBleHRlcm5hbCBmaWxlcyAoZS5nLiB0ZXh0IHRyYWNrcylcbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogICAgIC8vIHVzaW5nIHVybCBzdHJpbmdcbiAqICAgICB2aWRlb2pzLnhocignaHR0cDovL2V4YW1wbGUuY29tL215ZmlsZS52dHQnLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSl7fSk7XG4gKlxuICogICAgIC8vIG9yIG9wdGlvbnMgYmxvY2tcbiAqICAgICB2aWRlb2pzLnhocih7XG4gKiAgICAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vbXlmaWxlLnZ0dCcsXG4gKiAgICAgICBtZXRob2Q6ICdHRVQnLFxuICogICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcbiAqICAgICB9LCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSl7XG4gKiAgICAgICBpZiAoZXJyb3IpIHtcbiAqICAgICAgICAgLy8gbG9nIHRoZSBlcnJvclxuICogICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgLy8gc3VjY2Vzc2Z1bCwgZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIEFQSSBpcyBtb2RlbGVkIGFmdGVyIHRoZSBSYXlub3MveGhyLCB3aGljaCB3ZSBob3BlIHRvIHVzZSBhZnRlclxuICogZ2V0dGluZyBicm93c2VyaWZ5IGltcGxlbWVudGVkLlxuICogaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHIvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSAgb3B0aW9ucyAgIE9wdGlvbnMgYmxvY2sgb3IgVVJMIHN0cmluZ1xuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgVGhlIHJlcXVlc3RcbiAqL1xudmFyIHhociA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgbGV0IGFib3J0VGltZW91dDtcblxuICAvLyBJZiBvcHRpb25zIGlzIGEgc3RyaW5nIGl0J3MgdGhlIHVybFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICAvLyBNZXJnZSB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICBWanNVdGlscy5tZXJnZU9wdGlvbnMoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdGltZW91dDogNDUgKiAxMDAwXG4gIH0sIG9wdGlvbnMpO1xuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKXt9O1xuXG4gIGxldCBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG5cbiAgaWYgKHR5cGVvZiBYSFIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gU2hpbSBYTUxIdHRwUmVxdWVzdCBmb3Igb2xkZXIgSUVzXG4gICAgWEhSID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHsgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0cnkgeyByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaCAoZikge31cbiAgICAgIHRyeSB7IHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2ggKGcpIHt9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LicpO1xuICAgIH07XG4gIH1cblxuICBsZXQgcmVxdWVzdCA9IG5ldyBYSFIoKTtcbiAgLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHVybCBvbiB0aGUgcmVxdWVzdCBpbnN0YW5jZVxuICByZXF1ZXN0LnVyaSA9IG9wdGlvbnMudXJpO1xuXG4gIGxldCB1cmxJbmZvID0gTGliLnBhcnNlVXJsKG9wdGlvbnMudXJpKTtcbiAgbGV0IHdpbkxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICBsZXQgc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LCByZXF1ZXN0LnJlc3BvbnNlIHx8IHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfTtcblxuICBsZXQgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKXtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dCk7XG5cbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyID0gbmV3IEVycm9yKGVycik7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyLCByZXF1ZXN0KTtcbiAgfTtcblxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxuICAvLyBJRTggZG9lc24ndCBrbm93IGxvY2F0aW9uLm9yaWdpbiwgc28gd2Ugd29uJ3QgcmVseSBvbiBpdCBoZXJlXG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gKHVybEluZm8ucHJvdG9jb2wgKyB1cmxJbmZvLmhvc3QpICE9PSAod2luTG9jLnByb3RvY29sICsgd2luTG9jLmhvc3QpO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IC0tIFVzZSBmb3IgSUUgaWYgWE1MSFRUUFJlcXVlc3QyIGlzbid0IGF2YWlsYWJsZVxuICAvLyAnd2l0aENyZWRlbnRpYWxzJyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBYTUxIVFRQUmVxdWVzdDJcbiAgLy8gQWxzbyBYRG9tYWluUmVxdWVzdCBoYXMgYSBsb3Qgb2YgZ290Y2hhcywgc28gb25seSB1c2UgaWYgY3Jvc3MgZG9tYWluXG4gIGlmIChjcm9zc09yaWdpbiAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSkge1xuICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgLy8gVGhlc2UgYmxhbmsgaGFuZGxlcnMgbmVlZCB0byBiZSBzZXQgdG8gZml4IGllOVxuICAgIC8vIGh0dHA6Ly9jeXByZXNzbm9ydGguY29tL3Byb2dyYW1taW5nL2ludGVybmV0LWV4cGxvcmVyLWFib3J0aW5nLWFqYXgtcmVxdWVzdHMtZml4ZWQvXG4gICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKXt9O1xuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIFhNTEhUVFBSZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlsZVVybCA9ICh1cmxJbmZvLnByb3RvY29sID09ICdmaWxlOicgfHwgd2luTG9jLnByb3RvY29sID09ICdmaWxlOicpO1xuXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QudGltZWRvdXQpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKCd0aW1lb3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCBmaWxlVXJsICYmIHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgc3VjY2Vzc0hhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBhYm9ydFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJlcXVlc3QudGltZWRvdXQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvLyBvcGVuIHRoZSBjb25uZWN0aW9uXG4gIHRyeSB7XG4gICAgLy8gVGhpcmQgYXJnIGlzIGFzeW5jLCBvciBpZ25vcmVkIGJ5IFhEb21haW5SZXF1ZXN0XG4gICAgcmVxdWVzdC5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBvcHRpb25zLnVyaSwgdHJ1ZSk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcihlcnIpO1xuICB9XG5cbiAgLy8gd2l0aENyZWRlbnRpYWxzIG9ubHkgc3VwcG9ydGVkIGJ5IFhNTEh0dHBSZXF1ZXN0MlxuICBpZihvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHRoZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgcmVxdWVzdC5zZW5kKCk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB4aHI7XG4iXX0=
